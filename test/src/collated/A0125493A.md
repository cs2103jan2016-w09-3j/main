# A0125493A
###### logic\SearchModule.java
``` java
 *
 *          File used by TaskEntityManager to search for terms in its list
 */
package logic;

import java.util.ArrayList;

import entity.TaskEntity;

public class SearchModule {

    /**
     * Searches the hashtag, description and name of TaskEntity for a search
     * term and append it to search results
     * 
     * @param searchTerm - Sub string to locate within each items's description,
     *            name and hashtag
     * @param listToSearch - ArrayList to carry out the search on
     * @param searchResults - ArrayList to place results into
     */
    public static void searchStringAddToResults(String searchTerm, ArrayList<TaskEntity> listToSearch,
            ArrayList<TaskEntity> searchResults) {
        String lowerCaseSearchTerm = searchTerm.toLowerCase();

        String[] searchTerms = lowerCaseSearchTerm.split(" ");

        for (int i = 0; i < listToSearch.size(); i++) {

            if (listToSearch.get(i).getName() == null || listToSearch.get(i).getDescription() == null
                    || listToSearch.get(i).getHashtags() == null) {
                System.out.println("ERROR in searchModule: Certain search fields null");
                // Skip searching this faulty task
                continue;
            }

            boolean isSearchTermFound = false;

            isSearchTermFound = searchAllTerms(listToSearch.get(i), searchTerms);

            if (isSearchTermFound) {
                searchResults.add(listToSearch.get(i));
            }
        }
    }

    /**
     * Searches to ensure all terms seperated by a spacing are ALL located
     * within the task that is being searched before adding it as a result
     * 
     * @param listToSearch
     * @param searchTerms - Each term that is seperated by a spacing
     * @param i
     * @return
     */
    private static boolean searchAllTerms(TaskEntity taskToSearch, String[] searchTerms) {
        boolean isSearchTermFound = false;

        for (int j = 0; j < searchTerms.length; j++) {
            isSearchTermFound = false;

            if (taskToSearch.getName().toLowerCase().contains(searchTerms[j])
                    || taskToSearch.getDescription().toLowerCase().contains(searchTerms[j])) {
                isSearchTermFound = true;
            } else if (taskToSearch.getHashtags().toLowerCase().contains(searchTerms[j])) {
                if (checkHashMatch(searchTerms[j], taskToSearch)) {
                    isSearchTermFound = true;
                } else {
                    // Hashtag not found. Conclude as not added by breaking the
                    // loop, effctively leaving searchTermFound as false
                    break;
                }
            } else {
                // One of the words/terms not found. Conclude as not added
                // by breaking the loop, effectively leaving searchTermFound as
                // false
                break;
            }
        }

        return isSearchTermFound;
    }

    /**
     * If the term searched is a hashtag, check if it matches exactly
     * 
     * @param searchTerm - Search term passed in
     * @param currentItemSearched - Item that is being searched for the hashtag
     * @return true if there is an exact match in the list of hashtags in the
     *         currentItemSearched
     *         false otherwise
     */
    public static boolean checkHashMatch(String searchTerm, TaskEntity currentItemSearched) {
        // Length set as 2 as minimum hash is a # with one character. No empty
        // hashtags allowed
        if (searchTerm.length() >= 2) {
            // Checks if current search term is a hashtag
            if (searchTerm.charAt(0) == '#') {
                String hashTerm = searchTerm.substring(1);
                String[] itemHashes = currentItemSearched.getHashtags().split("#");

                for (int i = 0; i < itemHashes.length; i++) {
                    if (itemHashes[i].equalsIgnoreCase(hashTerm)) {
                        return true;
                    }
                }
                // If none of the hashes match
                return false;
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

}
```
###### logic\TaskCompletionTimeComparator.java
``` java
 * 
 *          Comparator to sort tasks based off their completion time
 */
package logic;

import java.util.Comparator;

import entity.TaskEntity;

public class TaskCompletionTimeComparator implements Comparator<TaskEntity> {
    private final String ERROR_DATE_NULL = "Error at TaskCompletionTime: Completion date of one date is null";

    public int compare(TaskEntity task1, TaskEntity task2) {
        if (task1.getCompletionDate() == null || task2.getCompletionDate() == null) {
            System.out.println(ERROR_DATE_NULL);
            return 0;
        }
        return task1.getCompletionDate().compareTo(task2.getCompletionDate());
    }
}
```
###### logic\TaskDateComparator.java
``` java
 * 
 *          Comparator used to sort the tasks in the timed arrayList
 */
package logic;

import java.util.Calendar;
import java.util.Comparator;

import entity.TaskEntity;

public class TaskDateComparator implements Comparator<TaskEntity> {
    private final static String ERROR_COMPAREFLOATING = "Error in TaskDateComparator.java: Trying to compare time on a floating task";
    private final static String ERROR_DATENULL = "Error in TaskDateComparator.java: Main task has both start and end time as null when comparing";

    public int compareTime(TaskEntity task1, TaskEntity task2) {
        Calendar task1TimeToCompare;
        Calendar task2TimeToCompare;

        task1TimeToCompare = chooseDateToCompare(task1);
        task2TimeToCompare = chooseDateToCompare(task2);

        // Error catching
        if (task1TimeToCompare == null || task2TimeToCompare == null) {
            return 0;
        }

        return task1TimeToCompare.compareTo(task2TimeToCompare);
    }

    private Calendar chooseDateToCompare(TaskEntity task) {
        if (task.getStartDate() != null) {
            return task.getStartDate();
        } else if (task.getDueDate() != null) {
            return task.getDueDate();
        } else {
            if (task.isFloating()) {
                System.out.println(ERROR_COMPAREFLOATING);
            } else {
                System.out.println(ERROR_DATENULL);
            }
            return null;
        }
    }

    public int compare(TaskEntity task1, TaskEntity task2) {
        if (task1.isFloating() || task2.isFloating()) {
            return compareFloating(task1, task2);
        } else {
            Calendar date1 = chooseDateToCompare(task1);
            Calendar date2 = chooseDateToCompare(task2);

            // 0 being returned means both tasks have the same date on the
            // calendar.
            // Terminate if different days, carry on sorting them if they are
            // the
            // same day
            int differentDayResult = compareDifferentDay(date1, date2);
            if (differentDayResult != 0) {
                return differentDayResult;
            }

            return compareFullDayTask(task1, task2, date1, date2);
        }
    }

    private int compareFloating(TaskEntity task1, TaskEntity task2) {
        if (task1.isFloating() && !task2.isFloating()) {
            return -1;
        } else if (!task1.isFloating() && task2.isFloating()) {
            return 1;
        } else {
            return task1.getName().compareToIgnoreCase(task2.getName());
        }
    }

    private int compareFullDayTask(TaskEntity task1, TaskEntity task2, Calendar date1, Calendar date2) {
        if (task1.isFullDay() && !task2.isFullDay()) {
            return -1;
        } else if (!task1.isFullDay() && task2.isFullDay()) {
            return 1;
        } else if (!task1.isFullDay() && !task2.isFullDay()) {
            return compareTime(task1, task2);
        } else {
            // If both tasks are full day, sort them alphabetically
            return task1.getName().compareToIgnoreCase(task2.getName());
        }
    }

    private int compareDifferentDay(Calendar date1, Calendar date2) {
        if (date1.get(Calendar.YEAR) > date2.get(Calendar.YEAR)) {
            return 1;
        } else if (date1.get(Calendar.YEAR) < date2.get(Calendar.YEAR)) {
            return -1;
        } else if (date1.get(Calendar.MONTH) > date2.get(Calendar.MONTH)) {
            return 1;
        } else if (date1.get(Calendar.MONTH) < date2.get(Calendar.MONTH)) {
            return -1;
        } else if (date1.get(Calendar.DATE) > date2.get(Calendar.DATE)) {
            return 1;
        } else if (date1.get(Calendar.DATE) < date2.get(Calendar.DATE)) {
            return -1;
        }
        return 0;
    }
}
```
###### logic\TaskManager.java
``` java
 * 
 *          Class to manage the handling of tasks during runtime. Singleton
 *          class, use GetInstance() to use this class
 */
package logic;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Random;
import java.util.logging.FileHandler;
import java.util.logging.Handler;
import java.util.logging.Level;
import java.util.logging.Logger;

import edu.emory.mathcs.backport.java.util.Collections;
import entity.AllTaskLists;
import entity.ResultSet;
import entity.TaskEntity;
import storage.StorageInterface;

public class TaskManager {
    private StorageInterface dataLoader;

    private static TaskManager singleton;
    private Logger logger;

    private int currentDisplayedList;
    private static ArrayList<TaskEntity> displayedTasks;
    private static ArrayList<TaskEntity> floatingTaskEntities = new ArrayList<TaskEntity>();
    private static ArrayList<TaskEntity> mainTaskEntities = new ArrayList<TaskEntity>();
    private static ArrayList<TaskEntity> completedTaskEntities = new ArrayList<TaskEntity>();

    private static ArrayList<String> undoCommands = new ArrayList<String>();
    private int undoPointer = -1;
    private boolean isUndoing = false;

    private static ArrayList<TaskEntity> searchedTasks = new ArrayList<TaskEntity>();

    public final static int DISPLAY_MAIN = 0;
    public final static int DISPLAY_FLOATING = 1;
    public final static int DISPLAY_SEARCH = 2;
    public final static int DISPLAY_COMPLETED = 3;
    public final static int DISPLAY_OTHERS = 4;

    private boolean isJsonSuccess = true;

    /**
     * Function for loadFrom to reset the undo stack upon loading other file
     */
    private void resetUndo() {
        undoCommands = new ArrayList<String>();
        undoPointer = -1;
        isUndoing = false;
    }

    /**
     * Startup function to call and check if there was corrupted data read by
     * storage. Data passed up from storage
     * 
     * @return false if data was corrupted
     *         true if data was successfully loaded
     */
    public boolean checkLoad() {
        return isJsonSuccess;
    }

    /**
     * Prints out all the names of the tasks in the main array
     * 
     * @param display
     *            - default - to print out the array currently in focus
     *            (inclusive of DISPLAY_OTHERS)
     *            - DISPLAY_MAIN - to print out the timed tasks array
     *            - DISPLAY_FLOATING - to print out the floating tasks array
     *            - DISPLAY_SEARCH - to print out the searched tasks array
     * 
     * @return a string containing all the names of the tasks in the ArrayList
     *         printed, separated by a ", " including at the end of the last
     *         task printed
     */
    public String printArrayContentsToString(int display) {
        ArrayList<TaskEntity> arrayToBePrinted = chooseArray(display);
        String arrayContents = appendTaskNameToString(arrayToBePrinted);
        return arrayContents;
    }

    /**
     * Each name in the ArrayList is appended with ", " at the back of it and
     * all added to one return string in order
     * 
     * @param arrayToBePrinted
     * @return Every name in the ArrayList appended with ", " at the back of it
     *         and all concatenated together
     */
    private String appendTaskNameToString(ArrayList<TaskEntity> arrayToBePrinted) {
        String arrayContents = "";
        for (int i = 0; i < arrayToBePrinted.size(); i++) {
            arrayContents += arrayToBePrinted.get(i).getName() + ", ";
        }
        return arrayContents;
    }

    private ArrayList<TaskEntity> chooseArray(int display) {
        if (display == DISPLAY_MAIN) {
            return mainTaskEntities;
        } else if (display == DISPLAY_FLOATING) {
            return floatingTaskEntities;
        } else if (display == DISPLAY_SEARCH) {
            return searchedTasks;
        } else if (display == DISPLAY_COMPLETED) {
            return completedTaskEntities;
        } else {
            return displayedTasks;
        }
    }

    /**
     * Function for JUnit test case to print out the display associations of a
     * task
     * 
     * @param taskToBePrinted - Task whose array is to be printed
     */
    public String printAssociationsToString(TaskEntity taskToBePrinted) {
        String printedAssociations = "";
        ArrayList<TaskEntity> displayedAssociations = taskToBePrinted.getDisplayAssociations();

        for (int i = 0; i < displayedAssociations.size(); i++) {
            printedAssociations += displayedAssociations.get(i).getName() + ",";
        }

        return printedAssociations;
    }

    /**
     * Function to clear saved file data from its array. For Junit testing
     */
    public void unloadFile() {
        floatingTaskEntities.clear();
        mainTaskEntities.clear();
        completedTaskEntities.clear();
        switchView(DISPLAY_MAIN);
    }

    /**
     * Initialization function to be called before usage of TaskManager class
     */
    @SuppressWarnings("unchecked")
    private TaskManager() {
        initLogger();

        dataLoader = new StorageInterface();
        AllTaskLists taskdata = dataLoader.getTaskLists();

        // Json load failure
        if (taskdata == null) {
            mainTaskEntities = new ArrayList<TaskEntity>();
            floatingTaskEntities = new ArrayList<TaskEntity>();
            isJsonSuccess = false;
        } else {
            mainTaskEntities = (ArrayList<TaskEntity>) taskdata.getMainTaskList().clone();
            floatingTaskEntities = (ArrayList<TaskEntity>) taskdata.getFloatingTaskList().clone();

            initializeAssociations();

            updateTaskEntityCurrentId();
            buildCompletedTasks();
        }
        displayedTasks = (ArrayList<TaskEntity>) mainTaskEntities.clone();
        currentDisplayedList = DISPLAY_MAIN;

    }

    /**
     * For loading of files. Extracting completed tasks from main and floating
     * task lists
     */
    public void buildCompletedTasks() {
        completedTaskEntities = new ArrayList<TaskEntity>();

        buildCompletedMainTasks();
        buildCompletedFloatingTasks();
    }

    private void buildCompletedFloatingTasks() {
        for (int i = 0; i < floatingTaskEntities.size(); i++) {
            if (floatingTaskEntities.get(i).isCompleted()) {
                int positionToAdd = findCompletionPositionToInsert(floatingTaskEntities.get(i));
                completedTaskEntities.add(positionToAdd, floatingTaskEntities.get(i));
                floatingTaskEntities.remove(i);
                i--;
            }
        }
    }

    private void buildCompletedMainTasks() {
        for (int i = 0; i < mainTaskEntities.size(); i++) {
            if (mainTaskEntities.get(i).isCompleted()) {
                int positionToAdd = findCompletionPositionToInsert(mainTaskEntities.get(i));
                completedTaskEntities.add(positionToAdd, mainTaskEntities.get(i));
                mainTaskEntities.remove(i);
                i--;
            }
        }
    }

    /**
     * Sets the currentId in TaskEntity to be 1 more than the largest ID loaded
     * so that it there will not be an Id Clash when creating new tasks
     */
    private void updateTaskEntityCurrentId() {
        checkThroughMain();
        checkThroughFloating();
    }

    /**
     * Function for updating TaskEntity's current ID
     */
    private void checkThroughFloating() {
        for (int i = 0; i < floatingTaskEntities.size(); i++) {
            if (floatingTaskEntities.get(i).getId() > TaskEntity.getCurrentId()) {
                TaskEntity.setCurrentId(floatingTaskEntities.get(i).getId() + 1);
            }
        }
    }

    /**
     * Function for updating TaskEntity's current ID
     */
    private void checkThroughMain() {
        for (int i = 0; i < mainTaskEntities.size(); i++) {
            if (mainTaskEntities.get(i).getId() > TaskEntity.getCurrentId()) {
                TaskEntity.setCurrentId(mainTaskEntities.get(i).getId() + 1);
            }
        }
    }

    /**
     * Creates the associations of the tasks based off the string
     * This function has to be called before building completed tasks
     * 
     * Pre-condition : Assumes id of tasks will not be repeated
     */
    private void initializeAssociations() {
        initializeAssociations(mainTaskEntities);
        initializeAssociations(floatingTaskEntities);
    }

    private void initializeAssociations(ArrayList<TaskEntity> arrayToInit) {
        for (int i = 0; i < arrayToInit.size(); i++) {
            arrayToInit.get(i).initAssociations();

            assert arrayToInit.get(i)
                    .getSavedAssociations() != null : "Null associations string loaded from file for task: "
                            + arrayToInit.get(i).getName();

            String[] associationIdList = arrayToInit.get(i).getSavedAssociations().split(",");

            if (!associationIdList[0].equals("")) {
                for (int j = 0; j < associationIdList.length; j++) {
                    int taskIdToAdd = Integer.parseInt(associationIdList[j]);

                    loadAssociationFromId(arrayToInit.get(i), taskIdToAdd);
                }
            }
        }
    }

    /**
     * Searches the 2 arraylist mainTaskEntities and floatingTaskEntities for an
     * object with the ID passed in and links the found task to the tasktoloadto
     * For initializeAssociations function.
     * 
     * Pre-condition : Assumes no duplicate ID
     * 
     * @param taskToLoadTo - Task that the found task is linked to
     * @param taskIdToAdd - ID of the task to be found
     */
    private void loadAssociationFromId(TaskEntity taskToLoadTo, int taskIdToAdd) {
        for (int k = 0; k < mainTaskEntities.size(); k++) {
            if (taskIdToAdd == mainTaskEntities.get(k).getId()) {
                taskToLoadTo.loadAssociation(mainTaskEntities.get(k));
                break;
            }
        }

        for (int k = 0; k < floatingTaskEntities.size(); k++) {
            if (taskIdToAdd == floatingTaskEntities.get(k).getId()) {
                taskToLoadTo.loadAssociation(floatingTaskEntities.get(k));
                break;
            }
        }
    }

    /**
     * Returns a list of raw command strings to run in the event of a crash. If
     * there was no crash, this queue is expected to be empty
     * 
     * @return all commands to be re-run before start of program
     */
    public Queue<String> getBackedupCommands() {
        Queue<String> reloadedCommands = dataLoader.getCommandsQueue();
        dataLoader.clearCommandFile();
        // Return cloned copy as same arraylist will cause infinite loop
        return new LinkedList(reloadedCommands);
    }

    /**
     * Calls storage to save each command ran. Auto commits when list is full
     * 
     * @param command - Raw command (the one that the user types) to be passed
     *            down
     */
    public void saveBackupCommand(String command) {
        // For crash
        boolean requiresFullSave = dataLoader.saveUponFullQueue(command);
        if (requiresFullSave) {
            commitFullSave();
        }

        updateUndoStack(command);
    }

    /**
     * Updates the list of commands to run for undo
     * 
     * @param command - Command to add for undo
     */
    private void updateUndoStack(String command) {
        if (!isUndoing) {
            if (undoPointer == undoCommands.size() - 1) {
                undoCommands.add(command);
                undoPointer++;
            } else {
                trimAdditionalCommands(command);
            }
            System.out.println("Undo pointer updated to " + undoPointer);
        } else {
            System.out.println("running an undo command");
        }
    }

    /**
     * For use in undo to trim off additional commands after entering a command
     * when undone, then adding the new undo command in
     * 
     * @param command - command to save to undo
     */
    private void trimAdditionalCommands(String command) {
        if (undoPointer == -1) {
            undoCommands = new ArrayList<String>();
        } else {
            undoCommands = new ArrayList<String>(undoCommands.subList(0, undoPointer + 1));
        }
        undoCommands.add(command);
        undoPointer++;
    }

    /**
     * function to log error messages into TaskManager
     * 
     * @param errorMessage
     */
    public void logError(String errorMessage) {
        if (logger == null) {
            initLogger();
        }
        logger.log(Level.SEVERE, "ERROR: " + errorMessage);
    }

    /**
     * Checks if an Id has shifted out of the end of the display list
     * 
     * @param currentId - Id to be checked
     * @return currentId if it is not out of range
     *         last ID in the display list if the checked ID is out of range
     *         -1 if the display list is empty
     */
    public int checkCurrentId(int currentId) {
        if (currentId >= displayedTasks.size()) {
            return displayedTasks.size() - 1;
        } else {
            return currentId;
        }
    }

    /**
     * Function to call for TaskManager before closing the program and whenever
     * its doing a full save. Calls storage for saving
     */
    public void commitFullSave() {
        AllTaskLists newList = generateSavedTaskArray();

        dataLoader.storeTaskLists(newList);
        dataLoader.clearCommandFileOnCommit();
    }

    /**
     * Creates a copy of the existing task lists, adding completed tasks into
     * the mainTaskEntities and floatingTaskEntities and building their string
     * list of IDs for associations
     * 
     * @return Object for saving all the tasks for Storage
     */
    public AllTaskLists generateSavedTaskArray() {
        ArrayList<TaskEntity> savedMainTaskEntities = new ArrayList<TaskEntity>();
        ArrayList<TaskEntity> savedFloatingTaskEntities = new ArrayList<TaskEntity>();

        buildMainSaveTasks(savedMainTaskEntities);
        buildFloatingSaveTasks(savedFloatingTaskEntities);
        buildCompletedSaveTasks(savedMainTaskEntities, savedFloatingTaskEntities);

        AllTaskLists newList = new AllTaskLists();
        newList.setFloatingTaskList(savedFloatingTaskEntities);
        newList.setMainTaskList(savedMainTaskEntities);

        return newList;
    }

    /**
     * Function for generateSavedTaskArray
     * 
     * @param savedMainTaskEntities - Array to put generated saved task into
     */
    private void buildMainSaveTasks(ArrayList<TaskEntity> savedMainTaskEntities) {
        for (int i = 0; i < mainTaskEntities.size(); i++) {
            TaskEntity clonedTask = mainTaskEntities.get(i).clone();
            clonedTask.buildAssociationsId();
            savedMainTaskEntities.add(clonedTask);
        }
    }

    /**
     * Function for generateSavedTaskArray
     * 
     * @param savedFloatingTaskEntities - Array to put generated saved task into
     */
    private void buildFloatingSaveTasks(ArrayList<TaskEntity> savedFloatingTaskEntities) {
        for (int i = 0; i < floatingTaskEntities.size(); i++) {
            TaskEntity clonedTask = floatingTaskEntities.get(i).clone();
            clonedTask.buildAssociationsId();
            savedFloatingTaskEntities.add(clonedTask);
        }
    }

    /**
     * Function for generateSavedTaskArray
     * 
     * @param savedMainTaskEntities - Array to put generated saved task into
     * @param savedFloatingTaskEntities - Array to put generated saved task into
     */
    private void buildCompletedSaveTasks(ArrayList<TaskEntity> savedMainTaskEntities,
            ArrayList<TaskEntity> savedFloatingTaskEntities) {
        for (int i = 0; i < completedTaskEntities.size(); i++) {
            TaskEntity clonedTask = completedTaskEntities.get(i).clone();
            clonedTask.buildAssociationsId();

            if (clonedTask.isFloating()) {
                savedFloatingTaskEntities.add(clonedTask);
            } else {
                savedMainTaskEntities.add(clonedTask);
            }
        }
    }

    /**
     * Gets the singleton instance of TaskManager
     * 
     * @return Singleton instance of TaskManager
     */
    public static TaskManager getInstance() {
        if (singleton == null) {
            singleton = new TaskManager();
        }
        return singleton;
    }

    /**
     * Initializes the logger
     */
    private void initLogger() {
        logger = Logger.getLogger("TaskManager.log");
        try {
            Handler fileHandler = new FileHandler("TaskManager.log");
            logger.addHandler(fileHandler);
            logger.setLevel(Level.FINEST);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Sets focus on a different list
     * 
     * @param view
     *            TaskManager.DISPLAY_MAIN, taskManager.DISPLAY_FLOATING,
     *            taskManager.DISPLAY_SEARCH taskMAnager.DISPLAY_COMPLETED
     */
    public void switchView(int view) {
        switch (view) {
            case DISPLAY_MAIN :
                currentDisplayedList = DISPLAY_MAIN;
                displayedTasks = (ArrayList<TaskEntity>) mainTaskEntities.clone();
                break;
            case DISPLAY_FLOATING :
                currentDisplayedList = DISPLAY_FLOATING;
                displayedTasks = (ArrayList<TaskEntity>) floatingTaskEntities.clone();
                break;
            case DISPLAY_COMPLETED :
                currentDisplayedList = DISPLAY_COMPLETED;
                displayedTasks = (ArrayList<TaskEntity>) completedTaskEntities.clone();
                break;
            case DISPLAY_SEARCH :
                currentDisplayedList = DISPLAY_SEARCH;
                displayedTasks = (ArrayList<TaskEntity>) searchedTasks.clone();
                break;
        }
    }

    public int getView() {
        return currentDisplayedList;
    }

    /**
     * UI Interface function Gets the currently displayed list of tasks
     * 
     * @return ArrayList containing the list of the task in focus
     */
    public ArrayList<TaskEntity> getWorkingList() {
        return displayedTasks;
    }

    /**
     * UI Interface function Modifies the selected task, effectively deleting it
     * and adding a new task. Will relink all the task's associations
     * 
     * @param index - int index of task to be modified
     * @param modifiedTask - New data of the task
     * @return ResultSet where
     *         ResultSet.getStatus
     *         : ResultSet.STATUS_CONFLICT if replacement task is conflicting
     *         with another task(excluding full day)
     *         : ResultSet.STATUS_PAST if replacement task is added to a date
     *         before current time
     *         : ResultSet.STATUS_CONFLICT_AND_PAST if both conditions above
     *         fulfilled
     *         : ResultSet.STATUS_GOOD if otherwise and successful
     *         : ResultSet.STATUS_BAD if operation failed to add
     *         : ResultSet.STATUS_INVALID_DATE if the start time of the
     *         modifiedTask
     *         is before the dueDate of it
     * 
     *         ResultSet.isSuccess
     *         :is false if INVALID_DATE OR Array to add to is null OR invalid
     *         name
     *         for the modififedTask like "     " OR failure to delete the task
     *         specified by taskId
     *         :is true otherwise
     * 
     *         ResultSet.getIndex
     *         : ID of the task to jump to (newly added task's ID)
     *         : -1 if its added to other views
     */
    public ResultSet modify(int index, TaskEntity modifiedTask) {
        ResultSet modificationResults = new ResultSet();

        // Temporarily set results to success
        modificationResults.setSuccess();
        modificationResults = checkModifyFailure(index, modifiedTask, modificationResults);
        if (!modificationResults.isSuccess()) {
            return modificationResults;
        }

        int associationState = displayedTasks.get(index).getAssociationState();
        TaskEntity projectHead = displayedTasks.get(index).getProjectHead();
        ArrayList<TaskEntity> childTasks = displayedTasks.get(index).getAssociations();

        if (delete(index) == false) {
            modificationResults.setStatus(ResultSet.STATUS_BAD);
            modificationResults.setFail();
            return modificationResults;
        }

        relinkAssociations(modifiedTask, associationState, projectHead, childTasks);

        modificationResults = add(modifiedTask);
        return modificationResults;
    }

    /**
     * Checks for the conditions where modification is not allowed
     * 
     * @param index - Id in the focused list of the task to be replaced
     * @param modifiedTask - Task to replace the edited task
     * @param modificationResults - Temporary ResultSet to set a failure if
     *            failure conditions are detected
     * @return Original ResultSet passed in if no failure conditions detected
     *         ResultSet containing failure conditions otherwise:
     *         ResultSet.getStatus() is set to STATUS_INVALID_NAME if no valid
     *         name is passed in, STATUS_BAD otherwise (Both are failure
     *         conditions)
     */
    private ResultSet checkModifyFailure(int index, TaskEntity modifiedTask, ResultSet modificationResults) {
        if (index > displayedTasks.size() - 1 || !TaskUtils.checkValidName(modifiedTask)) {
            if (!TaskUtils.checkValidName(modifiedTask)) {
                modificationResults.setStatus(ResultSet.STATUS_INVALID_NAME);
            } else {
                modificationResults.setStatus(ResultSet.STATUS_BAD);
            }
            modificationResults.setFail();
            return modificationResults;
        }

        // Check for invalid date ranges
        if (modifiedTask.getStartDate() != null && modifiedTask.getDueDate() != null) {
            if (modifiedTask.getStartDate().compareTo(modifiedTask.getDueDate()) > 0) {
                modificationResults.setStatus(ResultSet.STATUS_INVALID_DATE);
                modificationResults.setFail();
                return modificationResults;
            }
        }

        return modificationResults;
    }

    /**
     * Function for modify to link the deleted task's associations onto the new
     * task its modified to
     * 
     * @param modifiedTask -new task to replace the delete task
     * @param associationState- Association status of the task deleted
     * @param projectHead - Task that the delete task belonged to if it was
     *            associated to it
     * @param childTasks - Tasks that is under the deleted task if it is a
     *            project head
     */
    private void relinkAssociations(TaskEntity modifiedTask, int associationState, TaskEntity projectHead,
            ArrayList<TaskEntity> childTasks) {
        if (associationState == TaskEntity.ASSOCIATED) {
            link(projectHead, modifiedTask);
        } else if (associationState == TaskEntity.PROJECT_HEAD) {
            for (int i = 0; i < childTasks.size(); i++) {
                link(modifiedTask, childTasks.get(i));
            }
        }
    }

    /**
     * UI Interface function Modifies the selected task, effectively deleting it
     * and adding a new task. Will relink all the task's
     * 
     * @param index - int index of task to be modified represented by a string
     * @param modifiedTask - New data of the task
     * @return ResultSet where
     *         ResultSet.getStatus
     *         : ResultSet.STATUS_CONFLICT if replacement task is conflicting
     *         with another task(excluding full day)
     *         : ResultSet.STATUS_PAST if replacement task is added to a date
     *         before current time
     *         : ResultSet.STATUS_CONFLICT_AND_PAST if both conditions above
     *         fulfilled
     *         : ResultSet.STATUS_GOOD if otherwise and successful
     *         : ResultSet.STATUS_BAD if operation failed to add
     *         : ResultSet.STATUS_INVALID_DATE if the start time of the
     *         modifiedTask
     *         is before the dueDate of it
     * 
     *         ResultSet.isSuccess
     *         :is false if INVALID_DATE OR Array to add to is null OR invalid
     *         name
     *         for the modififedTask like "     " OR failure to delete the task
     *         specified by taskId
     *         :is true otherwise
     * 
     *         ResultSet.getIndex
     *         : ID of the task to jump to (newly added task's ID)
     *         : -1 if its added to other views
     */
    public ResultSet modify(String index, TaskEntity modifiedTask) {
        return modify(TaskUtils.convertStringToInteger(index), modifiedTask);
    }

    /**
     * Function to add multiple tasks. For test cases
     * 
     * @param tasks - An arrayList of the tasks to be added
     * @return ResultSet data from add of the first item added
     */
    public ResultSet add(ArrayList<TaskEntity> tasks) {
        ResultSet batchAddResults = new ResultSet();
        if (tasks.size() >= 1) {
            batchAddResults = add(tasks.get(0));
        }

        if (!batchAddResults.isSuccess()) {
            return batchAddResults;
        }

        for (int i = 1; i < tasks.size(); i++) {
            ResultSet currentAddResults = add(tasks.get(i));
            if (!currentAddResults.isSuccess()) {
                batchAddResults.setFail();
                return batchAddResults;
            }
        }

        return batchAddResults;
    }

    /**
     * UI Interface function Adds a task into its respective arraylist,
     * appending to the bottom of floatingTaskEntities if it is a floating task,
     * and inserting into its sorted position if it is a timed task
     * 
     * @param newTask - Task to be inserted
     * @return Resultset where
     *         ResultSet.getStatus
     *         : ResultSet.STATUS_CONFLICT if conflicting with another task
     *         (excluding full day)
     *         : ResultSet.STATUS_PAST if added to a date before current time
     *         : ResultSet.STATUS_CONFLICT_AND_PAST if both conditions above
     *         fulfilled
     *         : ResultSet.STATUS_GOOD if otherwise and successful
     *         : ResultSet.STATUS_BAD if operation failed to add
     *         : ResultSet.STATUS_INVALID_DATE if the start time of the newTask
     *         is before the dueDate of it
     * 
     *         ResultSet.isSuccess
     *         :false if INVALID_DATE OR Array to add to is null OR invalid name
     *         like "     "
     *         : success otherwise
     * 
     *         ResultSet.getIndex
     *         : ID of the task to jump to (newly added task's ID)
     *         : -1 if its added to other views
     */
    public ResultSet add(TaskEntity newTask) {
        assert displayedTasks != null : "no view set in displayedTasks, probably not initialised!";

        ResultSet addResults = new ResultSet();

        // Temporarily set success to check for failure
        addResults.setSuccess();
        addResults = checkAddFailure(newTask, addResults);
        if (!addResults.isSuccess()) {
            return addResults;
        }

        if (newTask.isFloating()) {
            return addFloatingTask(newTask);
        } else {
            return addMainTask(newTask);
        }
    }

    private ResultSet checkAddFailure(TaskEntity newTask, ResultSet addResults) {
        if (displayedTasks == null || !TaskUtils.checkValidName(newTask)) {
            if (!TaskUtils.checkValidName(newTask)) {
                addResults.setStatus(ResultSet.STATUS_INVALID_NAME);
            } else {
                addResults.setStatus(ResultSet.STATUS_BAD);
            }
            addResults.setFail();
            return addResults;
        }

        // Check for invalid date ranges
        if (newTask.getStartDate() != null && newTask.getDueDate() != null) {
            if (newTask.getStartDate().compareTo(newTask.getDueDate()) > 0) {
                addResults.setStatus(ResultSet.STATUS_INVALID_DATE);
                addResults.setFail();
                return addResults;
            }
        }

        // Return the results as it is if no failure detected
        return addResults;
    }

    /**
     * Adds the task into mainTaskEntities. For add function
     * 
     * @param newTask - Task to be added
     * @return ResultSet containing results matching the details in
     *         add(TaskEntity)
     */
    private ResultSet addMainTask(TaskEntity newTask) {
        ResultSet addResults = new ResultSet();

        if (mainTaskEntities == null) {
            addResults.setStatus(ResultSet.STATUS_BAD);
            addResults.setFail();
            return addResults;
        }

        if (checkClashing(newTask)) {
            addResults.setStatus(ResultSet.STATUS_CONFLICT);
        }

        if (TaskUtils.isDateBeforeNow(newTask.getDueDate())) {
            addResults.setStatus(ResultSet.STATUS_PAST);
        }

        return setResultAndInsertMain(newTask, addResults);
    }

    /**
     * Sets the fields for ResultSet and insert the main task into
     * mainTaskEntities
     * 
     * @param newTask - Task to be added
     * @return ResultSet containing results matching the details in
     *         add(TaskEntity)
     */
    private ResultSet setResultAndInsertMain(TaskEntity newTask, ResultSet addResults) {
        addResults.setView(ResultSet.TASK_VIEW);
        int idToInsert = findPositionToInsert(newTask);
        mainTaskEntities.add(idToInsert, newTask);
        System.out.println(mainTaskEntities.size());
        addResults.setIndex(updateMainDisplay(newTask, idToInsert));

        addResults.setStatus(ResultSet.STATUS_GOOD);
        addResults.setSuccess();
        System.out.println("status of add: " + addResults.getStatus());
        return addResults;
    }

    /**
     * Adds the task into floatingTaskEntities. For add function
     * 
     * @param newTask - Task to be added
     * @return ResultSet containing results matching the details in
     *         add(TaskEntity)
     */
    private ResultSet addFloatingTask(TaskEntity newTask) {
        ResultSet addResults = new ResultSet();

        if (floatingTaskEntities == null) {
            addResults.setStatus(ResultSet.STATUS_BAD);
            addResults.setFail();
            return addResults;
        }

        return setResultAndInsertFloating(newTask, addResults);
    }

    /**
     * Sets the fields for ResultSet and insert the floating task into
     * floatingTaskEntities
     * 
     * @param newTask - Task to be added
     * @return ResultSet containing results matching the details in
     *         add(TaskEntity)
     */
    private ResultSet setResultAndInsertFloating(TaskEntity newTask, ResultSet addResults) {
        boolean isAddSuccessful = floatingTaskEntities.add(newTask);
        assert isAddSuccessful == true : "Failed to add to non-null floatingTaskEntities list";
        System.out.println(floatingTaskEntities.size());

        addResults.setView(ResultSet.FLOATING_VIEW);
        addResults.setIndex(updateFloatingDisplay(newTask));
        addResults.setSuccess();
        addResults.setStatus(ResultSet.STATUS_GOOD);
        return addResults;
    }

    /**
     * Marks a task as done
     * 
     * @param index - Array slot in displayedTasks to be marked as done
     *            * @return true and STATUS_GOOD for success, false and
     *            STATUS_BAD for
     *            failure in ResultSet.isSuccess() and ResultSet.getStatus()
     *            respectively
     */
    public ResultSet markAsDone(int index) {
        ResultSet markingResults = new ResultSet();

        if ((index > displayedTasks.size() - 1) || (currentDisplayedList == DISPLAY_COMPLETED) || index < 0) {
            markingResults.setFail();
            markingResults.setStatus(ResultSet.STATUS_BAD);
            return markingResults;
        } else {
            // Checks for deletion failure
            if (!deleteFromCorrespondingDisplayList(displayedTasks.get(index))) {
                markingResults.setFail();
                markingResults.setStatus(ResultSet.STATUS_BAD);
                return markingResults;
            }

            return executeMarkTaskDone(index, markingResults);
        }
    }

    /**
     * Marks a task done. Pre-condition: All failure conditions have been
     * cleared. Called by markAsDone(int)
     * 
     * @param index - Array slot in displayedTasks to be marked as done
     *            * @return true and STATUS_GOOD for success in ResultSet
     */
    private ResultSet executeMarkTaskDone(int index, ResultSet markingResults) {
        displayedTasks.get(index).markAsDone();
        int positionToInsert = findCompletionPositionToInsert(displayedTasks.get(index));
        completedTaskEntities.add(positionToInsert, displayedTasks.get(index));

        // Remove it from displayedTasks only after processing it
        displayedTasks.remove(index);
        markingResults.setSuccess();
        markingResults.setStatus(ResultSet.STATUS_GOOD);
        return markingResults;
    }

    /**
     * Adds the task into displayed tasks too if its currently at main display.
     * For add function
     * 
     * @param newTask - Task to add
     * @param idToInsert - position to insert the task at
     * @return -1 if the focus is not on the main display
     *         ID of the position the task was added at otherwise
     */
    private int updateMainDisplay(TaskEntity newTask, int idToInsert) {
        if (currentDisplayedList == DISPLAY_MAIN) {
            displayedTasks.add(idToInsert, newTask);
            return idToInsert;
        } else {
            return -1;
        }
    }

    /**
     * Adds the task into displayed tasks too if its currently at floating
     * display. For add function
     * 
     * @param newTask - Task to add
     * @return -1 if the focus is not on the floating display
     *         ID of the position the task was added at otherwise
     */
    private int updateFloatingDisplay(TaskEntity newTask) {
        if (currentDisplayedList == DISPLAY_FLOATING) {
            displayedTasks.add(newTask);
            return floatingTaskEntities.size() - 1;
        } else {
            return -1;
        }
    }

    /**
     * UI Interface function Searches for the position to insert a newTask into
     * a sorted list of timed tasks using rules dictated in TaskDateComparator
     * 
     * @param newTask - The task object to be sorted
     * @return ID of the position where the task should be placed in the sorted
     *         list
     */
    private int findPositionToInsert(TaskEntity newTask) {
        int idToInsert = Collections.binarySearch(mainTaskEntities, newTask, new TaskDateComparator());

        // Due to Collections.binarySearch's implementation, all objects
        // that can't be found will return a negative value, which indicates
        // the position where the object that is being searched is supposed
        // to be minus 1. This if case figures out the position to slot it in
        if (idToInsert < 0) {
            idToInsert = -(idToInsert + 1);
        }
        return idToInsert;
    }

    /**
     * UI Interface function Searches for the position to insert a newTask into
     * a sorted list of completed tasks by their completion date
     * 
     * @param newTask - The task object to be sorted
     * @return ID of the position where the task should be placed in the sorted
     *         list
     */
    private int findCompletionPositionToInsert(TaskEntity newTask) {
        int idToInsert = Collections.binarySearch(completedTaskEntities, newTask,
                new TaskCompletionTimeComparator());

        // Due to Collections.binarySearch's implementation, all objects
        // that can't be found will return a negative value, which indicates
        // the position where the object that is being searched is supposed
        // to be minus 1. This if case figures out the position to slot it in
        if (idToInsert < 0) {
            idToInsert = -(idToInsert + 1);
        }
        return idToInsert;
    }

    /**
     * Deletion from the displayed list, will delete the object from the main
     * list in the backend's corresponding list as well
     * 
     * @param index- index of the item in the displayed tasks to be deleted
     * @return false - if fail to delete, true - if delete operation succeeded
     */
    public boolean delete(int index) {
        assert displayedTasks != null : "No list in focus when attempting to delete a task";

        if (displayedTasks == null) {
            logError("Attempted deletion with no list in focus");
            displayedTasks = mainTaskEntities;
        }

        if (index + 1 > displayedTasks.size()) {
            return false;
        }

        TaskEntity itemToBeDeleted = displayedTasks.get(index);
        boolean isDeletionSuccessful = deleteFromCorrespondingDisplayList(itemToBeDeleted);
        if (!isDeletionSuccessful) {
            return false;
        }

        itemToBeDeleted.removeSelfFromProject();

        try {
            displayedTasks.remove(index);
        } catch (ArrayIndexOutOfBoundsException e) {
            logError("Error at delete, removing from index that does not exist");
        }
        return true;
    }

    /**
     * Removes an object from the corresponding list that is being displayed
     * 
     * @param itemToBeDeleted
     *            - The task to be deleted from the main list
     * @return true - if removal operation succeeded false - if removal
     *         operation failed
     */
    private boolean deleteFromCorrespondingDisplayList(TaskEntity itemToBeDeleted) {
        if (currentDisplayedList == DISPLAY_FLOATING) {
            return floatingTaskEntities.remove(itemToBeDeleted);
        } else if (currentDisplayedList == DISPLAY_MAIN) {
            return mainTaskEntities.remove(itemToBeDeleted);
        } else if (currentDisplayedList == DISPLAY_SEARCH) {
            // Removes the object from its main list too
            if (!deleteFromMainList(itemToBeDeleted)) {
                return false;
            }
            return searchedTasks.remove(itemToBeDeleted);
        } else if (currentDisplayedList == DISPLAY_COMPLETED) {
            return mainTaskEntities.remove(itemToBeDeleted);
        } else {
            return false;
        }
    }

    /**
     * Removes an object from the main 3 list of floating/main/completed
     * 
     * @param itemToBeDeleted - Item that is being searched for to be removed
     * @return success of the deletion. True if succeeded in deleting
     */
    private boolean deleteFromMainList(TaskEntity itemToBeDeleted) {
        if (itemToBeDeleted.isCompleted()) {
            if (!completedTaskEntities.remove(itemToBeDeleted)) {
                return false;
            }
        } else {
            if (itemToBeDeleted.isFloating()) {
                if (!floatingTaskEntities.remove(itemToBeDeleted)) {
                    return false;
                }
            } else {
                if (!mainTaskEntities.remove(itemToBeDeleted)) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * Deletion from the displayed list, will delete the object from the main
     * list in the backend's corresponding list as well
     * 
     * @param index- index of the item in the displayed tasks to be deleted.
     *            String representation of an int
     * @return false - if fail to delete, true - if delete operation succeeded
     */
    public boolean delete(String index) {
        return delete(TaskUtils.convertStringToInteger(index));
    }

    /**
     * Deletes a consecutive list of tasks from both the working and main
     * arrayList. Upon failing to delete any item, the function terminates at
     * the object that it fails to delete and does not attempt to delete anymore
     * items
     * 
     * @param startIndex - An integer specifying the first index to be deleted.
     *            startIndex must be <= endIndex
     * @param endIndex - An integer specifying the last index to be deleted. The
     *            index must not be bigger than the size of the array List
     * @return - True if delete operation succeeded - False if delete operation
     *         failed
     */
    public boolean delete(int startIndex, int endIndex) {
        if (checkValidIndex(startIndex, endIndex) == false) {
            return false;
        }

        for (int i = 0; i <= endIndex - startIndex; i++) {
            if (!delete(startIndex)) {
                return false;
            }
        }
        return true;
    }

    /**
     * Saves current data before changing directory using Storage, passes on
     * storage's ResultSet for changing directory
     * 
     * @param newDirectory - Directory to change to
     * @return ResultSet from storage's saveto()
     */
    public ResultSet changeDirectory(String newDirectory) {
        commitFullSave();
        ResultSet saveSuccess = dataLoader.saveTo(newDirectory);

        return saveSuccess;
    }

    /**
     * Saves the current data first before changing the pathfile of the file and
     * loading it from there.
     * 
     * @param newDirectory - Directory to load from
     * @return ResultSet:
     *         ResultSet.getStatus - STATUS_GOOD if success
     *         STATUS_JSON_ERROR if file found but corrupted
     *         STATUS_BAD if file not found
     *         ResultSet.isSuccess - true if success
     *         false if either file not found or corrupted
     */
    public ResultSet loadFrom(String newDirectory) {
        ResultSet loadResult = new ResultSet();

        commitFullSave();

        boolean isLoadSuccessful = dataLoader.loadFrom(newDirectory);
        if (isLoadSuccessful == true) {
            if (reloadFile()) {
                dataLoader.clearCommandFile();
                loadResult.setSuccess();
                loadResult.setStatus(ResultSet.STATUS_GOOD);
            } else {
                loadResult.setStatus(ResultSet.STATUS_JSON_ERROR);
                loadResult.setFail();
            }
        } else {
            loadResult.setFail();
            loadResult.setStatus(ResultSet.STATUS_BAD);
        }

        return loadResult;
    }

    /**
     * Retrieves the filepath of the file loaded from storage
     * 
     * @return - String containing filepath of the file INCLUDING the filename
     */
    public String getMainFilePath() {
        return dataLoader.getMainFilePath();
    }

    /**
     * Takes in 2 IDs and make the second task an association under the first
     * task. Returns a ResultSet for the operation
     * 
     * @param projectHeadId - Id of Task that takes in other task as
     *            associations. String representing an int
     * @param taskUnderId - Id of Task to be associated under the first task.
     *            String representing an int
     * @return ResultSet, where status is STATUS_GOOD and isSuccess is true if
     *         operation succeeded, bad and false otherwise, respectively
     */
    public ResultSet link(String projectHeadId, String taskUnderId) {
        return link(TaskUtils.convertStringToInteger(projectHeadId),
                TaskUtils.convertStringToInteger(taskUnderId));
    }

    /**
     * Takes in 2 IDs and make the second task an association under the first
     * task. Returns a ResultSet for the operation
     * 
     * @param projectHeadId - Id of Task that takes in other task as
     *            associations.
     * @param taskUnderId - Id of Task to be associated under the first task.
     * @return ResultSet, where status is STATUS_GOOD and isSuccess is true if
     *         operation succeeded, bad and false otherwise, respectively
     */
    public ResultSet link(int projectHeadId, int taskUnderId) {
        ResultSet linkResult = new ResultSet();
        // Prevents linking to itself and to tasks IDs that are not valid
        if (projectHeadId >= displayedTasks.size() || taskUnderId >= displayedTasks.size()
                || projectHeadId == taskUnderId) {
            linkResult.setFail();
            linkResult.setStatus(ResultSet.STATUS_BAD);
            return linkResult;
        } else {
            return link(displayedTasks.get(projectHeadId), displayedTasks.get(taskUnderId));
        }
    }

    /**
     * Associates a task to a project head task. Project heads are not allowed
     * to be under other tasks and projects under other project heads are not
     * allowed to be project heads
     * 
     * @param projectHead - Task to be linked to
     * @param linkedTask - Task to be linked
     * @return ResultSet, where status is STATUS_GOOD and isSuccess is true if
     *         operation succeeded, bad and false otherwise, respectively
     */
    public ResultSet link(TaskEntity projectHead, TaskEntity linkedTask) {
        ResultSet linkResult = new ResultSet();
        int projectHeadId = displayedTasks.indexOf(projectHead);
        linkResult.setIndex(projectHeadId);

        if (linkedTask.getAssociationState() == TaskEntity.PROJECT_HEAD) {
            linkResult.setFail();
            linkResult.setStatus(ResultSet.STATUS_BAD);
            return linkResult;
        }

        boolean islinkSuccessful = projectHead.addAssociation(linkedTask);
        if (!islinkSuccessful) {
            linkResult.setFail();
            linkResult.setStatus(ResultSet.STATUS_BAD);
            return linkResult;
        }

        linkedTask.setAssociationHead(projectHead);
        linkResult.setSuccess();
        linkResult.setStatus(ResultSet.STATUS_GOOD);

        return linkResult;
    }

    /**
     * Checks if the Index passed in for deletion is a valid index
     * 
     * @param startIndex - Index of the first item in the range to be deleted
     * @param endIndex - Index of the last item in the range to be deleted
     * @return true if the index specified exists in the displayedTasks
     *         ArrayList
     */
    private boolean checkValidIndex(int startIndex, int endIndex) {
        if (endIndex + 1 > displayedTasks.size()) {
            return false;
        } else if (startIndex > endIndex) {
            return false;
        } else {
            return true;
        }
    }

    /**
     * Deletes a consecutive list of tasks from both the
     * working and main arrayList. Upon failing to delete any item, the function
     * terminates at the object that it fails to delete and does not attempt to
     * delete anymore items
     * 
     * @param startIndex - A string representing an int that represents the
     *            index of the first entry of all the entries to be deleted
     * @param endIndex - A string representing an int that represents the index
     *            of the last entry of all the entries to be deleted
     * @return - True if delete operation succeeded - False if delete operation
     *         failed
     */
    public boolean delete(String startIndex, String endIndex) {
        return delete(TaskUtils.convertStringToInteger(startIndex),
                TaskUtils.convertStringToInteger(endIndex));
    }

    /**
     * Gets the ID number of the upcoming task
     * 
     * @return ID of the task that is next, counting from the current time
     */
    public int getNextTimeListId() {
        TaskEntity currentTimePlaceholder = new TaskEntity("", null, Calendar.getInstance(), false);
        int nextTimeId = findPositionToInsert(currentTimePlaceholder);

        // Setting ID to the last index in the list if all tasks comes before
        // current time
        if (nextTimeId > mainTaskEntities.size() - 1) {
            nextTimeId = mainTaskEntities.size() - 1;
        }

        return nextTimeId;
    }

    /**
     * Gets a random floating task for display at UI
     * 
     * @return null - if floatingTaskEntities is empty A TaskEntity object that
     *         is a random floating task in floatingTaskEntities
     */
    public TaskEntity getRandomFloating() {
        if (floatingTaskEntities.size() == 0) {
            return null;
        } else {
            Random rand = new Random();
            int randomNum = rand.nextInt(floatingTaskEntities.size());
            return floatingTaskEntities.get(randomNum);
        }
    }

    public boolean checkClashing(TaskEntity newlyAddedTask) {
        for (int i = 0; i < mainTaskEntities.size(); i++) {
            if (TaskUtils.isClashing(newlyAddedTask, mainTaskEntities.get(i))) {
                return true;
            }
        }
        // No clash if none of the task is clashing with it
        return false;
    }

    public ResultSet searchForCompleted() {
        ResultSet searchResults = new ResultSet();
        if (completedTaskEntities == null) {
            searchResults.setFail();
            searchResults.setStatus(ResultSet.STATUS_BAD);
            return searchResults;
        }
        searchedTasks = (ArrayList<TaskEntity>) completedTaskEntities.clone();
        return populateResultSet();
    }

    /**
     * Default function for search to not narrow the search
     * 
     * @param searchTerm - String to search for
     * @return True if there are results, false if otherwise
     */
    public ResultSet searchString(String searchTerm) {
        if (searchTerm.equalsIgnoreCase("completed")) {
            return searchForCompleted();
        } else {
            return searchString(searchTerm, false);
        }
    }

    /**
     * Searches the description, name and hashtag fields of taskentity for the
     * string given. Non-case sensitive, populates the search view with the
     * search results
     * 
     * @param searchTerm - String to search for
     * @param isNarrowSearch - Set to true if you want to trim the current search
     *            instead of searching for a new term
     * @return true and STATUS_GOOD for success, false and STATUS_BAD for
     *         failure in ResultSet.isSuccess() and ResultSet.getStatus()
     *         respectively. ResultSet.searchCount() indicates how many search
     *         results were found
     */
    public ResultSet searchString(String searchTerm, boolean isNarrowSearch) {
        // Ensure that search is properly initialized
        if (searchedTasks == null) {
            searchedTasks = new ArrayList<TaskEntity>();
        }

        if (!isNarrowSearch) {
            searchedTasks = new ArrayList<TaskEntity>();
        }

        if (mainTaskEntities == null || floatingTaskEntities == null || completedTaskEntities == null) {
            ResultSet searchResults = new ResultSet();
            searchResults.setFail();
            searchResults.setStatus(ResultSet.STATUS_BAD);
            return searchResults;
        }

        searchAllArrays(searchTerm);
        return populateResultSet();
    }

    /**
     * Fill in ResultSet's data for searchString function. Only for use for
     * searchString. Pre-condition: search has succeeded
     * 
     * @return true and STATUS_GOOD for success in ResultSet.isSuccess() and
     *         ResultSet.getStatus() respectively. ResultSet.searchCount()
     *         indicates how many search results were found
     */
    private ResultSet populateResultSet() {
        ResultSet searchResults = new ResultSet();

        if (searchedTasks.size() > 0) {
            searchResults.setSuccess();
            searchResults.setStatus(ResultSet.STATUS_GOOD);
            searchResults.setSearchCount(searchedTasks.size());
            return searchResults;
        } else {
            searchResults.setSuccess();
            searchResults.setStatus(ResultSet.STATUS_GOOD);
            searchResults.setSearchCount(-1);
            return searchResults;
        }
    }

    /**
     * For searchString function
     * 
     * @param searchTerm - string to be searched
     */
    private void searchAllArrays(String searchTerm) {
        SearchModule.searchStringAddToResults(searchTerm, mainTaskEntities, searchedTasks);
        SearchModule.searchStringAddToResults(searchTerm, floatingTaskEntities, searchedTasks);
        SearchModule.searchStringAddToResults(searchTerm, completedTaskEntities, searchedTasks);
    }

    /**
     * Undoes the last command performed by the user
     * 
     * @return ArrayList of commands for main program to re-run
     */
    public ArrayList<String> undo() {
        System.out.println("undolist size: " + undoCommands.size() + " undoPointer : " + undoPointer);
        if (undoCommands.size() > 0 && undoPointer >= 0) {
            startUndo();

            if (undoPointer == -1) {
                System.out.println("Running 0 commands for undo");

                isUndoing = false;
                return new ArrayList<String>();
            } else {
                System.out.println("Running " + (undoPointer + 1) + " commands for undo");

                ArrayList<String> commandsToRun = new ArrayList<String>(undoCommands.subList(0, undoPointer + 1));
                return commandsToRun;
            }
        } else {
            return null;
        }
    }

    /**
     * For undo function
     */
    private void startUndo() {
        reloadBackUpFile();
        isUndoing = true;
        dataLoader.clearCommandFile();
        undoPointer--;
    }

    /**
     * Allows the undo list to be populated again
     */
    public void undoComplete() {
        isUndoing = false;
    }

    /**
     * Reloads the state of the program at startup
     */
    public void reloadBackUpFile() {
        AllTaskLists taskdata = dataLoader.getBackUpTaskLists();

        mainTaskEntities = (ArrayList<TaskEntity>) taskdata.getMainTaskList().clone();
        floatingTaskEntities = (ArrayList<TaskEntity>) taskdata.getFloatingTaskList().clone();

        initializeAssociations();

        updateTaskEntityCurrentId();
        buildCompletedTasks();
        displayedTasks = (ArrayList<TaskEntity>) mainTaskEntities.clone();
        currentDisplayedList = DISPLAY_MAIN;
    }

    /**
     * Loads task data from file. For use when doing loadfrom to load new file
     * data
     * 
     * @return true if new file is successfully loaded. False if there was a
     *         JSon error when reading the new file
     */
    public boolean reloadFile() {
        AllTaskLists taskdata = dataLoader.getTaskLists();
        if (taskdata == null) {
            return false;
        }

        mainTaskEntities = (ArrayList<TaskEntity>) taskdata.getMainTaskList().clone();
        floatingTaskEntities = (ArrayList<TaskEntity>) taskdata.getFloatingTaskList().clone();

        initializeAssociations();

        updateTaskEntityCurrentId();
        buildCompletedTasks();
        displayedTasks = (ArrayList<TaskEntity>) mainTaskEntities.clone();
        currentDisplayedList = DISPLAY_MAIN;
        resetUndo();
        return true;
    }

    /**
     * Saves the user's theme preference
     * 
     * @return true and STATUS_GOOD for success, false and STATUS_BAD for
     *         failure in ResultSet.isSuccess() and ResultSet.getStatus()
     *         respectively
     */
    public ResultSet saveTheme(String theme) {
        ResultSet saveResult = new ResultSet();
        boolean isSaveSuccessful = dataLoader.saveThemePreference(theme);

        if (isSaveSuccessful) {
            saveResult.setSuccess();
            saveResult.setStatus(ResultSet.STATUS_GOOD);
        } else {
            saveResult.setFail();
            saveResult.setStatus(ResultSet.STATUS_BAD);
        }
        return saveResult;
    }

    /**
     * Gets the user's saved theme preference
     * 
     * @return String indicating which css to use
     */
    public String loadTheme() {
        return dataLoader.getThemePreference();
    }
}
```
###### logic\TaskManagerInterface.java
``` java
 * 
 *          Interface class to the class that manages the handling of tasks
 *          during runtime
 */

package logic;

import java.util.ArrayList;
import java.util.Queue;
import entity.ResultSet;
import entity.TaskEntity;

public class TaskManagerInterface {
    TaskManager manager;

    public static int DISPLAY_MAIN;
    public static int DISPLAY_FLOATING;
    public static int DISPLAY_SEARCH;
    public static int DISPLAY_COMPLETED;
    public static int DISPLAY_OTHERS;

    public TaskManagerInterface() {
        manager = TaskManager.getInstance();

        // Values copied over for modularity
        DISPLAY_MAIN = manager.DISPLAY_MAIN;
        DISPLAY_FLOATING = manager.DISPLAY_FLOATING;
        DISPLAY_SEARCH = manager.DISPLAY_SEARCH;
        DISPLAY_COMPLETED = manager.DISPLAY_COMPLETED;
        DISPLAY_OTHERS = manager.DISPLAY_OTHERS;
    }

    /**
     * Returns a list of raw command strings to run in the event of a crash. If
     * there was no crash, this queue is expected to be empty
     * 
     * @return all commands to be re-run before start of program
     */
    public Queue<String> getBackedupCommands() {
        return manager.getBackedupCommands();
    }

    /**
     * Takes in a task to add and its raw command to store, adds the tasks into
     * the working list and returns a ResultSet indicating add results
     * 
     * @param newTask - Task to be added
     * @param command - Raw command prefixed with a view number at the front
     * @return Resultset where
     *         ResultSet.getStatus
     *         : ResultSet.STATUS_CONFLICT if conflicting with another task
     *         (excluding full day)
     *         : ResultSet.STATUS_PAST if added to a date before current time
     *         : ResultSet.STATUS_CONFLICT_AND_PAST if both conditions above
     *         fulfilled
     *         : ResultSet.STATUS_GOOD if otherwise and successful
     *         : ResultSet.STATUS_BAD if operation failed to add
     *         : ResultSet.STATUS_INVALID_DATE if the start time of the newTask
     *         is before the dueDate of it
     * 
     *         ResultSet.isSuccess
     *         :false if INVALID_DATE OR Array to add to is null OR invalid name
     *         like "     "
     *         : success otherwise
     * 
     *         ResultSet.getIndex
     *         : ID of the task to jump to (newly added task's ID)
     *         : -1 if its added to other views
     */
    public ResultSet add(TaskEntity newTask, String command) {
        ResultSet executionResult = manager.add(newTask);
        if (executionResult.isSuccess()) {
            manager.saveBackupCommand(command);
        }
        return executionResult;
    }

    /**
     * Takes in a list of tasks and adds them into the working list. Also takes
     * in a raw command to store. Returns a resultset indicating add results
     * 
     * @param newTasks - ArrayList of tasks to be added
     * @param command - Raw command prefixed with a view number at the front
     * @return Resultset where
     *         ResultSet.getStatus
     *         : ResultSet.STATUS_CONFLICT if conflicting with another task
     *         (excluding full day)
     *         : ResultSet.STATUS_PAST if added to a date before current time
     *         : ResultSet.STATUS_CONFLICT_AND_PAST if both conditions above
     *         fulfilled
     *         : ResultSet.STATUS_GOOD if otherwise and successful
     *         : ResultSet.STATUS_BAD if operation failed to add
     *         : ResultSet.STATUS_INVALID_DATE if the start time of the newTask
     *         is before the dueDate of it
     * 
     *         ResultSet.isSuccess
     *         :false if INVALID_DATE OR Array to add to is null OR invalid name
     *         like "     "
     *         : success otherwise
     * 
     *         ResultSet.getIndex
     *         : ID of the task to jump to (newly added task's ID)
     *         : -1 if its added to other views
     */
    public ResultSet add(ArrayList<TaskEntity> newTasks, String command) {
        ResultSet executionResult = manager.add(newTasks);
        if (executionResult.isSuccess()) {
            manager.saveBackupCommand(command);
        }
        return executionResult;
    }

    /**
     * Gets the task list in focus
     * 
     * @return
     */
    public ArrayList<TaskEntity> getWorkingList() {
        return manager.getWorkingList();
    }

    /**
     * Switches to the designated view
     * 
     * @param newView - Use one of the presets
     *            TaskManagerInterface.DISPLAY_MAIN,
     *            TaskManagerInterface.DISPLAY_FLOAT,
     *            TaskManagerInterface.DISPLAY_SEARCH
     */
    public void switchView(int newView) {
        manager.switchView(newView);
    }

    /**
     * Gets the current view in focus in TaskManager
     * 
     * @return int representing the current view
     *         TaskManagerInterface.DISPLAY_MAIN,
     *         TaskManagerInterface.DISPLAY_FLOAT,
     *         TaskManagerInterface.DISPLAY_SEARCH
     */
    public int getView() {
        return manager.getView();
    }

    /**
     * Takes in an ID specifying a task to be replaced with the task passed in.
     * Also stores the raw command. Returns a resultset for the modify results
     * 
     * @param taskId - ID relative to the current displayed list. String
     *            representation of an int
     * @param modifiedTask - Task to add after removing the ID specified
     * @param command - Raw command of the task prefixed by the view number the
     *            command is carried out in
     * @return ResultSet where
     *         ResultSet.getStatus
     *         : ResultSet.STATUS_CONFLICT if replacement task is conflicting
     *         with another task(excluding full day)
     *         : ResultSet.STATUS_PAST if replacement task is added to a date
     *         before current time
     *         : ResultSet.STATUS_CONFLICT_AND_PAST if both conditions above
     *         fulfilled
     *         : ResultSet.STATUS_GOOD if otherwise and successful
     *         : ResultSet.STATUS_BAD if operation failed to add
     *         : ResultSet.STATUS_INVALID_DATE if the start time of the
     *         modifiedTask
     *         is before the dueDate of it
     * 
     *         ResultSet.isSuccess
     *         :is false if INVALID_DATE OR Array to add to is null OR invalid
     *         name
     *         for the modififedTask like "     " OR failure to delete the task
     *         specified by taskId
     *         :is true otherwise
     * 
     *         ResultSet.getIndex
     *         : ID of the task to jump to (newly added task's ID)
     *         : -1 if its added to other views
     */
    public ResultSet modify(String taskId, TaskEntity modifiedTask, String command) {
        ResultSet executionResult = manager.modify(taskId, modifiedTask);
        if (executionResult.isSuccess()) {
            manager.saveBackupCommand(command);
        }
        return executionResult;
    }

    /**
     * Takes in an ID specifying a task to be replaced with the task passed in.
     * Also stores the raw command. Returns a ResultSet for the modify results
     * 
     * @param taskId - ID relative to the current displayed list
     * @param modifiedTask - Task to add after removing the ID specified
     * @param command - Raw command of the task prefixed by the view number the
     *            command is carried out in
     * @return ResultSet where
     *         ResultSet.getStatus
     *         : ResultSet.STATUS_CONFLICT if replacement task is conflicting
     *         with another task(excluding full day)
     *         : ResultSet.STATUS_PAST if replacement task is added to a date
     *         before current time
     *         : ResultSet.STATUS_CONFLICT_AND_PAST if both conditions above
     *         fulfilled
     *         : ResultSet.STATUS_GOOD if otherwise and successful
     *         : ResultSet.STATUS_BAD if operation failed to add
     *         : ResultSet.STATUS_INVALID_DATE if the start time of the
     *         modifiedTask
     *         is before the dueDate of it
     * 
     *         ResultSet.isSuccess
     *         :is false if INVALID_DATE OR Array to add to is null OR invalid
     *         name
     *         for the modififedTask like "     " OR failure to delete the task
     *         specified by taskId
     *         :is true otherwise
     * 
     *         ResultSet.getIndex
     *         : ID of the task to jump to (newly added task's ID)
     *         : -1 if its added to other views
     */
    public ResultSet modify(int taskId, TaskEntity modifiedTask, String command) {
        ResultSet executionResult = manager.modify(taskId, modifiedTask);
        if (executionResult.isSuccess()) {
            manager.saveBackupCommand(command);
        }
        return executionResult;
    }

    /**
     * Takes in an Id to delete a task and remove it from the lists. Also stores
     * the raw command. Returns a ResultSet of the deletion result
     * 
     * @param taskToMark - Id of the task to be delete in the displayed list
     * @param command - Raw command of the operation prefixed by an int
     *            representing the view the operation was carried out in
     * @return ResultSet - Deletion status to be good and deletion success to be
     *         true if deletion succeeded, bad and false otherwise,
     *         respectively.
     *         ResultSet's getIndex to be the position to be in the list after
     *         deletion, -1 if the list is empty after deletion
     */
    public ResultSet delete(String taskId, String command) {
        ResultSet deletionResult = new ResultSet();
        if (manager.delete(taskId)) {
            deletionResult.setSuccess();
            deletionResult.setStatus(ResultSet.STATUS_GOOD);
        } else {
            deletionResult.setFail();
            deletionResult.setStatus(ResultSet.STATUS_BAD);
        }

        if (!deletionResult.isSuccess()) {
            return deletionResult;
        } else {
            manager.saveBackupCommand(command);
            deletionResult.setIndex(manager.checkCurrentId(TaskUtils.convertStringToInteger(taskId)));
            return deletionResult;
        }
    }

    /**
     * Takes in a filepath to change the save directory for the tasklist to.
     * Results operation result in the form of a ResultSet
     * 
     * @param newDirectory - pathfile INCLUDING file name of the new save
     *            location
     * @return operation results
     */
    public ResultSet changeDirectory(String newDirectory) {
        return manager.changeDirectory(newDirectory);
    }

    /**
     * Loads from a filepath and changes the save directory for the tasklist.
     * Results operation result in the form of a ResultSet
     * 
     * @param newDirectory - pathfile INCLUDING file name of the new loaded file
     * @return ResultSet:
     *         ResultSet.getStatus - STATUS_GOOD if success
     *         STATUS_JSON_ERROR if file found but corrupted
     *         STATUS_BAD if file not found
     *         ResultSet.isSuccess - true if success
     *         false if either file not found or corrupted
     */
    public ResultSet loadFrom(String newDirectory) {
        return manager.loadFrom(newDirectory);
    }

    /**
     * Gets where the file is currently stored to
     * 
     * @return filepath INCLUDING filename
     */
    public String getMainFilePath() {
        return manager.getMainFilePath();
    }

    /**
     * Checks if JSON can read the file loaded. Returns true if JSON parsing is
     * successful
     * 
     * @return true if JSON read success, false otherwise
     */
    public boolean checkLoad() {
        return manager.checkLoad();
    }

    /**
     * Takes in tasks and make the second task an association under the first
     * task. Also stores the raw command. Returns a ResultSet for the operation
     * 
     * @param projectHeadId - Task that takes in other task as associations
     * @param taskUnderId - Task to be associated under the first task
     * @param command - Raw command prefixed with a int representing the view in
     *            which this command is carried out in
     * @return ResultSet, where status is STATUS_GOOD and isSuccess is true if
     *         operation succeeded, bad and false otherwise, respectively
     */
    public ResultSet link(TaskEntity projectHeadId, TaskEntity taskUnderId, String command) {
        ResultSet executionResults = manager.link(projectHeadId, taskUnderId);
        if (executionResults.isSuccess()) {
            manager.saveBackupCommand(command);
        }
        return executionResults;
    }

    /**
     * Takes in 2 IDs and make the second task an association under the first
     * task. Also stores the raw command. Returns a ResultSet for the operation
     * 
     * @param projectHeadId - Id of task that takes in other task as
     *            associations.
     *            String representing an int
     * @param taskUnderId - Id of task to be associated under the first task.
     *            String
     *            representing an int
     * @param command - Raw command prefixed with a int representing the view in
     *            which this command is carried out in
     * @return true and STATUS_GOOD for success, false and STATUS_BAD for
     *         failure in ResultSet.isSuccess() and ResultSet.getStatus()
     *         respectively
     */
    public ResultSet link(String projectHeadId, String taskUnderId, String command) {
        ResultSet executionResults = manager.link(projectHeadId, taskUnderId);
        if (executionResults.isSuccess()) {
            manager.saveBackupCommand(command);
        }
        return executionResults;
    }

    /**
     * Takes an ID of a task to mark complete and removes it from the
     * uncompleted task set. Stores the raw command and returns a ResultSet of
     * the results of the operation
     * 
     * @param taskToMark - Id of the task to be marked completed in the display
     *            list. String representation of an int.
     * @return true and STATUS_GOOD for success, false and STATUS_BAD for
     *         failure in ResultSet.isSuccess() and ResultSet.getStatus()
     *         respectively
     */
    public ResultSet markAsDone(String taskToMark, String command) {
        return markAsDone(TaskUtils.convertStringToInteger(taskToMark), command);
    }

    /**
     * Takes an ID of a task to mark complete and removes it from the
     * uncompleted task set. Stores the raw command and returns a resultset of
     * the results of the operation
     * 
     * @param taskToMark - Id of the task to be marked completed in the display
     *            list
     * @return true and STATUS_GOOD for success, false and STATUS_BAD for
     *         failure in ResultSet.isSuccess() and ResultSet.getStatus()
     *         respectively
     */
    public ResultSet markAsDone(int taskToMark, String command) {
        ResultSet markingResults = manager.markAsDone(taskToMark);

        if (!markingResults.isSuccess()) {
            return markingResults;
        } else {
            manager.saveBackupCommand(command);
            markingResults.setIndex(manager.checkCurrentId(taskToMark));
            return markingResults;
        }
    }

    /**
     * Gets the next upcoming task
     * 
     * @return ID of the upcoming task
     */
    public int getNextTimeListId() {
        return manager.getNextTimeListId();
    }

    /**
     * Gets a random floating task. Returns null if there are no floating tasks
     * 
     * @return a random TaskEntity that is from floatingTaskEntities
     */
    public TaskEntity getRandomFloating() {
        return manager.getRandomFloating();
    }

    /**
     * Undos the last command. Returns ArrayList of raw commands to re-run
     * 
     * @return ArrayList of raw commands to re-run
     */
    public ArrayList<String> undo() {
        return manager.undo();
    }

    /**
     * Gets the program out of an undo-ing state, allowing commands to be saved
     * to the undo stack again
     */
    public void undoComplete() {
        System.out.println("Undo completed");
        manager.undoComplete();
    }

    /**
     * Takes in a string to search for and builds search results in the search
     * view. Also stores the raw command. Returns ResultSet for results of
     * search
     * 
     * @param searchTerm - String that may contain substrings to search for or
     *            hashtags
     * @param command - Raw command prefixed with a int representing the view in
     *            which this command is carried out in
     * @return true and STATUS_GOOD for success, false and STATUS_BAD for
     *         failure in ResultSet.isSuccess() and ResultSet.getStatus()
     *         respectively. ResultSet.searchCount() indicates how many search
     *         results were found
     */
    public ResultSet searchString(String searchTerm, String command) {
        ResultSet executionResult = manager.searchString(searchTerm);
        if (executionResult.isSuccess()) {
            manager.saveBackupCommand(command);
        }
        return executionResult;
    }

    /**
     * Saves the user's theme preference
     * 
     * @return true and STATUS_GOOD for success, false and STATUS_BAD for
     *         failure in ResultSet.isSuccess() and ResultSet.getStatus()
     *         respectively
     */
    public ResultSet saveTheme(String theme) {
        return manager.saveTheme(theme);
    }

    /**
     * Gets the user's saved theme preference
     * 
     * @return String indicating which css to use
     */
    public String loadTheme() {
        return manager.loadTheme();
    }

    /**
     * Saves the tasklist into the file. Use when exiting program
     */
    public void closeTaskManager() {
        manager.commitFullSave();
    }
}
```
###### logic\TaskUtils.java
``` java
 * 
 *          Common utilities from logic for use through the program
 */
package logic;

import java.util.Calendar;

import entity.TaskEntity;

public class TaskUtils {

    /**
     * Converts an integer into its base 36, 0~Z equivalent. Supports any length
     * of characters need to represent its equivalent
     * 
     * @param index - positive integer, throws an error if its negative
     * @return - returns a string of the base 36 value
     */
    public static String convertDecToBase36(int index) {

        if (index < 0) {
            throw new Error("Converted number should be non-negative!");
        }

        String base36 = "";

        // 36 characters from 0~Z, break the int value down into each of their
        // base 36 equivalent number
        while (index / 36 >= 1) {
            // Supposed to be cast into integer to drop off its decimal value
            int currentDigit = index % 36;
            index = index / 36;

            base36 = appendChar(currentDigit, base36);
        }

        // Append last character
        base36 = appendChar(index, base36);

        return base36;
    }

    /**
     * Appends the next character to the end of the number. For
     * convertDecToBase36
     * 
     * @param index - value of next digit to append
     * @param base36 - currently compiled string of base 36 number
     * @return new String with next appended character
     */
    private static String appendChar(int index, String base36) {
        if (index < 10) {
            base36 = Integer.toString(index) + base36;
        } else if (index < 36) {
            // Match the values 10~35 to match A~Z in the ASCII table
            base36 = (char) (index + 55) + base36;
        }
        return base36;
    }

    /**
     * Checks if the name of a task is a valid name (Non-empty)
     * 
     * @param taskToCheck
     * @return true if the name is not null,just whitespace characters or empty
     *         false otherwise
     */
    public static boolean checkValidName(TaskEntity taskToCheck) {
        if (taskToCheck.getName() == null) {
            return false;
        } else if (taskToCheck.getName().trim() == "") {
            return false;
        } else {
            return true;
        }
    }

    /**
     * Converts a string representing a number to integer
     * 
     * @param str - String to convert
     * @return - converted integer in int, returns -2 if there is a number
     *         format exception
     */
    public static int convertStringToInteger(String str) {
        try {
            return Integer.parseInt(str);
        } catch (NumberFormatException e) {
            return -2;
        }
    }

    /**
     * Converts a base 36 number represented by a string into a base 10 int
     * value. Function will strip ALL spaces in the string
     * 
     * @param base36 - String representation of a base36 number
     * @return - positive integer -1 if unexpected input is given
     */
    public static int convertBase36ToDec(String base36) {
        int decNumber = 0;
        // digitValue increases by 36x per character in the string
        int digitWeight = 1;

        // Additional check if string passed in is just spaces
        boolean isWithValue = false;

        assert base36 != null : "Null string passed into convertBase36ToDec!";
        if (base36 == null) {
            return -1;
        }

        while (base36.length() > 0) {
            // Get the current last character of the base36 string
            char lastChar = base36.charAt(base36.length() - 1);

            int lastCharAsciiValue = (int) lastChar;
            int characterValue = 0;

            // Identify if the lastChar is an alphabet or number and then cast
            // it to its dec number value of 0~35
            characterValue = castCharacterValue(lastCharAsciiValue, characterValue);
            if (characterValue == -1) {
                return -1;
            }

            // Add the appropriate value of that digit to the final value
            if (checkIfAsciiSpaceChar(lastCharAsciiValue)) {
                decNumber += characterValue * digitWeight;
                digitWeight *= 36;
                isWithValue = true;
            }
            base36 = base36.substring(0, base36.length() - 1);
        }

        // Return error message of -1 if there are only spaces or no characters
        // in the string
        if (isWithValue == false) {
            return -1;
        }

        return decNumber;
    }

    private static int castCharacterValue(int lastCharAsciiValue, int characterValue) {
        if (checkIfAsciiUppercase(lastCharAsciiValue)) {
            characterValue = lastCharAsciiValue - 55;
        } else if (checkIfAsciiLowercase(lastCharAsciiValue)) {
            characterValue = lastCharAsciiValue - 87;
        } else if (checkIfAsciiNumber(lastCharAsciiValue)) {
            characterValue = lastCharAsciiValue - 48;
        } else if (checkIfAsciiSpaceChar(lastCharAsciiValue)) {
            characterValue = -1;
        }
        return characterValue;
    }

    private static boolean checkIfAsciiSpaceChar(int lastCharAsciiValue) {
        return lastCharAsciiValue != 32;
    }

    private static boolean checkIfAsciiNumber(int lastCharAsciiValue) {
        return lastCharAsciiValue >= 48 && lastCharAsciiValue <= 57;
    }

    private static boolean checkIfAsciiLowercase(int lastCharAsciiValue) {
        return lastCharAsciiValue >= 97 && lastCharAsciiValue <= 122;
    }

    private static boolean checkIfAsciiUppercase(int lastCharAsciiValue) {
        return lastCharAsciiValue >= 65 && lastCharAsciiValue <= 90;
    }

    /**
     * 
     * Checks if the 2 tasks passed in are of the same date
     * 
     * @param firstTask - first task to be compared
     * @param secondTask - second task to be compared
     * @return True - If the dates are the same False - If either the dates are
     *         different, or if either task is floating
     */
    public static boolean checkSameDate(TaskEntity firstTask, TaskEntity secondTask) {
        // Floating tasks cannot be compared, check if either tasks is floating
        Calendar firstDate;
        if (firstTask.isFloating()) {
            return false;
        } else {
            firstDate = firstTask.getDueDate();
        }

        Calendar secondDate;
        if (secondTask.isFloating()) {
            return false;
        } else {
            secondDate = secondTask.getDueDate();
        }

        return checkSameDate(firstDate, secondDate);
    }

    /**
     * Checks if 2 Calendar dates passed in are in the same day
     * 
     * @param firstDate
     * @param secondDate
     * @return True if it is, false otherwise
     */
    public static boolean checkSameDate(Calendar firstDate, Calendar secondDate) {
        if (firstDate.get(Calendar.YEAR) == secondDate.get(Calendar.YEAR)
                && firstDate.get(Calendar.MONTH) == secondDate.get(Calendar.MONTH)
                && firstDate.get(Calendar.DATE) == secondDate.get(Calendar.DATE)) {
            return true;
        }
        return false;
    }

    /**
     * Clears the seconds and milliseconds off a calendar object
     * 
     * @param timeToTrim
     */
    public static void clearSeconds(Calendar timeToTrim) {
        timeToTrim.set(Calendar.SECOND, 0);
        timeToTrim.set(Calendar.MILLISECOND, 0);
    }

    /**
     * Checks if 2 tasks are clashing
     * 
     * @param task1
     * @param task2
     * @return True if clashing
     *         False if not clashing or one of the variables to be checked is
     *         not set
     */
    public static boolean isClashing(TaskEntity task1, TaskEntity task2) {
        if (task1.getStartDate() == null) {
            if (task2.getStartDate() == null) {
                return TaskUtils.compareTwoDueDates(task1, task2);
            } else {
                return TaskUtils.checkDueDateInRange(task1, task2);
            }
        } else {
            if (task2.getStartDate() == null) {
                return TaskUtils.checkDueDateInRange(task2, task1);
            } else {
                return TaskUtils.checkOverlappingDuration(task1, task2);
            }
        }
    }

    /**
     * Checks if the durations of 2 tasks are overlapping
     * 
     * @param task1 - tasks to be compared
     * @param task2 - tasks to be compared
     * @return true if the range from start-end time of both tasks intersects
     *         false otherwise
     */
    public static boolean checkOverlappingDuration(TaskEntity task1, TaskEntity task2) {
        assert task1.getDueDate() != null && task1.getStartDate() != null && task2.getDueDate() != null
                && task2.getStartDate() != null : "One of the variables being compared is null in checkOverlappingDuration";

        if (task1.getDueDate() == null || task1.getStartDate() == null || task2.getDueDate() == null
                || task2.getStartDate() == null) {
            return false;
        } else if (task1.isFullDay() || task2.isFullDay()) {
            return false;
        } else {
            return checkOverlapping(task1, task2);
        }
    }

    /**
     * Checks if either startDate or dueDate of task1 is within the range of
     * startDate and dueDate of task2. Function strips the seconds and
     * milliseconds of all dates compared
     * 
     * @param task1
     * @param task2
     * @return True if either dates is within range
     *         false otherwise
     */
    private static boolean checkOverlapping(TaskEntity task1, TaskEntity task2) {
        clearSeconds(task1.getDueDate());
        clearSeconds(task1.getStartDate());
        clearSeconds(task2.getDueDate());
        clearSeconds(task2.getStartDate());

        if (task1.getDueDate().compareTo(task2.getDueDate()) <= 0
                && task1.getDueDate().compareTo(task2.getStartDate()) >= 0) {
            return true;
        } else if (task1.getStartDate().compareTo(task2.getDueDate()) <= 0
                && task1.getStartDate().compareTo(task2.getStartDate()) >= 0) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Checks if a due date of the first task is within the range specified by
     * the startDate and dueDate of the second task
     * 
     * @param dueDate - Task with due date to be checked
     * @param range - Task with the start and end time
     * @return True if the due date is within the 2 timing
     *         False if the due date is within the
     */
    public static boolean checkDueDateInRange(TaskEntity dueDate, TaskEntity range) {
        assert range.getDueDate() != null && range.getDueDate() != null && range
                .getStartDate() != null : "One of the variables being compared is null in checkDueDateInRange";

        if (range.getDueDate() == null || range.getDueDate() == null || range.getStartDate() == null) {
            return false;
        } else if (dueDate.isFullDay() || range.isFullDay()) {
            return false;
        } else {
            return checkWithinRange(dueDate, range);
        }
    }

    /**
     * Checks if dueDate of "dueDate" variable is within the range specified by
     * startDate and dueDate of "range" variable. Function strips the seconds
     * and milliseconds of all dates compared
     * 
     * @param dueDate
     * @param range
     * @return true if it is within the range
     *         false otherwise
     */
    private static boolean checkWithinRange(TaskEntity dueDate, TaskEntity range) {
        clearSeconds(dueDate.getDueDate());
        clearSeconds(range.getDueDate());
        clearSeconds(range.getStartDate());

        if (dueDate.getDueDate().compareTo(range.getDueDate()) <= 0
                && dueDate.getDueDate().compareTo(range.getStartDate()) >= 0) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Compares if the 2 due dates of the task is the same (Task order dont
     * matter)
     * 
     * @param task1 - First task to be compared
     * @param task2 - Second task to be compared
     * @return True if the same
     *         False if not the same, or fail to check
     */
    public static boolean compareTwoDueDates(TaskEntity task1, TaskEntity task2) {
        assert task1.getDueDate() != null && task2
                .getDueDate() != null : "Comparing floating task or corrupted non-floating task set to null for clashing";

        if (task1.getDueDate() == null || task2.getDueDate() == null) {
            return false;
        } else if (task1.isFullDay() || task2.isFullDay()) {
            return false;
        } else {
            return checkSameDueDate(task1, task2);
        }
    }

    /**
     * Checks if the dueDates of both tasks are the same. Function strips the
     * seconds and milliseconds of all dates compared
     * 
     * @param task1
     * @param task2
     * @return True if the dueDates are the same
     *         false otherwise
     */
    private static boolean checkSameDueDate(TaskEntity task1, TaskEntity task2) {
        clearSeconds(task1.getDueDate());
        clearSeconds(task2.getDueDate());
        if (task1.getDueDate().compareTo(task2.getDueDate()) == 0) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Used to generate a calendar object with the passed in time
     * 
     * @param day - Used to set DAY_OF_MONTH field in calendar
     * @param month - Used to set MONTH field in calendar
     * @param year - Used to set YEAR field in the calendar
     * @return Calendar object with the passed in fields
     */
    public static Calendar createDate(int day, int month, int year) {
        Calendar newDate = Calendar.getInstance();
        newDate.clear();
        newDate.set(year, month, day);
        return newDate;
    }

    /**
     * Used to generate a calendar object with the passed in time
     * 
     * @param day - Used to set DAY_OF_MONTH field in calendar
     * @param month - Used to set MONTH field in calendar
     * @param year - Used to set YEAR field in the calendar
     * @param hour - Used to set HOUR_OF_DAY field in the calendar
     * @param minutes - Used to set MINUTES field in the calendar
     * @return Calendar object with the passed in fields
     */
    public static Calendar createDate(int day, int month, int year, int hour, int minutes) {
        Calendar newDate = Calendar.getInstance();
        newDate.clear();
        newDate.set(year, month, day, hour, minutes);
        return newDate;
    }

    /**
     * Checks if a date is before the current time
     * 
     * @param timeToCheck
     * @return true is it is before, false otherwise
     */
    public static boolean isDateBeforeNow(Calendar timeToCheck) {
        Calendar currentTime = Calendar.getInstance();

        if (currentTime.compareTo(timeToCheck) > 0) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Checks if the firstDate is on a day before the secondDate in the same
     * year
     * 
     * @param firstDate
     * @param secondDate
     * @return True if the first date is on a day before the secondDate in the
     *         same year,false otherwise
     */
    public static boolean dayBefore(Calendar firstDate, Calendar secondDate) {
        if (firstDate.get(Calendar.YEAR) == secondDate.get(Calendar.YEAR)) {
            if (firstDate.get(Calendar.MONTH) < secondDate.get(Calendar.MONTH)) {
                return true;
            } else if (firstDate.get(Calendar.MONTH) > secondDate.get(Calendar.MONTH)) {
                return false;
            } else if (firstDate.get(Calendar.DAY_OF_MONTH) < secondDate.get(Calendar.DAY_OF_MONTH)) {
                return true;
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * Checks if the firstDate is set at a time before the secondDate on the
     * same day
     * 
     * @param firstDate
     * @param secondDate
     * @return True if it is
     *         False otherwise
     */
    public static boolean timeBefore(Calendar firstDate, Calendar secondDate) {
        if (checkSameDate(firstDate, secondDate)) {
            if (firstDate.get(Calendar.HOUR_OF_DAY) < secondDate.get(Calendar.HOUR_OF_DAY)) {
                return true;
            } else if (firstDate.get(Calendar.HOUR_OF_DAY) > secondDate.get(Calendar.HOUR_OF_DAY)) {
                return false;
            } else if (firstDate.get(Calendar.MINUTE) < secondDate.get(Calendar.MINUTE)) {
                return true;
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * Function to ensure that the dueDate of a task is not before the startTime
     * of it
     * 
     * @param taskToBeProcessed
     * @return same task passed in, but with date correction
     */
    public static TaskEntity calculateSecondDate(TaskEntity taskToBeProcessed) {
        Calendar firstDate = taskToBeProcessed.getStartDate();
        Calendar secondDate = taskToBeProcessed.getDueDate();

        if (firstDate == null || secondDate == null) {
            return taskToBeProcessed;
        }

        if (firstDate.compareTo(secondDate) < 0) {
            return taskToBeProcessed;
        }

        if (firstDate.get(Calendar.YEAR) < secondDate.get(Calendar.YEAR)) {
            return taskToBeProcessed;
        } else if (firstDate.get(Calendar.YEAR) > secondDate.get(Calendar.YEAR)) {
            secondDate.set(Calendar.YEAR, firstDate.get(Calendar.YEAR));
            taskToBeProcessed.setDate(firstDate, secondDate, taskToBeProcessed.isFullDay());
        }

        return processSameYearTask(taskToBeProcessed, firstDate, secondDate);
    }

    /**
     * Processes the 2 dates of a task that is on the same year. Causes any
     * start time before end time to be after logically
     * 
     * @param taskToBeProcessed
     * @param firstDate
     * @param secondDate
     * @return Same task with edited dates to make sense
     */
    private static TaskEntity processSameYearTask(TaskEntity taskToBeProcessed, Calendar firstDate,
            Calendar secondDate) {
        if (dayBefore(secondDate, firstDate)) {
            Calendar newTime = secondDate;
            newTime.set(Calendar.YEAR, secondDate.get(Calendar.YEAR) + 1);
            taskToBeProcessed.setDate(firstDate, newTime, taskToBeProcessed.isFullDay());
            return taskToBeProcessed;
        } else if (timeBefore(secondDate, firstDate) && !taskToBeProcessed.isFullDay()) {
            Calendar newTime = secondDate;
            newTime.set(Calendar.DAY_OF_MONTH, newTime.get(Calendar.DAY_OF_MONTH) + 1);
            taskToBeProcessed.setDate(firstDate, newTime, taskToBeProcessed.isFullDay());
            return taskToBeProcessed;
        } else {
            // Same date and hence, remove start time
            taskToBeProcessed.setDate(secondDate, taskToBeProcessed.isFullDay());
            return taskToBeProcessed;
        }
    }
}
```
###### test\logic\JUnitTaskEntity.java
``` java
 * 
 *          Testing unit for TaskEntity's functionalities
 */
package test.logic;

import static org.junit.Assert.*;

import java.util.ArrayList;

import org.junit.Test;

import entity.TaskEntity;
import logic.TaskManager;

public class JUnitTaskEntity {
    TaskManager manager = TaskManager.getInstance();

    @Test
    public void testTaskEntity_GetAssociationPosition_positionMatchInsertionOrder() {
        manager.unloadFile();

        TaskEntity firstTask = new TaskEntity("Master Task");
        manager.add(firstTask);

        assertEquals(firstTask.getAssociationPosition(), -1);

        ArrayList<TaskEntity> newList = new ArrayList<TaskEntity>();
        for (int i = 0; i < 9; i++) {
            TaskEntity otherTasks = new TaskEntity("Task " + Integer.toString(i + 1));
            newList.add(otherTasks);
            manager.link(firstTask, otherTasks);
        }
        manager.add(newList);

        assertEquals(firstTask.getAssociationPosition(), 0);

        manager.switchView(manager.DISPLAY_FLOATING);
        ArrayList<TaskEntity> taskList = manager.getWorkingList();

        assertEquals(taskList.get(1).getAssociationPosition(), 1);

        assertEquals(taskList.get(9).getAssociationPosition(), 9);

        assertEquals(taskList.get(5).getAssociationPosition(), 5);
    }

}
```
###### test\logic\JUnitTaskManager.java
``` java
 * 
 *          Testing unit for TaskManager's functionalities
 */

package test.logic;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.util.ArrayList;
import java.util.Calendar;

import org.junit.Test;

import entity.TaskEntity;
import logic.TaskManager;
import logic.TaskUtils;

public class JUnitTaskManager {
    TaskManager manager = TaskManager.getInstance();

    @Test
    public void testTaskManager_SwitchView_SwitchedToFloating() {
        manager.switchView(manager.DISPLAY_FLOATING);
        assertEquals(manager.DISPLAY_FLOATING, manager.getView());
    }

    @Test
    public void testTaskManager_AddFloatingTask_AddedToFloatingInOrder() {
        manager.unloadFile();
        manager.add(new TaskEntity("Task floating 1"));
        manager.add(new TaskEntity("Task floating 2"));
        manager.add(new TaskEntity("Task floating 3"));
        manager.add(new TaskEntity("Task floating 4"));
        assertEquals(manager.printArrayContentsToString(manager.DISPLAY_FLOATING),
                "Task floating 1, Task floating 2, Task floating 3, Task floating 4, ");
        assertEquals(manager.printArrayContentsToString(manager.DISPLAY_MAIN), "");
    }

    @Test
    public void testTaskManager_AddTimedTask_AddedToMainChronologicallyByDate() {
        manager.unloadFile();
        manager.add(new TaskEntity("Task 1", null, TaskUtils.createDate(16, 1, 2016), true));
        manager.add(new TaskEntity("Task 2", null, TaskUtils.createDate(17, 1, 2016), true));
        manager.add(new TaskEntity("Task 3", null, TaskUtils.createDate(15, 1, 2016), true));
        manager.add(new TaskEntity("Task 4", null, TaskUtils.createDate(18, 1, 2016), true));
        assertEquals(manager.printArrayContentsToString(manager.DISPLAY_MAIN),
                "Task 3, Task 1, Task 2, Task 4, ");
        assertEquals(manager.printArrayContentsToString(manager.DISPLAY_FLOATING), "");
    }

    @Test
    public void testTaskManager_AddTimedTask_AddedToMainChronologicallyByTime() {
        manager.unloadFile();
        manager.add(new TaskEntity("Task 1", null, TaskUtils.createDate(16, 1, 2016, 22, 0), false));
        manager.add(new TaskEntity("Task 2", null, TaskUtils.createDate(17, 1, 2016, 7, 0), false));
        manager.add(new TaskEntity("Task 3", null, TaskUtils.createDate(15, 1, 2016, 8, 0), false));
        manager.add(new TaskEntity("Task 4", null, TaskUtils.createDate(17, 1, 2016, 6, 0), false));
        assertEquals(manager.printArrayContentsToString(manager.DISPLAY_MAIN),
                "Task 3, Task 1, Task 4, Task 2, ");
        assertEquals(manager.printArrayContentsToString(manager.DISPLAY_FLOATING), "");
        assertEquals(manager.printArrayContentsToString(manager.DISPLAY_OTHERS),
                "Task 3, Task 1, Task 4, Task 2, ");
    }

    @Test
    public void testTaskManager_AddTimedTask_AddedToMainChronologicallyFullDayBeforeOtherTasks() {
        manager.unloadFile();
        manager.add(new TaskEntity("Task 1", null, TaskUtils.createDate(16, 1, 2016, 6, 0), false));
        manager.add(new TaskEntity("Task 2", null, TaskUtils.createDate(16, 1, 2016, 7, 0), true));
        manager.add(new TaskEntity("Task 3", null, TaskUtils.createDate(16, 1, 2016, 9, 0), false));
        manager.add(new TaskEntity("Task 4", null, TaskUtils.createDate(16, 1, 2016, 8, 0), false));
        assertEquals(manager.printArrayContentsToString(manager.DISPLAY_MAIN),
                "Task 2, Task 1, Task 4, Task 3, ");
        assertEquals(manager.printArrayContentsToString(manager.DISPLAY_FLOATING), "");
        assertEquals(manager.printArrayContentsToString(manager.DISPLAY_OTHERS),
                "Task 2, Task 1, Task 4, Task 3, ");
    }

    @Test
    public void testTaskManager_DeleteTimedTask_MainTask3Deleted() {
        manager.unloadFile();
        manager.add(new TaskEntity("Task 1", null, TaskUtils.createDate(16, 1, 2016, 6, 0), false));
        manager.add(new TaskEntity("Task 2", null, TaskUtils.createDate(16, 1, 2016, 8, 0), false));
        manager.add(new TaskEntity("Task 3", null, TaskUtils.createDate(16, 1, 2016, 7, 0), false));
        manager.add(new TaskEntity("Task 4", null, TaskUtils.createDate(16, 1, 2016, 9, 0), false));
        manager.delete("1");
        assertEquals(manager.printArrayContentsToString(manager.DISPLAY_MAIN), "Task 1, Task 2, Task 4, ");
    }

    @Test
    public void testTaskManager_DeleteFloatingTask_FloatingTask2Deleted() {
        manager.unloadFile();
        manager.add(new TaskEntity("Task 1"));
        manager.add(new TaskEntity("Task 2"));
        manager.add(new TaskEntity("Task 3"));
        manager.add(new TaskEntity("Task 4"));
        manager.switchView(manager.DISPLAY_FLOATING);
        manager.delete("1");
        assertEquals(manager.printArrayContentsToString(manager.DISPLAY_FLOATING),
                "Task 1, Task 3, Task 4, ");
    }

    @Test
    public void testTaskManager_ModifyTimedTask_Task3ModifiedToTask0() {
        manager.unloadFile();
        manager.add(new TaskEntity("Task 1", null, TaskUtils.createDate(16, 1, 2016, 6, 0), false));
        manager.add(new TaskEntity("Task 2", null, TaskUtils.createDate(16, 1, 2016, 8, 0), false));
        manager.add(new TaskEntity("Task 3", null, TaskUtils.createDate(16, 1, 2016, 7, 0), false));
        manager.add(new TaskEntity("Task 4", null, TaskUtils.createDate(16, 1, 2016, 9, 0), false));
        manager.modify("1", new TaskEntity("Task 0", null, TaskUtils.createDate(16, 1, 2016, 5, 0), false));
        assertEquals(manager.printArrayContentsToString(manager.DISPLAY_MAIN),
                "Task 0, Task 1, Task 2, Task 4, ");
    }

    @Test
    public void testTaskManager_ModifyFloatingTask_FloatingTaskMoveToMainTask() {
        manager.unloadFile();
        manager.add(new TaskEntity("Task 1"));
        manager.add(new TaskEntity("Task 2"));
        manager.add(new TaskEntity("Task 3"));
        manager.add(new TaskEntity("Task 4"));
        manager.switchView(manager.DISPLAY_FLOATING);
        manager.modify("0", new TaskEntity("Task 0", null, TaskUtils.createDate(16, 1, 2016, 5, 0), false));
        assertEquals(manager.printArrayContentsToString(manager.DISPLAY_FLOATING),
                "Task 2, Task 3, Task 4, ");
        assertEquals(manager.printArrayContentsToString(manager.DISPLAY_MAIN), "Task 0, ");
    }

    @Test
    public void testTaskManager_AddModifyDeleteCompiled_PrintoutMatchesTestPrintout() {
        manager.unloadFile();

        ArrayList<TaskEntity> newList = new ArrayList<TaskEntity>();
        for (int i = 0; i < 5; i++) {
            Calendar newDate = TaskUtils.createDate(1, 3, 2016);
            newDate.set(Calendar.MINUTE, newDate.get(Calendar.MINUTE) + i);
            newList.add(new TaskEntity("Task " + Integer.toString(i + 1), null, newDate, false, "some desc"));
        }
        manager.add(newList);

        System.out.println(manager.printArrayContentsToString(manager.DISPLAY_MAIN));
        TaskEntity firstFloating = new TaskEntity("Task floating 1");
        assertTrue(manager.add(firstFloating).isSuccess());
        manager.add(new TaskEntity("Task floating 2"));
        manager.add(new TaskEntity("Task floating 3"));
        manager.add(new TaskEntity("Task floating 4"));
        manager.switchView(manager.DISPLAY_FLOATING);
        manager.delete(0);
        manager.switchView(manager.DISPLAY_MAIN);

        TaskEntity headTask = new TaskEntity("2016/2/5", null, TaskUtils.createDate(5, 2, 2016), true);
        manager.modify(1, headTask);

        TaskEntity childTask = new TaskEntity("2016/2/3", null, TaskUtils.createDate(3, 2, 2016), true);
        manager.modify(3, childTask);

        assertEquals(manager.link(headTask, childTask).isSuccess(), true);

        childTask = new TaskEntity("2016/3/16", null, TaskUtils.createDate(16, 3, 2016), true);
        manager.add(childTask);
        manager.link(headTask, childTask);

        assertEquals(manager.link(childTask, headTask).isSuccess(), false);

        manager.add(new TaskEntity("2016/3/15", null, TaskUtils.createDate(15, 3, 2016), true));

        manager.link(firstFloating, childTask);

        manager.modify(6, new TaskEntity("Modified task", null, TaskUtils.createDate(15, 3, 2016), true));

        assertEquals(manager.printArrayContentsToString(manager.DISPLAY_OTHERS),
                "2016/2/3, 2016/2/5, Task 1, Task 3, Task 5, 2016/3/15, Modified task, ");
        assertEquals(manager.printArrayContentsToString(manager.DISPLAY_FLOATING),
                "Task floating 2, Task floating 3, Task floating 4, ");
        assertEquals(manager.printArrayContentsToString(manager.DISPLAY_MAIN),
                "2016/2/3, 2016/2/5, Task 1, Task 3, Task 5, 2016/3/15, Modified task, ");
    }

    @Test
    public void testTaskManager_markTimedDone_TaskMovedToCompleteAndIsComplete() {
        manager.unloadFile();

        TaskEntity nextTaskToAdd = new TaskEntity("Assignment", null, TaskUtils.createDate(16, 1, 2016, 6, 0),
                false);
        manager.add(nextTaskToAdd);

        assertEquals("Assignment, ", manager.printArrayContentsToString(manager.DISPLAY_MAIN));
        manager.switchView(manager.DISPLAY_MAIN);
        manager.markAsDone(0);
        assertEquals("", manager.printArrayContentsToString(manager.DISPLAY_MAIN));
        assertEquals("Assignment, ", manager.printArrayContentsToString(manager.DISPLAY_COMPLETED));
        assertTrue(nextTaskToAdd.isCompleted());
    }

    @Test
    public void testTaskManager_markFloatingDone_TaskMovedToCompleteAndIsComplete() {
        manager.unloadFile();

        TaskEntity nextTaskToAdd = new TaskEntity("Assignment");
        manager.add(nextTaskToAdd);

        assertEquals("Assignment, ", manager.printArrayContentsToString(manager.DISPLAY_FLOATING));
        manager.switchView(manager.DISPLAY_FLOATING);
        manager.markAsDone(0);
        assertEquals("", manager.printArrayContentsToString(manager.DISPLAY_FLOATING));
        assertEquals("Assignment, ", manager.printArrayContentsToString(manager.DISPLAY_COMPLETED));
        assertTrue(nextTaskToAdd.isCompleted());
    }

    @Test
    public void testTaskManager_link3Task_BothLinkSuccessful() {
        manager.unloadFile();

        TaskEntity firstTask = new TaskEntity("Task 1");
        manager.add(firstTask);
        TaskEntity secondTask = new TaskEntity("Task 2");
        manager.add(secondTask);
        TaskEntity thirdTask = new TaskEntity("Task 3");
        manager.add(thirdTask);

        manager.switchView(manager.DISPLAY_FLOATING);
        assertTrue(manager.link(0, 1).isSuccess());
        assertTrue(manager.link(0, 2).isSuccess());
    }

    @Test
    public void testTaskManager_link3Task_LinkProjectHeadAsTaskUnderFails() {
        manager.unloadFile();

        TaskEntity firstTask = new TaskEntity("Task 1");
        manager.add(firstTask);
        TaskEntity secondTask = new TaskEntity("Task 2");
        manager.add(secondTask);
        TaskEntity thirdTask = new TaskEntity("Task 3");
        manager.add(thirdTask);

        manager.switchView(manager.DISPLAY_FLOATING);
        assertTrue(manager.link(0, 1).isSuccess());
        assertFalse(manager.link(2, 0).isSuccess());
    }

    @Test
    public void testTaskManager_link3Task_MakeAssociatedTaskProjectHeadFails() {
        manager.unloadFile();

        TaskEntity firstTask = new TaskEntity("Task 1");
        manager.add(firstTask);
        TaskEntity secondTask = new TaskEntity("Task 2");
        manager.add(secondTask);
        TaskEntity thirdTask = new TaskEntity("Task 3");
        manager.add(thirdTask);

        manager.switchView(manager.DISPLAY_FLOATING);
        assertTrue(manager.link(0, 1).isSuccess());
        assertFalse(manager.link(1, 2).isSuccess());
    }

    @Test
    public void testTaskManager_searchStringSingleWord_AllDescriptionAndNameMatchesAddedToSearchView() {
        manager.unloadFile();

        manager.add(new TaskEntity("Groom Cat", "Remember to bring cat to grooming salon"));
        manager.add(new TaskEntity("Groom Dog", "Remember to bring dog to grooming salon"));
        manager.add(new TaskEntity("Groom Bird", "Remember bring bird grooming salon"));
        manager.add(new TaskEntity("Groom Rabbit", "Remember to bring rabbit to grooming salon"));
        manager.searchString("to");
        assertEquals("Groom Cat, Groom Dog, Groom Rabbit, ",
                manager.printArrayContentsToString(manager.DISPLAY_SEARCH));
        manager.searchString("groOming");
        assertEquals("Groom Cat, Groom Dog, Groom Bird, Groom Rabbit, ",
                manager.printArrayContentsToString(manager.DISPLAY_SEARCH));

        manager.add(new TaskEntity("Do 2103 V0.4", null, TaskUtils.createDate(4, 4, 2016), true,
                "Remember to be in before 9pm"));
        manager.add(new TaskEntity("Do 2103 V0.3", null, TaskUtils.createDate(28, 3, 2016), true));
        manager.add(new TaskEntity("Do 2104 V0.5", null, TaskUtils.createDate(11, 4, 2016), true));

        manager.searchString("remember");
        assertEquals("Do 2103 V0.4, Groom Cat, Groom Dog, Groom Bird, Groom Rabbit, ",
                manager.printArrayContentsToString(manager.DISPLAY_SEARCH));
    }

    @Test
    public void testTaskManager_searchCompletedTask_GroomDogFound() {
        manager.unloadFile();

        manager.add(new TaskEntity("Groom Cat", "Remember to bring cat to grooming salon"));
        manager.add(new TaskEntity("Groom Dog", "Remember to bring dog to grooming salon"));
        manager.add(new TaskEntity("Groom Bird", "Remember bring bird grooming salon"));
        manager.add(new TaskEntity("Groom Rabbit", "Remember to bring rabbit to grooming salon"));

        manager.switchView(manager.DISPLAY_FLOATING);
        assertTrue(manager.markAsDone(1).isSuccess());

        manager.searchString("completed");
        manager.switchView(manager.DISPLAY_SEARCH);
        assertEquals("Groom Dog, ", manager.printArrayContentsToString(manager.DISPLAY_OTHERS));
    }

    @Test
    public void testTaskManager_searchCategory_OnlyExactMatchFound() {
        manager.unloadFile();

        TaskEntity nextTaskToAdd = new TaskEntity("Groom Cat", "Remember to bring cat to grooming salon");
        nextTaskToAdd.addHashtag("#pets");
        manager.add(nextTaskToAdd);

        manager.searchString("#pets");
        manager.switchView(manager.DISPLAY_SEARCH);
        assertEquals("Groom Cat, ", manager.printArrayContentsToString(manager.DISPLAY_OTHERS));

        manager.searchString("#pet");
        manager.switchView(manager.DISPLAY_SEARCH);
        assertEquals("", manager.printArrayContentsToString(manager.DISPLAY_OTHERS));
    }
}
```
###### test\logic\JUnitTaskManagerInterface.java
``` java
 * 
 *          Testing unit for TaskManagerInterface's functionalities
 */

package test.logic;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.assertFalse;

import java.util.ArrayList;
import java.util.Calendar;

import org.junit.Test;

import entity.TaskEntity;
import logic.TaskManager;
import logic.TaskManagerInterface;
import logic.TaskUtils;

public class JUnitTaskManagerInterface {

    TaskManagerInterface manager = new TaskManagerInterface();
    TaskManager taskmanager = TaskManager.getInstance();

    @Test
    public void testTaskManagerInterface_SwitchView_SwitchedToFloating() {
        manager.switchView(manager.DISPLAY_FLOATING);
        assertEquals(manager.DISPLAY_FLOATING, manager.getView());
    }

    @Test
    public void testTaskManagerInterface_AddFloatingTask_AddedToFloatingInOrder() {
        taskmanager.unloadFile();
        manager.add(new TaskEntity("Task floating 1"), "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Task floating 2"), "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Task floating 3"), "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Task floating 4"), "PLACEHOLDER_SAVE_COMMAND");
        assertEquals(taskmanager.printArrayContentsToString(manager.DISPLAY_FLOATING),
                "Task floating 1, Task floating 2, Task floating 3, Task floating 4, ");
        assertEquals(taskmanager.printArrayContentsToString(manager.DISPLAY_MAIN), "");
    }

    @Test
    public void testTaskManagerInterface_AddTimedTask_AddedToMainChronologicallyByDate() {
        taskmanager.unloadFile();
        manager.add(new TaskEntity("Task 1", null, TaskUtils.createDate(16, 1, 2016), true),
                "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Task 2", null, TaskUtils.createDate(17, 1, 2016), true),
                "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Task 3", null, TaskUtils.createDate(15, 1, 2016), true),
                "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Task 4", null, TaskUtils.createDate(18, 1, 2016), true),
                "PLACEHOLDER_SAVE_COMMAND");
        assertEquals(taskmanager.printArrayContentsToString(manager.DISPLAY_MAIN),
                "Task 3, Task 1, Task 2, Task 4, ");
        assertEquals(taskmanager.printArrayContentsToString(manager.DISPLAY_FLOATING), "");
    }

    @Test
    public void testTaskManagerInterface_AddTimedTask_AddedToMainChronologicallyByTime() {
        taskmanager.unloadFile();
        manager.add(new TaskEntity("Task 1", null, TaskUtils.createDate(16, 1, 2016, 22, 0), false),
                "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Task 2", null, TaskUtils.createDate(17, 1, 2016, 7, 0), false),
                "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Task 3", null, TaskUtils.createDate(15, 1, 2016, 8, 0), false),
                "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Task 4", null, TaskUtils.createDate(17, 1, 2016, 6, 0), false),
                "PLACEHOLDER_SAVE_COMMAND");
        assertEquals(taskmanager.printArrayContentsToString(manager.DISPLAY_MAIN),
                "Task 3, Task 1, Task 4, Task 2, ");
        assertEquals(taskmanager.printArrayContentsToString(manager.DISPLAY_FLOATING), "");
        assertEquals(taskmanager.printArrayContentsToString(manager.DISPLAY_OTHERS),
                "Task 3, Task 1, Task 4, Task 2, ");
    }

    @Test
    public void testTaskManagerInterface_AddTimedTask_AddedToMainChronologicallyFullDayBeforeOtherTasks() {
        taskmanager.unloadFile();
        manager.add(new TaskEntity("Task 1", null, TaskUtils.createDate(16, 1, 2016, 6, 0), false),
                "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Task 2", null, TaskUtils.createDate(16, 1, 2016, 7, 0), true),
                "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Task 3", null, TaskUtils.createDate(16, 1, 2016, 9, 0), false),
                "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Task 4", null, TaskUtils.createDate(16, 1, 2016, 8, 0), false),
                "PLACEHOLDER_SAVE_COMMAND");
        assertEquals(taskmanager.printArrayContentsToString(manager.DISPLAY_MAIN),
                "Task 2, Task 1, Task 4, Task 3, ");
        assertEquals(taskmanager.printArrayContentsToString(manager.DISPLAY_FLOATING), "");
        assertEquals(taskmanager.printArrayContentsToString(manager.DISPLAY_OTHERS),
                "Task 2, Task 1, Task 4, Task 3, ");
    }

    @Test
    public void testTaskManagerInterface_DeleteTimedTask_MainTask3Deleted() {
        taskmanager.unloadFile();
        manager.add(new TaskEntity("Task 1", null, TaskUtils.createDate(16, 1, 2016, 6, 0), false),
                "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Task 2", null, TaskUtils.createDate(16, 1, 2016, 8, 0), false),
                "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Task 3", null, TaskUtils.createDate(16, 1, 2016, 7, 0), false),
                "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Task 4", null, TaskUtils.createDate(16, 1, 2016, 9, 0), false),
                "PLACEHOLDER_SAVE_COMMAND");
        manager.delete("1", "PLACEHOLDER_SAVE_COMMAND");
        assertEquals(taskmanager.printArrayContentsToString(manager.DISPLAY_MAIN),
                "Task 1, Task 2, Task 4, ");
    }

    @Test
    public void testTaskManagerInterface_DeleteFloatingTask_FloatingTask2Deleted() {
        taskmanager.unloadFile();
        manager.add(new TaskEntity("Task 1"), "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Task 2"), "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Task 3"), "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Task 4"), "PLACEHOLDER_SAVE_COMMAND");
        manager.switchView(manager.DISPLAY_FLOATING);
        manager.delete("1", "PLACEHOLDER_SAVE_COMMAND");
        assertEquals(taskmanager.printArrayContentsToString(manager.DISPLAY_FLOATING),
                "Task 1, Task 3, Task 4, ");
    }

    @Test
    public void testTaskManagerInterface_ModifyTimedTask_Task3ModifiedToTask0() {
        taskmanager.unloadFile();
        manager.add(new TaskEntity("Task 1", null, TaskUtils.createDate(16, 1, 2016, 6, 0), false),
                "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Task 2", null, TaskUtils.createDate(16, 1, 2016, 8, 0), false),
                "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Task 3", null, TaskUtils.createDate(16, 1, 2016, 7, 0), false),
                "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Task 4", null, TaskUtils.createDate(16, 1, 2016, 9, 0), false),
                "PLACEHOLDER_SAVE_COMMAND");
        manager.modify("1", new TaskEntity("Task 0", null, TaskUtils.createDate(16, 1, 2016, 5, 0), false),
                "PLACEHOLDER_SAVE_COMMAND");
        assertEquals(taskmanager.printArrayContentsToString(manager.DISPLAY_MAIN),
                "Task 0, Task 1, Task 2, Task 4, ");
    }

    @Test
    public void testTaskManagerInterface_ModifyFloatingTask_FloatingTaskMoveToMainTask() {
        taskmanager.unloadFile();
        manager.add(new TaskEntity("Task 1"), "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Task 2"), "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Task 3"), "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Task 4"), "PLACEHOLDER_SAVE_COMMAND");
        manager.switchView(manager.DISPLAY_FLOATING);
        manager.modify("0", new TaskEntity("Task 0", null, TaskUtils.createDate(16, 1, 2016, 5, 0), false),
                "PLACEHOLDER_SAVE_COMMAND");
        assertEquals(taskmanager.printArrayContentsToString(manager.DISPLAY_FLOATING),
                "Task 2, Task 3, Task 4, ");
        assertEquals(taskmanager.printArrayContentsToString(manager.DISPLAY_MAIN), "Task 0, ");
    }

    @Test
    public void testTaskManagerInterface_AddModifyDeleteCompiled_PrintoutMatchesTestPrintout() {
        taskmanager.unloadFile();

        ArrayList<TaskEntity> newList = new ArrayList<TaskEntity>();
        for (int i = 0; i < 5; i++) {
            Calendar newDate = TaskUtils.createDate(1, 3, 2016);
            newDate.set(Calendar.MINUTE, newDate.get(Calendar.MINUTE) + i);
            newList.add(new TaskEntity("Task " + Integer.toString(i + 1), null, newDate, false, "some desc"));
        }
        manager.add(newList, "PLACEHOLDER_SAVE_COMMAND");

        System.out.println(taskmanager.printArrayContentsToString(manager.DISPLAY_MAIN));
        TaskEntity firstFloating = new TaskEntity("Task floating 1");
        assertTrue(manager.add(firstFloating, "PLACEHOLDER_SAVE_COMMAND").isSuccess());
        manager.add(new TaskEntity("Task floating 2"), "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Task floating 3"), "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Task floating 4"), "PLACEHOLDER_SAVE_COMMAND");
        manager.switchView(manager.DISPLAY_FLOATING);
        manager.delete("0", "PLACEHOLDER_SAVE_COMMAND");
        manager.switchView(manager.DISPLAY_MAIN);

        TaskEntity headTask = new TaskEntity("2016/2/5", null, TaskUtils.createDate(5, 2, 2016), true);
        manager.modify(1, headTask, "PLACEHOLDER_SAVE_COMMAND");

        TaskEntity childTask = new TaskEntity("2016/2/3", null, TaskUtils.createDate(3, 2, 2016), true);
        manager.modify(3, childTask, "PLACEHOLDER_SAVE_COMMAND");

        assertEquals(manager.link(headTask, childTask, "PLACEHOLDER_SAVE_COMMAND").isSuccess(), true);

        childTask = new TaskEntity("2016/3/16", null, TaskUtils.createDate(16, 3, 2016), true);
        manager.add(childTask, "PLACEHOLDER_SAVE_COMMAND");
        manager.link(headTask, childTask, "PLACEHOLDER_SAVE_COMMAND");

        assertEquals(manager.link(childTask, headTask, "PLACEHOLDER_SAVE_COMMAND").isSuccess(), false);

        manager.add(new TaskEntity("2016/3/15", null, TaskUtils.createDate(15, 3, 2016), true),
                "PLACEHOLDER_SAVE_COMMAND");

        manager.link(firstFloating, childTask, "PLACEHOLDER_SAVE_COMMAND");

        manager.modify(6, new TaskEntity("Modified task", null, TaskUtils.createDate(15, 3, 2016), true),
                "PLACEHOLDER_SAVE_COMMAND");

        assertEquals(taskmanager.printArrayContentsToString(manager.DISPLAY_OTHERS),
                "2016/2/3, 2016/2/5, Task 1, Task 3, Task 5, 2016/3/15, Modified task, ");
        assertEquals(taskmanager.printArrayContentsToString(manager.DISPLAY_FLOATING),
                "Task floating 2, Task floating 3, Task floating 4, ");
        assertEquals(taskmanager.printArrayContentsToString(manager.DISPLAY_MAIN),
                "2016/2/3, 2016/2/5, Task 1, Task 3, Task 5, 2016/3/15, Modified task, ");
    }

    @Test
    public void testTaskManagerInterface_markTimedDone_TaskMovedToCompleteAndIsComplete() {
        taskmanager.unloadFile();

        TaskEntity nextTaskToAdd = new TaskEntity("Assignment", null, TaskUtils.createDate(16, 1, 2016, 6, 0),
                false);
        manager.add(nextTaskToAdd, "PLACEHOLDER_SAVE_COMMAND");

        assertEquals("Assignment, ", taskmanager.printArrayContentsToString(manager.DISPLAY_MAIN));
        manager.switchView(manager.DISPLAY_MAIN);
        manager.markAsDone(0, "PLACEHOLDER_SAVE_COMMAND");
        assertEquals("", taskmanager.printArrayContentsToString(manager.DISPLAY_MAIN));
        assertEquals("Assignment, ", taskmanager.printArrayContentsToString(manager.DISPLAY_COMPLETED));
        assertTrue(nextTaskToAdd.isCompleted());
    }

    @Test
    public void testTaskManagerInterface_markFloatingDone_TaskMovedToCompleteAndIsComplete() {
        taskmanager.unloadFile();

        TaskEntity nextTaskToAdd = new TaskEntity("Assignment");
        manager.add(nextTaskToAdd, "PLACEHOLDER_SAVE_COMMAND");

        assertEquals("Assignment, ", taskmanager.printArrayContentsToString(manager.DISPLAY_FLOATING));
        manager.switchView(manager.DISPLAY_FLOATING);
        manager.markAsDone(0, "PLACEHOLDER_SAVE_COMMAND");
        assertEquals("", taskmanager.printArrayContentsToString(manager.DISPLAY_FLOATING));
        assertEquals("Assignment, ", taskmanager.printArrayContentsToString(manager.DISPLAY_COMPLETED));
        assertTrue(nextTaskToAdd.isCompleted());
    }

    @Test
    public void testTaskManagerInterface_link3Task_BothLinkSuccessful() {
        taskmanager.unloadFile();

        TaskEntity firstTask = new TaskEntity("Task 1");
        manager.add(firstTask, "PLACEHOLDER_SAVE_COMMAND");
        TaskEntity secondTask = new TaskEntity("Task 2");
        manager.add(secondTask, "PLACEHOLDER_SAVE_COMMAND");
        TaskEntity thirdTask = new TaskEntity("Task 3");
        manager.add(thirdTask, "PLACEHOLDER_SAVE_COMMAND");

        manager.switchView(manager.DISPLAY_FLOATING);
        assertTrue(manager.link("0", "1", "PLACEHOLDER_SAVE_COMMAND").isSuccess());
        assertTrue(manager.link("0", "2", "PLACEHOLDER_SAVE_COMMAND").isSuccess());
    }

    @Test
    public void testTaskManagerInterface_link3Task_LinkProjectHeadAsTaskUnderFails() {
        taskmanager.unloadFile();

        TaskEntity firstTask = new TaskEntity("Task 1");
        manager.add(firstTask, "PLACEHOLDER_SAVE_COMMAND");
        TaskEntity secondTask = new TaskEntity("Task 2");
        manager.add(secondTask, "PLACEHOLDER_SAVE_COMMAND");
        TaskEntity thirdTask = new TaskEntity("Task 3");
        manager.add(thirdTask, "PLACEHOLDER_SAVE_COMMAND");

        manager.switchView(manager.DISPLAY_FLOATING);
        assertTrue(manager.link("0", "1", "PLACEHOLDER_SAVE_COMMAND").isSuccess());
        assertFalse(manager.link("2", "0", "PLACEHOLDER_SAVE_COMMAND").isSuccess());
    }

    @Test
    public void testTaskManagerInterface_link3Task_MakeAssociatedTaskProjectHeadFails() {
        taskmanager.unloadFile();

        TaskEntity firstTask = new TaskEntity("Task 1");
        manager.add(firstTask, "PLACEHOLDER_SAVE_COMMAND");
        TaskEntity secondTask = new TaskEntity("Task 2");
        manager.add(secondTask, "PLACEHOLDER_SAVE_COMMAND");
        TaskEntity thirdTask = new TaskEntity("Task 3");
        manager.add(thirdTask, "PLACEHOLDER_SAVE_COMMAND");

        manager.switchView(manager.DISPLAY_FLOATING);
        assertTrue(manager.link("0", "1", "PLACEHOLDER_SAVE_COMMAND").isSuccess());
        assertFalse(manager.link("1", "2", "PLACEHOLDER_SAVE_COMMAND").isSuccess());
    }

    @Test
    public void testTaskManagerInterface_searchStringSingleWord_AllDescriptionAndNameMatchesAddedToSearchView() {
        taskmanager.unloadFile();

        manager.add(new TaskEntity("Groom Cat", "Remember to bring cat to grooming salon"),
                "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Groom Dog", "Remember to bring dog to grooming salon"),
                "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Groom Bird", "Remember bring bird grooming salon"),
                "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Groom Rabbit", "Remember to bring rabbit to grooming salon"),
                "PLACEHOLDER_SAVE_COMMAND");
        manager.searchString("to", "PLACEHOLDER_SAVE_COMMAND");
        assertEquals("Groom Cat, Groom Dog, Groom Rabbit, ",
                taskmanager.printArrayContentsToString(manager.DISPLAY_SEARCH));
        manager.searchString("groOming", "PLACEHOLDER_SAVE_COMMAND");
        assertEquals("Groom Cat, Groom Dog, Groom Bird, Groom Rabbit, ",
                taskmanager.printArrayContentsToString(manager.DISPLAY_SEARCH));

        manager.add(new TaskEntity("Do 2103 V0.4", null, TaskUtils.createDate(4, 4, 2016), true,
                "Remember to be in before 9pm"), "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Do 2103 V0.3", null, TaskUtils.createDate(28, 3, 2016), true),
                "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Do 2104 V0.5", null, TaskUtils.createDate(11, 4, 2016), true),
                "PLACEHOLDER_SAVE_COMMAND");

        manager.searchString("remember", "PLACEHOLDER_SAVE_COMMAND");
        assertEquals("Do 2103 V0.4, Groom Cat, Groom Dog, Groom Bird, Groom Rabbit, ",
                taskmanager.printArrayContentsToString(manager.DISPLAY_SEARCH));
    }

    @Test
    public void testTaskManagerInterface_searchCompletedTask_GroomDogFound() {
        taskmanager.unloadFile();

        manager.add(new TaskEntity("Groom Cat", "Remember to bring cat to grooming salon"),
                "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Groom Dog", "Remember to bring dog to grooming salon"),
                "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Groom Bird", "Remember bring bird grooming salon"),
                "PLACEHOLDER_SAVE_COMMAND");
        manager.add(new TaskEntity("Groom Rabbit", "Remember to bring rabbit to grooming salon"),
                "PLACEHOLDER_SAVE_COMMAND");

        manager.switchView(manager.DISPLAY_FLOATING);
        assertTrue(manager.markAsDone(1, "PLACEHOLDER_SAVE_COMMAND").isSuccess());

        manager.searchString("completed", "PLACEHOLDER_SAVE_COMMAND");
        manager.switchView(manager.DISPLAY_SEARCH);
        assertEquals("Groom Dog, ", taskmanager.printArrayContentsToString(manager.DISPLAY_OTHERS));
    }

    @Test
    public void testTaskManagerInterface_searchCategory_OnlyExactMatchFound() {
        taskmanager.unloadFile();

        TaskEntity nextTaskToAdd = new TaskEntity("Groom Cat", "Remember to bring cat to grooming salon");
        nextTaskToAdd.addHashtag("#pets");
        manager.add(nextTaskToAdd, "PLACEHOLDER_SAVE_COMMAND");

        manager.searchString("#pets", "PLACEHOLDER_SAVE_COMMAND");
        manager.switchView(manager.DISPLAY_SEARCH);
        assertEquals("Groom Cat, ", taskmanager.printArrayContentsToString(manager.DISPLAY_OTHERS));

        manager.searchString("#pet", "PLACEHOLDER_SAVE_COMMAND");
        manager.switchView(manager.DISPLAY_SEARCH);
        assertEquals("", taskmanager.printArrayContentsToString(manager.DISPLAY_OTHERS));
    }
}
```
###### test\logic\JUnitTaskUtils.java
``` java
 * 
 *          Testing unit for TaskUtils's functionalities
 */

package test.logic;

import static org.junit.Assert.assertEquals;

import java.util.Calendar;

import org.junit.Test;

import entity.TaskEntity;
import logic.TaskUtils;

public class JUnitTaskUtils {

    @Test
    public void testTaskUtils_ConvertDecToBase36_numberMatches() {
        String r0 = TaskUtils.convertDecToBase36(0);
        String r1 = TaskUtils.convertDecToBase36(100);
        String r2 = TaskUtils.convertDecToBase36(1000);
        String r3 = TaskUtils.convertDecToBase36(10000);
        String r4 = TaskUtils.convertDecToBase36(100000);

        assertEquals(r0, "0");
        assertEquals(r1, "2S");
        assertEquals(r2, "RS");
        assertEquals(r3, "7PS");
        assertEquals(r4, "255S");
    }

    @Test
    public void testTaskUtils_convertBase36ToDec_numberMatches() {
        int r1 = TaskUtils.convertBase36ToDec("AF");
        int r2 = TaskUtils.convertBase36ToDec("asd");
        int r3 = TaskUtils.convertBase36ToDec("");
        int r4 = TaskUtils.convertBase36ToDec("-");

        assertEquals(r1, 375);
        assertEquals(r2, 13981);
        assertEquals(r3, -1);
        assertEquals(r4, -1);
    }

    @Test
    public void testTaskUtils_DueDateInRange_dueDatesWithinDurationReturnsTrue() {
        TaskEntity due2MinutesPast3Am = new TaskEntity("Due 3:02", null,
                TaskUtils.createDate(1, 1, 2016, 3, 2), false);
        TaskEntity due4Am = new TaskEntity("Due 4am", null, TaskUtils.createDate(1, 1, 2016, 4, 0), false);
        TaskEntity due5Am = new TaskEntity("Due 5am", null, TaskUtils.createDate(1, 1, 2016, 5, 0), false);
        TaskEntity due6Am = new TaskEntity("Due 6am", null, TaskUtils.createDate(1, 1, 2016, 6, 0), false);
        TaskEntity due4AmOtherDay = new TaskEntity("Due 4am another day", null,
                TaskUtils.createDate(2, 1, 2016, 6, 0), false);
        TaskEntity from0300to0500 = new TaskEntity("From 3:05 to 5:00",
                TaskUtils.createDate(1, 1, 2016, 3, 5), TaskUtils.createDate(1, 1, 2016, 5, 0), false);

        assertEquals(false, TaskUtils.checkDueDateInRange(due2MinutesPast3Am, from0300to0500));
        assertEquals(true, TaskUtils.checkDueDateInRange(due4Am, from0300to0500));
        assertEquals(true, TaskUtils.checkDueDateInRange(due5Am, from0300to0500));
        assertEquals(false, TaskUtils.checkDueDateInRange(due6Am, from0300to0500));
        assertEquals(false, TaskUtils.checkDueDateInRange(due4AmOtherDay, from0300to0500));
    }

    @Test
    public void testTaskUtils_CheckOverlappingDuration_overlappingDurationsReturnsTrue() {
        TaskEntity from0300to0500 = new TaskEntity("From 3:05 to 5:00",
                TaskUtils.createDate(1, 1, 2016, 3, 5), TaskUtils.createDate(1, 1, 2016, 5, 0), false);
        TaskEntity from0652to1100 = new TaskEntity("From 6:52 to 11:00",
                TaskUtils.createDate(1, 1, 2016, 6, 52), TaskUtils.createDate(1, 1, 2016, 11, 0), false);
        TaskEntity from0152to0428 = new TaskEntity("From 1:52 to 4:28",
                TaskUtils.createDate(1, 1, 2016, 1, 52), TaskUtils.createDate(1, 1, 2016, 4, 28), false);
        TaskEntity from1010to2210 = new TaskEntity("From 10:10 to 22:10",
                TaskUtils.createDate(1, 1, 2016, 10, 10), TaskUtils.createDate(1, 1, 2016, 22, 10), false);
        TaskEntity from0000to2359OtherDay = new TaskEntity("From 00:00 to 23:59 another day",
                TaskUtils.createDate(2, 1, 2016, 0, 0), TaskUtils.createDate(2, 1, 2016, 23, 39), false);

        assertEquals(false, TaskUtils.checkOverlappingDuration(from0300to0500, from0652to1100));
        assertEquals(false, TaskUtils.checkOverlappingDuration(from0152to0428, from0000to2359OtherDay));
        assertEquals(true, TaskUtils.checkOverlappingDuration(from0652to1100, from1010to2210));
        assertEquals(true, TaskUtils.checkOverlappingDuration(from0300to0500, from0152to0428));
        assertEquals(false, TaskUtils.checkOverlappingDuration(from0652to1100, from0152to0428));
    }

    @Test
    public void testTaskUtils_calculateSecondDate_SetToNextYear() {
        Calendar startDate = TaskUtils.createDate(17, 3, 2016);
        Calendar endDate = TaskUtils.createDate(16, 3, 2016);
        TaskEntity testTask = new TaskEntity("Testing task", startDate, endDate, true);

        testTask = TaskUtils.calculateSecondDate(testTask);

        assertEquals("17/3/2016", testTask.printStartDate());
        assertEquals("16/3/2017", testTask.printDueDate());

        startDate = TaskUtils.createDate(17, 3, 2016, 7, 0);
        endDate = TaskUtils.createDate(17, 3, 2016, 7, 0);
    }

    @Test
    public void testTaskUtils_calculateSecondDate_SetToNextDay() {
        Calendar startDate = TaskUtils.createDate(17, 3, 2016, 7, 0);
        Calendar endDate = TaskUtils.createDate(17, 3, 2016, 6, 0);
        TaskEntity testTask = new TaskEntity("Testing task", startDate, endDate, false);

        testTask = TaskUtils.calculateSecondDate(testTask);

        assertEquals("17/3/2016", testTask.printStartDate());
        assertEquals("18/3/2016", testTask.printDueDate());

        startDate = TaskUtils.createDate(30, 3, 2016, 7, 0);
        endDate = TaskUtils.createDate(30, 3, 2016, 6, 0);
        testTask.setDate(startDate, endDate, false);
        testTask = TaskUtils.calculateSecondDate(testTask);

        assertEquals("30/3/2016", testTask.printStartDate());
        assertEquals("1/4/2016", testTask.printDueDate());
    }

    @Test
    public void testTaskUtils_calculateSecondDate_RemainSameDay() {
        Calendar startDate = TaskUtils.createDate(17, 3, 2016, 6, 0);
        Calendar endDate = TaskUtils.createDate(17, 3, 2016, 7, 0);
        TaskEntity testTask = new TaskEntity("Testing task", startDate, endDate, false);

        testTask = TaskUtils.calculateSecondDate(testTask);

        assertEquals("17/3/2016", testTask.printStartDate());
        assertEquals("17/3/2016", testTask.printDueDate());

        startDate = TaskUtils.createDate(17, 3, 2016, 7, 0);
        endDate = TaskUtils.createDate(17, 5, 2016, 6, 0);
        testTask.setDate(startDate, endDate, false);
        testTask = TaskUtils.calculateSecondDate(testTask);

        assertEquals("17/3/2016", testTask.printStartDate());
        assertEquals("17/5/2016", testTask.printDueDate());

        startDate = TaskUtils.createDate(19, 3, 2016, 10, 0);
        endDate = TaskUtils.createDate(17, 5, 2016, 6, 0);
        testTask.setDate(startDate, endDate, false);
        testTask = TaskUtils.calculateSecondDate(testTask);

        assertEquals("19/3/2016", testTask.printStartDate());
        assertEquals("17/5/2016", testTask.printDueDate());

    }

    @Test
    public void testTaskUtils_calculateSecondDate_RemoveStartTime() {
        Calendar startDate = TaskUtils.createDate(17, 3, 2016);
        Calendar endDate = TaskUtils.createDate(17, 3, 2016);
        TaskEntity testTask = new TaskEntity("Testing task", startDate, endDate, true);

        testTask = TaskUtils.calculateSecondDate(testTask);

        assertEquals("", testTask.printStartDate());
        assertEquals("17/3/2016", testTask.printDueDate());

        // Full day task, so 7am and 6am irrelevant, counted as exact same day
        startDate = TaskUtils.createDate(17, 3, 2016, 7, 0);
        endDate = TaskUtils.createDate(17, 3, 2016, 6, 0);
        testTask.setDate(startDate, endDate, true);
        testTask = TaskUtils.calculateSecondDate(testTask);

        assertEquals("", testTask.printStartDate());
        assertEquals("17/3/2016", testTask.printDueDate());
    }
}
```
