# A0125514N
###### src\blackandwhite.css
``` css
.cssLabels,.cssLabelsFloatingBar,.cssLabelsFloatingTaskInterface,
.cssLabelsSearchView{
	-fx-text-fill:rgba(255,255,255,1.0);
	-fx-fill:rgba(255,255,255,1.0);
}
.cssLabelsDescription,.cssLabelsDetails,.cssLabelsCommandBar{
	-fx-text-fill:rgba(0,0,0,1.0);
	-fx-fill:rgba(0,0,0,1.0);
}

#cssCommandMainUserInput {
    -fx-background-color: rgba(0,0,0,1);
    -fx-font: 12.0px "Arial";
}

#commandText {
	-fx-font: 12.0px "Arial";
}

/* Help Screen */

#cssHelpScreenRoot{
	-fx-background-color: rgba(255.0,255.0,255.0,0.5);
}

#cssHelpComponentHighLighter{
	-fx-background-color: rgba(0.0,0.0,0.0,0.1);
	-fx-border-width: 1.0; 
	-fx-border-color: black;
}

#cssHelpComponentLinker{
	-fx-background-color: rgba(0.0,0.0,0.0,1.0);
}

#cssHelpComponentDescriptionBox{
	-fx-background-color: rgba(255.0,255.0,255.0,1.0);
	-fx-border-width: 1.0; 
	-fx-border-color: black;
}

#cssHelpTitle{
	-fx-text-fill: rgba(240.0,180.0,50.0,1.0);
	-fx-border-width: 0.0 0.0 1.0 0.0; 
	-fx-border-color: black;
}


#rootPane{
	-fx-border-color: #d3d3d3;
    -fx-border-width: 2.0px;
}

.controlFocus {
	-fx-border-color: #FF00FF;
	-fx-border-width: 2.0px;
}

/* css Task view  */
#cssTaskViewMainBackground{
	-fx-background-color: rgba(0,0,0,0.9);
}

#cssTaskViewWeekSelected{
	-fx-background-color: rgba(28, 22, 22,1);
}

#cssTaskViewWeekUnSelected{
	-fx-background-color: rgba(0,0,0,0.5);
}

#cssTaskViewDayBoxSelected{
}

#cssTaskViewDayBoxUnSelected{	
}

#cssTaskViewSelectedTask{
	-fx-background-radius: 20.0; 
	-fx-background-color:  rgba(255.0,178.5,127.5,0.3);
	-fx-background-insets: 1.0 5.0 1.0 5.0;
}

#cssTaskViewUnSelectedTask{
}

#cssTaskViewDayLabel{
	-fx-border-width: 0.0 0.0 1.0 0.0; 
	-fx-border-color: black;
}

/* css description panel */

#cssDescriptionLabelSelected{
	-fx-background-color:rgba(255.0,178.5,127.5,1);
}

#cssDescriptionLabelUnSelected{
	-fx-background-color:rgba(255,255,255,0.2);
}

#cssRootDescriptionViewMainBackground{
	-fx-background-color: rgba(0,0,0,0.9);
}



#cssDetailComponentRoot{
	-fx-background-color: rgba(0,0,0,0.9);
}

#cssDetailComponentRootAssociation{
	-fx-background-color: rgba(255.0,178.5,127.5,1),rgba(0,0,0,0.9);
	-fx-background-insets: 0,2;
}

#cssDetailComponentEmptyTitle {
	-fx-background-color: rgba(255.0,178.5,127.5,1.0);	
}

#cssDetailComponentProjectHeadBox{
	-fx-background-color: rgba(255.0,255.0,255.0,0.95);
}

#cssExpandedViewVBox{
	-fx-background-color: rgba(255.0,255.0,255.0,0.9);
	-fx-background-radius: 7.0;
	-fx-background-insets: 0.0 5.0 0.0 5.0;
}

#cssExpandedViewVBoxSelected{
	-fx-background-color: rgba(255.0,178.5,127.5,0.8);
	-fx-background-radius: 7.0;
	-fx-background-insets: 0.0 5.0 0.0 5.0;
}

#cssDetailAssociationListBox
{
	-fx-background-color: rgba(255.0,255.0,255.0,0.0);
	-fx-background-insets: 0.0 0.0 0.0 0.0;
}

/* Floating Bar CSS */
#cssRootFloatingBar{
	-fx-background-color: rgba(255.0,178.5,127.5,1.0), rgba(0,0,0,1);
	-fx-background-insets: 0.0,0.0 10.0 0.0 10.0;
}
#cssFloatingBarContentArea{
	-fx-border-width:  0.0 0.0 0.0 1.0; 
	-fx-border-color: black;
}

#cssFloatingBarTitleLabel{

}

/* Floating Task View CSS */

#cssRootFloatingTaskView{
	-fx-background-color: rgba(255.0,178.5,127.5,1.0),rgba(0,0,0,1.0);
	-fx-background-insets: 0.0,5.0;
}

#cssFloatingTaskViewTitle
{
	-fx-background-color: rgba(255.0,178.5,127.5,1.0);
}
#cssFloatingTaskViewSelected{
	-fx-background-radius: 20.0; 
	-fx-background-color:  rgba(255.0,178.5,127.5,0.3);
	-fx-background-insets: 1.0 7.0 1.0 7.0;
}

/* Search View CSS */
#cssRootSearchView{
	-fx-background-color: rgba(191.0, 80.0, 191.0,1.0,1.0),rgba(0,0,0,1.0);
	-fx-background-insets: 0.0,5.0;
}
#cssSearchTitle{
	-fx-background-color: rgba(191.0, 80.0, 191.0,1.0);
}

#cssSearchSelected{
	-fx-background-color: rgba(191.0, 80.0, 191.0,0.3);
	-fx-background-radius: 20.0; 
	-fx-background-insets: 1.0 7.0 1.0 7.0;
}

/* CommandsBar CSS */

#cssCommandBarMainStructure{
	-fx-background-color: rgba(0,0,0,1);
}

#cssCommandBarContentZone{
	-fx-border-width: 1.0 0.0 1.0 0.0; 
	-fx-border-color: black;
}

#cssCommandBarfeedback_normal
{
	-fx-background-color: rgba(179.0, 255.0, 153.0, 1.0);
}
#cssCommandBarfeedback_conflict
{
	-fx-background-color: rgba(249.0, 186.0, 122.0, 1.0);
}
#cssCommandBarfeedback_past{
	-fx-background-color: rgba(246.0, 246.0, 39.0, 1.0);
}

#cssCommandBarfeedback_conflict_past{
	-fx-background-color: rgba(180, 251.0, 212.0, 1.0);
}

#cssCommandBarfeedback_error
{
	-fx-background-color: rgba(249.0, 122.0, 122.0,1.0);
}

/* Commands CSS */

#cssCommandBarAdd {
	-fx-background-color: rgba(72.0, 238.0, 56.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
	
}

#cssCommandBarInvalid{
	-fx-text-fill:rgba(255.0,0.0,0.0,1.0);
}

#cssCommandBarDelete {
	-fx-background-color: rgba(56.0, 238.0, 223.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}

#cssCommandBarEdit {
	-fx-background-color: rgba(56.0, 163.0, 238.0, 0.5);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}

#cssCommandBarLink {
	-fx-background-color: rgba(163.0, 238.0, 56.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}

#cssCommandBarDone {
	-fx-background-color: rgba(238.0, 132.0, 56.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}

#cssCommandTitle {
	-fx-background-color: rgba(202.0, 247.0, 140.0, 1.0);
	-fx-background-radius: 7.0; 
}
#cssCommandDate {
	-fx-background-color: rgba(247.0, 140.0, 149.0, 1.0);
	-fx-background-radius: 7.0; 
}
#cssCommandHashTag{
	-fx-background-color: rgba(247.0, 238.0, 140.0, 1.0);
	-fx-background-radius: 7.0; 
}

#cssCommandID {
	-fx-background-color: rgba(247.0, 184.0, 140.0, 1.0);
	-fx-background-radius: 7.0; 
}
#cssCommandDescription {
	-fx-background-color: rgba(140.0, 202.0, 247.0, 1.0);
	-fx-background-radius: 7.0; 
}

#cssCommandJump {
	-fx-background-color: rgba(238.0, 56.0, 163.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}
#cssCommandSearch{
	-fx-background-color: rgba(132.0, 56.0, 238.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}

#cssCommandExit{
	-fx-text-fill:white;
	-fx-background-color: rgba(238.0, 56.0, 72.0, 1.0);
	-fx-font-weight:bold;
	 -fx-font: 20.0px "Arial";
}

#cssCommandFloat{
	-fx-background-color: rgba(238.0, 132.0, 56.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}
#cssCommandShow{
	-fx-background-color: rgba(223.0, 56.0, 238.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}
#cssCommandHide{
	-fx-background-color: rgba(223.0, 56.0, 238.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}
#cssCommandMain{
	-fx-background-color: rgba(238.0, 56.0, 163.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}
#cssCommandSaveDir{
	-fx-background-color: rgba(183.0, 220.0, 40.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}
#cssCommandUndo{
	-fx-background-color: rgba(240.0, 180.0, 20.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}

#cssCommandOther{
	-fx-text-fill:rgba(255,255,255,1.0);
}

#cssCommandTheme{
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(238.0, 120, 163.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}
#cssCommandLoadFrom{
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(183.0, 220.0, 40.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}
```
###### src\default.css
``` css
.cssLabels,.cssLabelsDescription,.cssLabelsDetails,.cssLabelsFloatingBar,.cssLabelsFloatingTaskInterface,
.cssLabelsSearchView, .cssLabelsCommandBar{
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-fill:rgba(0.0,0.0,0.0,1.0);
}

#cssCommandMainUserInput {
    -fx-background-color: -fx-control-inner-background;
    -fx-font: 12.0px "Arial";
}

#commandText {
	-fx-font: 12.0px "Arial";
}

/* Help Screen */

#cssHelpScreenRoot{
	-fx-background-color: rgba(255.0,255.0,255.0,0.5);
}

#cssHelpComponentHighLighter{
	-fx-background-color: rgba(0.0,0.0,0.0,0.1);
	-fx-border-width: 1.0; 
	-fx-border-color: black;
}

#cssHelpComponentLinker{
	-fx-background-color: rgba(0.0,0.0,0.0,1.0);
}

#cssHelpComponentDescriptionBox{
	-fx-background-color: rgba(255.0,255.0,255.0,1.0);
	-fx-border-width: 1.0; 
	-fx-border-color: black;
}

#cssHelpTitle{
	-fx-text-fill: rgba(240.0,180.0,50.0,1.0);
	-fx-border-width: 0.0 0.0 1.0 0.0; 
	-fx-border-color: black;
}


#rootPane{
	-fx-border-color: #d3d3d3;
    -fx-border-width: 2.0px;
}

.controlFocus {
	-fx-border-color: #FF00FF;
	-fx-border-width: 2.0px;
}

/* css Task view  */
#cssTaskViewMainBackground{
	-fx-background-color: rgba(255.0,255.0,255.0,0.9);
}

#cssTaskViewWeekSelected{
	-fx-background-color: rgba(193.0,230.0,255.0,0.95);
}

#cssTaskViewWeekUnSelected{
	-fx-background-color: rgba(255.0,255.0,255.0,0.9);
}

#cssTaskViewDayBoxSelected{
}

#cssTaskViewDayBoxUnSelected{	
}

#cssTaskViewSelectedTask{
	-fx-background-radius: 20.0; 
	-fx-background-color:  rgba(255.0, 255.0, 255.0, 0.8);
	-fx-background-insets: 1.0 5.0 1.0 5.0;
}

#cssTaskViewUnSelectedTask{
}

#cssTaskViewDayLabel{
	-fx-border-width: 0.0 0.0 1.0 0.0; 
	-fx-border-color: black;
}

/* css expanded panel */
#cssExpandedViewVBox{
	-fx-background-color: rgba(255.0,255.0,255.0,0.9);
	-fx-background-radius: 7.0;
	-fx-background-insets: 0.0 5.0 0.0 5.0;
}

#cssExpandedViewVBoxSelected{
	-fx-background-color: rgba(255.0,230.0,255.0,1.0);
	-fx-background-radius: 7.0;
	-fx-background-insets: 0.0 5.0 0.0 5.0;
}

/* css description panel */

#cssRootDescriptionViewMainBackground{
	-fx-background-color: rgba(255.0,255.0,255.0,0.9);
}

#cssDescriptionLabelSelected{
	-fx-background-color:rgba(255.0,178.5,127.5,1.0);
}

#cssDescriptionLabelUnSelected{
	-fx-background-color:rgba(255.0,255.0,255.0,0.3);
}

/* Detail Componenet CSS */

#cssDetailComponentRoot{
	-fx-background-color: rgba(255.0,255.0,255.0,0.7),rgba(193.0,230.0,255.0,0.95);
}

#cssDetailComponentRootAssociation{
	-fx-background-color: rgba(255.0,178.5,127.5,1),rgba(255.0,255.0,255.0,0.7),rgba(193.0,230.0,255.0,0.95);
	-fx-background-insets: 0,2,2;
}

#cssDetailComponentEmptyTitle {
	-fx-background-color: rgba(255.0,178.5,127.5,1.0);	
}

#cssDetailComponentProjectHeadBox{
	-fx-background-color: rgba(255.0,255.0,255.0,0.95);
}

#cssDetailAssociationListBox{
	-fx-background-color: rgba(255.0,255.0,255.0,0.0);
	-fx-background-insets: 0.0 0.0 0.0 0.0;
}


/* Floating Bar CSS */

#cssRootFloatingBar{
	-fx-background-color: rgba(255.0,178.5,127.5,1.0), rgba(255.0,255.0,255.0,0.7);
	-fx-background-insets: 0.0,0.0 10.0 0.0 10.0;
}

#cssFloatingBarContentArea{
	-fx-border-width:  0.0 0.0 0.0 1.0; 
	-fx-border-color: black;
}

#cssFloatingBarTitleLabel{

}

/* Floating Task View CSS */

#cssRootFloatingTaskView{
	-fx-background-color: rgba(255.0,178.5,127.5,1.0),rgba(255.0,255.0,255.0,1.0);
	-fx-background-insets: 0.0,5.0;
}

#cssFloatingTaskViewTitle{
	-fx-background-color: rgba(255.0,178.5,127.5,1.0);
}

#cssFloatingTaskViewSelected{
	-fx-background-radius: 20.0; 
	-fx-background-color:  rgba(255.0,178.5,127.5,0.3);
	-fx-background-insets: 1.0 7.0 1.0 7.0;
}

/* Search View CSS */
#cssRootSearchView{
	-fx-background-color: rgba(191.0, 80.0, 191.0,1.0,1.0),rgba(255.0,255.0,255.0,1.0);
	-fx-background-insets: 0.0,5.0;
}

#cssSearchTitle{
	-fx-background-color: rgba(191.0, 80.0, 191.0,1.0);
}

#cssSearchSelected{
	-fx-background-color: rgba(191.0, 80.0, 191.0,0.3);
	-fx-background-radius: 20.0; 
	-fx-background-insets: 1.0 7.0 1.0 7.0;
}

/* CommandsBar CSS */

#cssCommandBarMainStructure{
	-fx-background-color: rgba(255.0,255.0,255.0,0.8);
}

#cssCommandBarContentZone{
	-fx-border-width: 1.0 0.0 1.0 0.0; 
	-fx-border-color: black;
}


#cssCommandBarfeedback_normal{
	-fx-background-color: rgba(179.0, 255.0, 153.0, 1.0);
}

#cssCommandBarfeedback_conflict{
	-fx-background-color: rgba(249.0, 186.0, 122.0, 1.0);
}

#cssCommandBarfeedback_past{
	-fx-background-color: rgba(246.0, 246.0, 39.0, 1.0);
}

#cssCommandBarfeedback_conflict_past{
	-fx-background-color: rgba(180.0, 251.0, 212.0, 1.0);
}

#cssCommandBarfeedback_error{
	-fx-background-color: rgba(249.0, 122.0, 122.0,1.0);
}

/* Commands CSS */

#cssCommandBarAdd {
	-fx-background-color: rgba(72.0, 238.0, 56.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}

#cssCommandBarInvalid{
	-fx-text-fill:rgba(255.0,0.0,0.0,1.0);
}

#cssCommandBarDelete {
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(56.0, 238.0, 223.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}

#cssCommandBarEdit {
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(56.0, 163.0, 238.0, 0.5);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}

#cssCommandBarLink {
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(163.0, 238.0, 56.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}

#cssCommandBarDone {
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(238.0, 132.0, 56.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}

#cssCommandTitle {
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(202.0, 247.0, 140.0, 1.0);
	-fx-background-radius: 7.0; 
}
#cssCommandDate {
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(247.0, 140.0, 149.0, 1.0);
	-fx-background-radius: 7.0; 
}
#cssCommandHashTag{
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(247.0, 238.0, 140.0, 1.0);
	-fx-background-radius: 7.0; 
}

#cssCommandID {
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(247.0, 184.0, 140.0, 1.0);
	-fx-background-radius: 7.0; 
}
#cssCommandDescription {
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(140.0, 202.0, 247.0, 1.0);
	-fx-background-radius: 7.0; 
}

#cssCommandJump {
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(238.0, 56.0, 163.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}
#cssCommandSearch{
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(132.0, 56.0, 238.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}

#cssCommandExit{
	-fx-text-fill:white;
	-fx-background-color: rgba(238.0, 56.0, 72.0, 1.0);
	-fx-font-weight:bold;
	 -fx-font: 20.0px "Arial";
}

#cssCommandFloat{
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(238.0, 132.0, 56.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}
#cssCommandShow{
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(223.0, 56.0, 238.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}
#cssCommandHide{
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(223.0, 56.0, 238.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}
#cssCommandMain{
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(238.0, 56.0, 163.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}
#cssCommandSaveDir{
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(183.0, 220.0, 40.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}
#cssCommandUndo{
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(240.0, 180.0, 20.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}

#cssCommandOther{
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
}

#cssCommandTheme{
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(238.0, 120.0, 163.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}
#cssCommandLoadFrom{
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(183.0, 220.0, 40.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}
```
###### src\userinterface\CommandBar.java
``` java
 * 
 *          This class handles the building of the command bar and the feedback
 *          messgaes.
 */
package userinterface;

import java.util.ArrayList;

import entity.ResultSet;
import entity.TaskEntity;
import javafx.event.EventHandler;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.VBox;
import javafx.scene.text.Font;
import parser.CommandParser;
import parser.InputParser;
import parser.Pair;
import parser.XMLParser;
import parser.CommandParser.COMMAND;
import javafx.scene.Node;

public class CommandBar {

    // Feedback status
    private static final int FEEDBACK_STATUS_ERROR = 0;
    private static final int FEEDBACK_STATUS_NORMAL = 1;
    private static final int FEEDBACK_STATUS_CONFLICT = 2;
    private static final int FEEDBACK_STATUS_PAST = 3;
    private static final int FEEDBACK_STATUS_CONFLICT_PAST = 4;

    // Feedback messages
    private static final String MESSAGE_FAILURE_INVALID = "you have entered an invalid command";

    private static final String MESSAGE_SUCCESS_ADD_TYPE_1 = "Successfully added %1$s to list.";
    private static final String MESSAGE_SUCCESS_ADD_TYPE_2 = "Successfully added %1$s to task list.";
    private static final String MESSAGE_SUCCESS_ADD_TYPE_3 = "Successfully added %1$s to floating task list.";
    private static final String MESSAGE_FAILURE_ADD_TYPE_1 = "Fail to add.";
    private static final String MESSAGE_FAILURE_ADD_TYPE_2 = "Fail to add task, task requires a name.";
    private static final String MESSAGE_FAILURE_ADD_TYPE_3 = "Fail to add task, Due date is before start date.";

    private static final String MESSAGE_SUCCESS_DELETE = "Successfully deleted %1$s.";
    private static final String MESSAGE_FAILURE_DELETE_TYPE_1 = "Task id required to delete.";
    private static final String MESSAGE_FAILURE_DELETE_TYPE_2 = "Fail to delete %1$s.";

    private static final String MESSAGE_SUCCESS_EDIT = "Successfully edited %1$s.";
    private static final String MESSAGE_FAILURE_EDIT_TYPE_1 = "Fail to edit %1$s.";
    private static final String MESSAGE_FAILURE_EDIT_TYPE_2 = "Fail to retrieve task.";
    private static final String MESSAGE_FAILURE_EDIT_TYPE_3 = "Fail to edit task, task name is required.";
    private static final String MESSAGE_FAILURE_EDIT_TYPE_4 = "Fail to add task, Due date is before start date.";

    private static final String MESSAGE_SUCCESS_MARK = "Successfully mark %1$s as completed.";
    private static final String MESSAGE_FAILURE_MARK_TYPE_1 = "Fail to mark %1$s as completed.";
    private static final String MESSAGE_FAILURE_MARK_TYPE_2 = "Invalid task ID";

    private static final String MESSAGE_SUCCESS_SEARCH_TYPE_1 = "Search compelete with %1$s results.";
    private static final String MESSAGE_SUCCESS_SEARCH_TYPE_2 = "No results found.";
    private static final String MESSAGE_FAILURE_SEARCH_TYPE_1 = "No results found.";

    private static final String MESSAGE_FAILURE_JUMP_TYPE_1 = "No index to jump to.";
    private static final String MESSAGE_FAILURE_JUMP_TYPE_2 = "Task id required to jump to.";

    private static final String MESSAGE_SUCCESS_LINK = "Linked successfully.";
    private static final String MESSAGE_FAILURE_LINK_TYPE_1 = "Failed to link, IDs are not within range.";
    private static final String MESSAGE_FAILURE_LINK_TYPE_2 = "Failed to link.";

    private static final String MESSAGE_SUCCESS_UNDO_TYPE_1 = "successfully undo.";
    private static final String MESSAGE_FAILURE_UNDO_TYPE_1 = "There are no commands to undo.";

    private static final String MESSAGE_SUCCESS_SAVETO = "Saved to new file successfully.";
    private static final String MESSAGE_FAILURE_SAVETO = "Unable to create new directory and file. Please check for clashes or duplicate files.";

    private static final String MESSAGE_SUCCESS_THEME = "Successfully changed theme.";
    private static final String MESSAGE_FAILURE_THEME = "Invalid theme. Choose a theme from this list -> %1$s.";

    private static final String MESSAGE_CONFLICT = "Conflict detected.";
    private static final String MESSAGE_PAST = "Task has past deadline.";
    private static final String MESSAGE_CONFLICT_PAST = "Conflict detected and task has past deadline.";

    private static final String MESSAGE_SUCCESS_LOADFROM = "Loaded from %1$s file successfully.";
    private static final String MESSAGE_FAILURE_LOADFROM_TYPE_1 = "Unable to find %1$s. Please check that the file is available for reading.";
    private static final String MESSAGE_FAILURE_LOADFROM_TYPE_2 = "File not in json format.";

    // UserInterface values
    private static final int GAP_SIZE = 0;
    private static final double FEEDBACK_HEIGHT = 20;
    private static final int MAIN_PANE_LEFT_RIGHT_MARGIN = 0;
    private static final int TEXT_FIELD_WIDTH = 10;
    private static final int TWO = 2;
    private static final int ZERO = 0;
    private static final int NOTHING_SELECTED = -1;

    private static final String CSS_LABEL = "cssLabelsCommandBar";

    // Font
    static final int FONT_SIZE_FEEDBACK = 12;
    private static final Font FONT_FEEDBACK = new Font(PrimaryUserInterface.FONT_DEFAULT, FONT_SIZE_FEEDBACK);

    private static CommandBar _myInstance;
    private double _prefHeight;
    private double _prefWidth;
    private double _mainPaneHeight;
    private double _commandLabelHeight;

    private VBox _mainStructure;
    private Label _feedbackLabel;

    private GridPane _mainPane;
    private TextField _textField;
    private int _numberOfItems = ZERO;
    private int _selected;
    private ArrayList<Label> labels = new ArrayList<Label>();
    private ArrayList<String> preCommands = new ArrayList<String>();
    private int _commandSelector;

    private String fullInput = "";
    private int _feedBackCounter;

    /**
     * Create an instance of the CommandBar only if there isn't an instance
     * already.
     * 
     * @param _commandBarWidth
     * @param commandBarHeigth
     * @return CommandBar
     */
    public static CommandBar getInstance(double _commandBarWidth, int commandBarHeigth) {
        if (_myInstance == null) {
            _myInstance = new CommandBar(_commandBarWidth, commandBarHeigth);
            return _myInstance;
        }
        return null;
    }

    /**
     * Builds the CommandBar and all the main components.
     * 
     * @param preWidth
     * @param preHeight
     */
    private CommandBar(double preWidth, double preHeight) {
        _prefHeight = preHeight;
        _prefWidth = preWidth;
        _mainPaneHeight = _prefHeight - FEEDBACK_HEIGHT;
        _commandLabelHeight = _mainPaneHeight / TWO;
        _selected = NOTHING_SELECTED;
        initilizeMainStructure();
        initilizeFeedbackBar();
        initializeMainPane();
        initializeTextBox();
        _mainPane.add(_textField, _numberOfItems++, ZERO);
    }

    public void initilizeMainStructure() {
        _mainStructure = new VBox();
        _mainStructure.setMaxHeight(_prefHeight);
        _mainStructure.setMaxWidth(_prefWidth);
        _mainStructure.setMinHeight(_prefHeight);
        _mainStructure.setMinWidth(_prefWidth);
        _mainStructure.setAlignment(Pos.BOTTOM_LEFT);
        _mainStructure.setId("cssCommandBarMainStructure");
    }

    private void initilizeFeedbackBar() {
        _feedbackLabel = new Label();
        _feedbackLabel.getStyleClass().add(CSS_LABEL);
        _feedbackLabel.setMinWidth(_prefWidth);
        _feedbackLabel.setMaxHeight(FEEDBACK_HEIGHT);
        _feedbackLabel.setMinHeight(FEEDBACK_HEIGHT);
        _feedbackLabel.setFont(FONT_FEEDBACK);
        _feedbackLabel.setAlignment(Pos.CENTER_LEFT);
        _feedbackLabel.setId("cssCommandBarfeedback_normal");
        _feedbackLabel.setOpacity(ZERO);
        _mainStructure.getChildren().add(_feedbackLabel);
    }

    public void initializeMainPane() {
        _mainPane = new GridPane();
        _mainPane.setId("cssCommandBarContentZone");
        _mainPane.setMinHeight(_mainPaneHeight);
        _mainPane.setMaxHeight(_mainPaneHeight);
        _mainPane.setAlignment(Pos.CENTER_LEFT);
        _mainPane.setHgap(GAP_SIZE);
        VBox.setMargin(_mainPane,
                new Insets(ZERO, MAIN_PANE_LEFT_RIGHT_MARGIN, ZERO, MAIN_PANE_LEFT_RIGHT_MARGIN));
        _mainStructure.getChildren().add(_mainPane);
    }

    public void initializeTextBox() {
        _textField = new TextField();
        _textField.setId("cssCommandMainUserInput");
        _textField.setMaxWidth(TEXT_FIELD_WIDTH);
        _textField.setAlignment(Pos.CENTER_LEFT);
        _textField.setPrefHeight(_commandLabelHeight);
        _textField.setPadding(new Insets(ZERO, ZERO, ZERO, ZERO));
        _textField.setBorder(null);
    }

    /**
     * Gets the input from the user and concatenate to the full String.
     */
    public void concatToFullString() {
        String input = _textField.getText();
        if (!input.equals("")) {
            if (_selected == NOTHING_SELECTED) {
                fullInput = fullInput.concat(input);
            } else {
                String front = getFrontString();
                String current = currentString();
                String back = getBackString();
                current = current.concat(input);
                fullInput = rebuildString(front, current, back);
            }
            _textField.setText("");
        }
    }

    public void clearFullString() {
        fullInput = "";
    }

    /**
     * Deletes a character in the fullString base on where the selector is.
     */
    public void deleteKey() {
        if (_selected != NOTHING_SELECTED) {
            String front = getFrontString();
            String current = currentString();
            String back = getBackString();
            current = current.substring(0, current.length() - 1);
            if (current.length() == ZERO) {
                _selected--;
            }
            fullInput = rebuildString(front, current, back);
            onKeyReleased();
        } else {
            if (fullInput.length() > ZERO) {
                fullInput = fullInput.substring(0, fullInput.length() - 1);
            }
            onKeyReleased();
        }
    }

    private String rebuildString(String front, String current, String back) {
        String full = "";
        if (!front.equals("")) {
            full = full.concat(front);
        }
        if (full.equals("")) {
            full = full.concat(current);
        } else {
            full = full.concat(" ").concat(current);
        }
        if (full.equals("")) {
            full = full.concat(back);
        } else {
            full = full.concat(" ").concat(back);
        }
        return full;
    }

    public String getFrontString() {
        String front = "";
        for (int i = 0; i < _selected; i++) {
            front = front.concat(labels.get(i).getText());
            if (i + 1 < _selected) {
                front = front.concat(" ");
            }
        }
        return front;
    }

    public String currentString() {
        return labels.get(_selected).getText();
    }

    public String getBackString() {
        String back = "";
        for (int i = _selected + 1; i < labels.size(); i++) {
            back = back.concat(labels.get(i).getText());
            if (i + 1 < labels.size()) {
                back = back.concat(" ");
            }
        }
        return back;
    }

    public void release() {
        String input = _textField.getText();
        if (!input.equals("")) {
            onKeyReleased();
        }
    }

    /**
     * Gets the user input and concatenate to the fullString and run through the
     * parser. Rebuilds the command bar base on the parser.
     */
    public void onKeyReleased() {
        concatToFullString();
        ArrayList<Node> itemsToAdd = new ArrayList<Node>();
        InputParser parser = new InputParser(fullInput);
        try {
            parser.addXML();
            ArrayList<Pair<String, ArrayList<String>>> items = XMLParser.xmlToArrayList(parser.getInput());
            for (int i = 0; i < items.size(); i++) {
                Label label = buildItem(items.get(i));
                if (label != null) {
                    itemsToAdd.add(label);
                }
            }
            addItemsToBar(itemsToAdd);
        } catch (Exception e) {
        }
    }

    private void addItemsToCommandBar(ArrayList<Label> itemsToAdd) {
        ArrayList<Node> temp = new ArrayList<Node>();
        for (Label i : itemsToAdd) {
            temp.add(i);
        }
        addItemsToBar(temp);
    }

    /**
     * Creates the new labels and place them inside the commandBar.
     * 
     * @param itemsToAdd
     */
    private void addItemsToBar(ArrayList<Node> itemsToAdd) {
        _mainPane.getChildren().clear();
        labels.clear();
        _numberOfItems = 0;
        if (itemsToAdd.size() == 0) {
            _selected = NOTHING_SELECTED;
        }
        if (_selected == NOTHING_SELECTED) {
            itemsToAdd.add(_textField);
        } else {
            itemsToAdd.add(_selected + 1, _textField);
        }

        for (int i = 0; i < itemsToAdd.size(); i++) {
            _mainPane.add(itemsToAdd.get(i), _numberOfItems++, 1);
            if (itemsToAdd.get(i) instanceof Label) {
                Label l = (Label) itemsToAdd.get(i);
                GridPane.setMargin(l, new Insets(ZERO, ZERO, ZERO, TWO));
                labels.add(l);
            }
        }
    }

    /**
     * Build the individual label base on the XML tag.
     * 
     * @param item
     * @return Label
     */
    public Label buildItem(Pair<String, ArrayList<String>> item) {
        String type = item.getFirst();
        if (type.equals(XMLParser.CMD_TAG)) {
            return buildCommandDisplay(item.getSecond());
        } else if (type.equals(XMLParser.TITLE_TAG)) {
            return buildTitleLabel(item.getSecond());
        } else if (type.equals(XMLParser.DESC_TAG)) {
            return buildDescLabel(item.getSecond());
        } else if (type.equals(XMLParser.ID_TAG)) {
            return buildIDLabel(item.getSecond());
        } else if (type.equals(XMLParser.DATE_TAG)) {
            return buildDateLabel(item.getSecond());
        } else if (type.equals(XMLParser.OTHERS_TAG)) {
            return buildNormalLabel(item.getSecond());
        } else if (type.equals(XMLParser.HASH_TAG)) {
            return buildHashTagLabel(item.getSecond());
        }
        return null;
    }

    /**
     * Builds a basic structure that all labels share.
     * 
     * @return
     */
    public Label buildLabelSkeleton() {
        Label label = new Label();
        label.setMinHeight(_commandLabelHeight);
        label.setAlignment(Pos.BASELINE_RIGHT);
        return label;
    }

    private Label buildNormalLabel(ArrayList<String> other) {
        Label label = buildLabelSkeleton();
        label.setText(other.get(0));
        label.setId("cssCommandOther");
        return label;
    }

    private Label buildDateLabel(ArrayList<String> dates) {
        Label label = buildLabelSkeleton();
        String text = "";
        for (int i = 0; i < dates.size(); i++) {
            text = text.concat(dates.get(i));
            if (i < dates.size() - 1) {
                text.concat(" ");
            }
        }
        label.setText(text);
        label.setId("cssCommandDate");
        return label;
    }

    public Label buildIDLabel(ArrayList<String> text) {
        Label label = buildLabelSkeleton();
        label.setText(text.get(0));
        label.setId("cssCommandID");
        return label;
    }

    public Label buildHashTagLabel(ArrayList<String> text) {
        Label label = buildLabelSkeleton();
        label.setText(text.get(0));
        label.setId("cssCommandHashTag");
        return label;
    }

    public Label buildDescLabel(ArrayList<String> text) {
        Label label = buildLabelSkeleton();
        label.setText(text.get(0));
        label.setId("cssCommandDescription");
        return label;
    }

    public Label buildTitleLabel(ArrayList<String> text) {
        Label label = buildLabelSkeleton();
        label.setText(text.get(0));
        label.setId("cssCommandTitle");
        return label;
    }

    public Label buildCommandDisplay(ArrayList<String> text) {
        CommandParser cp = new CommandParser();
        if (text.size() == 1) {
            String commandString = text.get(0);
            Label label = buildLabelSkeleton();
            label.setText(commandString.toUpperCase());
            COMMAND cmd = cp.getCommand(commandString);
            switch (cmd) {
                case ADD : {
                    label.setId("cssCommandBarAdd");
                    break;
                }
                case DELETE : {
                    label.setId("cssCommandBarDelete");
                    break;
                }
                case EDIT : {
                    label.setId("cssCommandBarEdit");
                    break;
                }
                case INVALID : {
                    label.setId("cssCommandBarInvalid");
                    break;
                }
                case JUMP : {
                    label.setId("cssCommandJump");
                    break;
                }
                case DONE : {
                    label.setId("cssCommandBarDone");
                    break;
                }
                case SEARCH : {
                    label.setId("cssCommandSearch");
                    break;
                }
                case LINK : {
                    label.setId("cssCommandBarLink");
                    break;
                }
                case EXIT : {
                    label.setId("cssCommandExit");
                    break;
                }
                case FLOAT : {
                    label.setId("cssCommandFloat");
                    break;
                }
                case MAIN : {
                    label.setId("cssCommandMain");
                    break;
                }
                case HIDE : {
                    label.setId("cssCommandHide");
                    break;
                }
                case SHOW : {
                    label.setId("cssCommandShow");
                    break;
                }
                case SAVETO : {
                    label.setId("cssCommandSaveDir");
                    break;
                }
                case UNDO : {
                    label.setId("cssCommandUndo");
                    break;
                }
                case THEME : {
                    label.setId("cssCommandTheme");
                    break;
                }
                case LOADFROM : {
                    label.setId("cssCommandLoadFrom");
                    break;
                }
                default :
                    break;
            }
            return label;
        }
        return null;
    }

    public COMMAND onEnter() {
        onKeyReleased();
        preCommands.add(fullInput);
        _commandSelector = preCommands.size();
        InputParser parser = new InputParser(fullInput);
        COMMAND cmd = parser.getCommand();
        return cmd;
    }

    /**
     * Gets the tasks that the parser has build from the user input.
     * 
     * @return lists of TaskEntity
     */
    public ArrayList<TaskEntity> getTasks() {
        InputParser parser = new InputParser(fullInput);
        return parser.getTask();
    }

    /**
     * Gets the partial input that the parser has identified.
     * 
     * @return list of TaskEntity
     */
    public ArrayList<TaskEntity> getTasksPartialInput() {
        InputParser parser = new InputParser(fullInput);
        parser.removeId();
        return parser.getTask();
    }

    /**
     * Gets the ID that the parser has identified.
     * 
     * @return id
     */
    public String getId() {
        String returnVal = null;
        InputParser parser = new InputParser(fullInput);
        returnVal = parser.getID();
        return returnVal;
    }

    /**
     * Gets the String that the parser has identified as the search String.
     * 
     * @return search string
     */
    public String getSearchStr() {
        InputParser parser = new InputParser(fullInput);
        return parser.getSearchString();
    }

    /**
     * Gets the ids of the two task that needs to be link which the parser has
     * identified.
     * 
     * @return Pair
     */
    public Pair<String, String> getLinkId() {
        Pair<String, String> returnVal = null;
        InputParser parser = new InputParser(fullInput);
        returnVal = parser.getLinkID();
        return returnVal;
    }

    /**
     * Sets the main textField handler to the given eventHandler.
     * 
     * @param mainEventHandler
     * @param secondaryEventHandler
     */
    public void setTextFieldHandler(EventHandler<KeyEvent> mainEventHandler,
            EventHandler<KeyEvent> secondaryEventHandler) {
        _textField.setOnKeyPressed(mainEventHandler);
        _textField.setOnKeyReleased(secondaryEventHandler);
    }

    public void focus() {
        _mainPane.requestFocus();
        _textField.requestFocus();
    }

    public TextField getTextField() {
        return _textField;
    }

    public VBox getCommandBar() {
        return _mainStructure;
    }

    public String getFullInput() {
        return fullInput;
    }

    public void setFullInput(String toSet) {
        fullInput = toSet;
    }

    public void addToFullInput(String toSet) {
        fullInput = fullInput.trim().concat(" ").concat(toSet.trim());
    }

    /**
     * Change the selector and underline the label that is being selected.
     */
    public void changeSelector() {
        if (labels.size() > 0) {
            int tempSelector = _selected;
            if (_selected + 1 < labels.size() - 1) {
                tempSelector++;
            } else {
                tempSelector = -1;
            }
            // change in selector detected
            if (tempSelector != _selected && _selected != -1) {
                labels.get(_selected).setUnderline(false);
            }
            if (tempSelector != -1) {
                labels.get(tempSelector).setUnderline(true);
            }
            _selected = tempSelector;
        }
        addItemsToCommandBar(labels);
    }

    public void setFeedBackMessage(String feedback) {
        _feedbackLabel.setText(feedback);
    }

    /**
     * Resets the commandBar to get ready for new command.
     */
    public void reset() {
        _selected = -1;
        setFullInput("");
        ArrayList<Node> temp = new ArrayList<Node>();
        addItemsToBar(temp);
    }

    /**
     * Shows the feedback message.
     * 
     * @param cmdType
     * @param resultSet
     * @param msg
     */
    public void showFeedBackMessage(COMMAND cmdType, ResultSet resultSet, String msg) {
        switch (cmdType) {
            case INVALID : {
                setFeedBackMessage(MESSAGE_FAILURE_INVALID);
                setFeedBackColor(FEEDBACK_STATUS_ERROR);
                break;
            }
            case ADD : {
                if (resultSet != null) {
                    String feedBackMsg = "";
                    if (resultSet.isSuccess()) {
                        if (resultSet.getIndex() > -1) {
                            feedBackMsg = feedBackMsg.concat(String.format(MESSAGE_SUCCESS_ADD_TYPE_1, msg));
                        } else {
                            if (resultSet.getView() == ResultSet.ASSOCIATE_VIEW
                                    || resultSet.getView() == ResultSet.EXPANDED_VIEW
                                    || resultSet.getView() == ResultSet.TASK_VIEW) {
                                feedBackMsg = feedBackMsg
                                        .concat(String.format(MESSAGE_SUCCESS_ADD_TYPE_2, msg));
                            } else if (resultSet.getView() == ResultSet.FLOATING_VIEW) {
                                feedBackMsg = feedBackMsg
                                        .concat(String.format(MESSAGE_SUCCESS_ADD_TYPE_3, msg));
                            }
                        }

                        String feedback = processFeedBackColor(resultSet.getStatus());
                        if (feedback != null) {
                            feedBackMsg = feedBackMsg.concat(" ").concat(feedback);
                        }
                        setFeedBackMessage(feedBackMsg);
                    } else {
                        if (resultSet.getStatus() == ResultSet.STATUS_INVALID_NAME) {
                            setFeedBackMessage(MESSAGE_FAILURE_ADD_TYPE_2);
                        } else if (resultSet.getStatus() == ResultSet.STATUS_INVALID_DATE) {
                            setFeedBackMessage(MESSAGE_FAILURE_ADD_TYPE_3);
                        } else {
                            setFeedBackMessage(MESSAGE_FAILURE_ADD_TYPE_1);
                        }
                        setFeedBackColor(FEEDBACK_STATUS_ERROR);
                    }
                }
                break;
            }
            case DELETE : {
                if (resultSet == null) {
                    setFeedBackMessage(MESSAGE_FAILURE_DELETE_TYPE_1);
                    setFeedBackColor(FEEDBACK_STATUS_ERROR);
                } else {
                    if (resultSet.isSuccess()) {
                        setFeedBackMessage(String.format(MESSAGE_SUCCESS_DELETE, msg));
                        processFeedBackColor(resultSet.getStatus());
                    } else {
                        setFeedBackMessage(String.format(MESSAGE_FAILURE_DELETE_TYPE_2, msg));
                        setFeedBackColor(FEEDBACK_STATUS_ERROR);
                    }
                }
                break;
            }
            case EDIT : {
                if (resultSet == null) {
                    setFeedBackMessage(MESSAGE_FAILURE_EDIT_TYPE_2);
                    setFeedBackColor(FEEDBACK_STATUS_ERROR);
                } else {
                    if (resultSet.isSuccess()) {
                        String feedback = processFeedBackColor(resultSet.getStatus());
                        String feedBackMsg = String.format(MESSAGE_SUCCESS_EDIT, msg);
                        if (feedback != null) {
                            feedBackMsg = feedBackMsg.concat(" ").concat(feedback);
                        }
                        setFeedBackMessage(feedBackMsg);
                    } else {

                        if (resultSet.getStatus() == ResultSet.STATUS_INVALID_NAME) {
                            setFeedBackMessage(MESSAGE_FAILURE_EDIT_TYPE_3);
                        } else if (resultSet.getStatus() == ResultSet.STATUS_INVALID_DATE) {
                            setFeedBackMessage(MESSAGE_FAILURE_EDIT_TYPE_4);
                        } else {
                            setFeedBackMessage(String.format(MESSAGE_FAILURE_EDIT_TYPE_1, msg));
                        }
                        setFeedBackColor(FEEDBACK_STATUS_ERROR);
                    }
                }
                break;
            }
            case DONE : {
                if (resultSet != null) {
                    if (resultSet.isSuccess()) {
                        setFeedBackMessage(String.format(MESSAGE_SUCCESS_MARK, msg));
                        setFeedBackColor(FEEDBACK_STATUS_NORMAL);
                    } else {
                        setFeedBackMessage(String.format(MESSAGE_FAILURE_MARK_TYPE_1, msg));
                        setFeedBackColor(FEEDBACK_STATUS_ERROR);
                    }
                } else {
                    setFeedBackMessage(MESSAGE_FAILURE_MARK_TYPE_2);
                    setFeedBackColor(FEEDBACK_STATUS_ERROR);
                }
                break;
            }
            case SEARCH : {
                if (resultSet != null) {
                    if (resultSet.isSuccess()) {
                        if (resultSet.getSearchCount() > 0) {
                            setFeedBackMessage(
                                    String.format(MESSAGE_SUCCESS_SEARCH_TYPE_1, resultSet.getSearchCount()));
                        } else {
                            setFeedBackMessage(MESSAGE_SUCCESS_SEARCH_TYPE_2);
                            setFeedBackColor(FEEDBACK_STATUS_ERROR);
                        }
                        setFeedBackColor(FEEDBACK_STATUS_NORMAL);
                    } else {
                        setFeedBackMessage(MESSAGE_FAILURE_SEARCH_TYPE_1);
                        setFeedBackColor(FEEDBACK_STATUS_ERROR);
                    }
                }
                break;
            }
            case JUMP : {
                if (!resultSet.isSuccess()) {
                    if (resultSet.getIndex() == PrimaryUserInterface.TYPE_1) {
                        setFeedBackMessage(MESSAGE_FAILURE_JUMP_TYPE_1);
                    } else {
                        setFeedBackMessage(MESSAGE_FAILURE_JUMP_TYPE_2);
                    }
                    setFeedBackColor(FEEDBACK_STATUS_ERROR);
                }
                break;
            }
            case LINK : {
                if (resultSet != null) {
                    if (resultSet.isSuccess()) {
                        setFeedBackMessage(MESSAGE_SUCCESS_LINK);
                        setFeedBackColor(FEEDBACK_STATUS_NORMAL);
                    } else {
                        if (resultSet.getIndex() == -1) {
                            setFeedBackMessage(MESSAGE_FAILURE_LINK_TYPE_1);
                            setFeedBackColor(FEEDBACK_STATUS_ERROR);
                        } else {
                            setFeedBackMessage(MESSAGE_FAILURE_LINK_TYPE_2);
                            setFeedBackColor(FEEDBACK_STATUS_ERROR);
                        }
                    }
                }
                break;
            }

            case UNDO : {
                if (resultSet != null) {
                    if (resultSet.isSuccess()) {
                        setFeedBackMessage(MESSAGE_SUCCESS_UNDO_TYPE_1);
                        setFeedBackColor(FEEDBACK_STATUS_NORMAL);
                    } else {
                        setFeedBackMessage(MESSAGE_FAILURE_UNDO_TYPE_1);
                        setFeedBackColor(FEEDBACK_STATUS_ERROR);
                    }
                } else {
                    setFeedBackMessage(MESSAGE_FAILURE_UNDO_TYPE_1);
                    setFeedBackColor(FEEDBACK_STATUS_ERROR);
                }
                break;
            }
            case SAVETO : {
                if (resultSet != null) {
                    if (resultSet.isSuccess()) {
                        setFeedBackMessage(MESSAGE_SUCCESS_SAVETO);
                        setFeedBackColor(FEEDBACK_STATUS_NORMAL);
                    } else {
                        setFeedBackMessage(MESSAGE_FAILURE_SAVETO);
                        setFeedBackColor(FEEDBACK_STATUS_ERROR);
                    }
                } else {
                    setFeedBackMessage(MESSAGE_FAILURE_SAVETO);
                    setFeedBackColor(FEEDBACK_STATUS_ERROR);
                }
                break;
            }
            case LOADFROM : {
                if (resultSet != null) {
                    if (resultSet.isSuccess()) {
                        setFeedBackMessage(String.format(MESSAGE_SUCCESS_LOADFROM, msg));
                        setFeedBackColor(FEEDBACK_STATUS_NORMAL);
                    } else {
                        if (resultSet.getStatus() == ResultSet.STATUS_JSON_ERROR) {
                            setFeedBackMessage(MESSAGE_FAILURE_LOADFROM_TYPE_2);
                        } else if (resultSet.getStatus() == ResultSet.STATUS_BAD) {
                            setFeedBackMessage(String.format(MESSAGE_FAILURE_LOADFROM_TYPE_1, msg));
                        } else {
                            setFeedBackMessage(String.format(MESSAGE_FAILURE_LOADFROM_TYPE_1, msg));
                        }
                        setFeedBackColor(FEEDBACK_STATUS_ERROR);
                    }
                } else {
                    setFeedBackMessage(String.format(MESSAGE_FAILURE_LOADFROM_TYPE_1, msg));
                    setFeedBackColor(FEEDBACK_STATUS_ERROR);
                }
                break;
            }
            case THEME : {
                if (resultSet != null) {
                    if (resultSet.isSuccess()) {
                        setFeedBackMessage(MESSAGE_SUCCESS_THEME);
                        setFeedBackColor(FEEDBACK_STATUS_NORMAL);
                    } else {
                        setFeedBackMessage(String.format(MESSAGE_FAILURE_THEME, msg));
                        setFeedBackColor(FEEDBACK_STATUS_ERROR);
                    }
                } else {
                    setFeedBackMessage(String.format(MESSAGE_FAILURE_THEME, msg));
                    setFeedBackColor(FEEDBACK_STATUS_ERROR);
                }
            }
            default :
                break;
        }

    }

    /**
     * Process the feedback color base on the status.
     * 
     * @param status
     * @return condition (conflict, past, conflict and past)
     */
    public String processFeedBackColor(int status) {
        if (status == ResultSet.STATUS_GOOD) {
            setFeedBackColor(FEEDBACK_STATUS_NORMAL);
            return null;
        } else if (status == ResultSet.STATUS_CONFLICT) {
            setFeedBackColor(FEEDBACK_STATUS_CONFLICT);
            return MESSAGE_CONFLICT;
        } else if (status == ResultSet.STATUS_PAST) {
            setFeedBackColor(FEEDBACK_STATUS_PAST);
            return MESSAGE_PAST;
        } else if (status == ResultSet.STATUS_CONFLICT_AND_PAST) {
            setFeedBackColor(FEEDBACK_STATUS_CONFLICT_PAST);
            return MESSAGE_CONFLICT_PAST;
        }
        return null;
    }

    /**
     * Gets the previous command that was executed, builds the labels and place
     * them in the commandbar.
     */
    public void getPrevCommand() {
        int index = _commandSelector - 1;
        if (index < preCommands.size() && index > -1) {
            String preCommand = preCommands.get(index);
            setFullInput(preCommand);
            onKeyReleased();
            _commandSelector = index;
        }
    }

    /**
     * Gets the next command that was executed, builds the labels and place them
     * in the commandbar.
     */
    public void getNextCommand() {
        int index = _commandSelector + 1;
        if (index < preCommands.size() && index > -1) {
            String preCommand = preCommands.get(index);
            setFullInput(preCommand);
            onKeyReleased();
            _commandSelector = index;
        }
    }

    /**
     * Sets the feed back area color base on the feedBackStatus.
     * 
     * @param feedBackStatus
     */
    public void setFeedBackColor(int feedBackStatus) {
        switch (feedBackStatus) {
            case FEEDBACK_STATUS_NORMAL : {
                _feedbackLabel.setId("cssCommandBarfeedback_normal");
                break;
            }
            case FEEDBACK_STATUS_CONFLICT : {
                _feedbackLabel.setId("cssCommandBarfeedback_conflict");
                break;
            }
            case FEEDBACK_STATUS_PAST : {
                _feedbackLabel.setId("cssCommandBarfeedback_past");
                break;
            }
            case FEEDBACK_STATUS_CONFLICT_PAST : {
                _feedbackLabel.setId("cssCommandBarfeedback_conflict_past");
                break;
            }
            case FEEDBACK_STATUS_ERROR : {
                _feedbackLabel.setId("cssCommandBarfeedback_error");
                break;
            }
            default : {
                _feedbackLabel.setId("cssCommandBarfeedback_normal");
                break;
            }
        }
        CommandBarAnimation.start(this);
    }

    /**
     * Reset the feedback to the default color and opacity.
     * 
     * @param feedCounter
     */
    public void resetFeedBack(int feedCounter) {
        _feedBackCounter = feedCounter;
        _feedbackLabel.setOpacity(1.0);
    }

    /**
     * Reduces the opacity of the feedBack component.
     * 
     * @param _percentageDone
     * @param count
     * 
     * @return true only if opacity is 0s
     */
    public boolean updateCommandStatus(double _percentageDone, int count) {
        if (_feedBackCounter == count) {
            double opacity = _feedbackLabel.getOpacity();
            if (opacity < 0) {
                _feedbackLabel.setOpacity(0);
                return true;
            } else {
                _feedbackLabel.setOpacity((1 - _percentageDone));
                return false;
            }
        } else {
            return true;
        }
    }

}
```
###### src\userinterface\CommandBarAnimation.java
``` java
 * 
 *          This is the animation class that provides the service to animate the
 *          fading of the feedback message.
 */
package userinterface;

import javafx.application.Platform;
import javafx.concurrent.Service;
import javafx.concurrent.Task;

public class CommandBarAnimation extends Service<Void> {

    private static final int DELAY_BEFORE_START = 3000;
    private static final int ANIMATE_SPEED_TOTAL = 1000;
    private static final int ANIMATION_DELAY = 33;
    private CommandBar _commandBar;
    private static int count = 0;
    private int individualCount = 0;

    private static CommandBarAnimation _myInstance;

    public static void start(CommandBar commandBar) {
        if (_myInstance != null) {
            while (_myInstance.isRunning()) {
                _myInstance.cancel();
            }
        }
        _myInstance = new CommandBarAnimation(commandBar, ++count);
        _myInstance.start();
    }

    private CommandBarAnimation(CommandBar commandBar, int count) {
        _commandBar = commandBar;
        individualCount = count;
        commandBar.resetFeedBack(individualCount);
    }

    @Override
    protected Task<Void> createTask() {
        return new MyTask();
    }

    private class MyTask extends Task<Void> {
        private double _percentageDone;
        private boolean _isDoneAnimating;

        @Override
        protected Void call() throws Exception {
            _percentageDone = 0;
            _isDoneAnimating = false;
            Thread.sleep(DELAY_BEFORE_START);
            long timeStart = System.currentTimeMillis();
            while (!_isDoneAnimating) {
                long timePast = System.currentTimeMillis() - timeStart;
                _percentageDone = timePast / (double) ANIMATE_SPEED_TOTAL;
                Platform.runLater(new Runnable() {
                    public void run() {
                        _isDoneAnimating = _commandBar.updateCommandStatus(_percentageDone, individualCount);
                        if (_percentageDone > 1) {
                            _isDoneAnimating = true;
                        }
                    }
                });
                Thread.sleep(ANIMATION_DELAY);
            }
            return null;
        }
    }

}
```
###### src\userinterface\DescriptionComponent.java
``` java
 * 
 *          This class builds the components on the left panel.
 */
package userinterface;

import java.util.ArrayList;

import javafx.event.EventHandler;
import javafx.geometry.Pos;
import javafx.geometry.Rectangle2D;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.paint.CycleMethod;
import javafx.scene.paint.LinearGradient;
import javafx.scene.paint.Stop;
import javafx.scene.shape.Rectangle;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import javafx.stage.Window;
import userinterface.DescriptionLabel;

public class DescriptionComponent implements ViewInterface {

    static final int CONPONENT_WIDTH = 50;
    static final int CONPONENT_RIGHT_MARGIN = 0;
    private static final int POSITION_ZERO = 0;
    private static final String CSS_LABEL = "cssLabelsDescription";

    private static DescriptionComponent _myInstance;
    private String _styleSheet;

    private final double LABEL_SIZE_LARGE = 200;
    private final double LABEL_SIZE_MEDIUM = 100;

    private Stage _stage;
    private int _stageWidth;
    private int _stageHeight;
    private int _windowPosX;
    private int _windowPosY;

    private GridPane _mainVbox;
    private double _translationY = 0;
    private int _currentView;

    /**
     * Create an instance of DescriptionComponent.
     * 
     * @param parentStage
     * @param screenBounds
     * @param isFixedSize
     * @param styleSheet
     * @param mouseEvent
     * @return Instance of DescriptionComponent only if there isn't an instance
     *         already.
     */
    public static DescriptionComponent getInstance(Stage parentStage, Rectangle2D screenBounds,
            boolean isFixedSize, String styleSheet, EventHandler<MouseEvent> mouseEvent) {
        if (_myInstance == null) {
            _myInstance = new DescriptionComponent(parentStage, screenBounds, isFixedSize, styleSheet,
                    mouseEvent);
            return _myInstance;
        }
        return null;
    }

    private DescriptionComponent(Stage parentStage, Rectangle2D screenBounds, boolean isfixedSize,
            String styleSheet, EventHandler<MouseEvent> mouseEvent) {
        _styleSheet = styleSheet;
        initializeVaribles(screenBounds, isfixedSize);
        initializeStage(parentStage, _windowPosX, _windowPosY, _stageWidth, _stageHeight, mouseEvent);
    }

    /**
     * Initialize view dimensions and position.
     */
    public void initializeVaribles(Rectangle2D screenBounds, boolean isFixedSize) {
        if (isFixedSize) {
            _stageWidth = CONPONENT_WIDTH;
            _stageHeight = (int) (screenBounds.getHeight() - PrimaryUserInterface.COMMAND_BAR_HEIGTH
                    - PrimaryUserInterface.COMMAND_BAR_BOTTOM_MARGIN
                    - PrimaryUserInterface.COMMAND_BAR_TOP_MARGIN
                    - FloatingBarViewUserInterface.COMPONENT_HEIGHT
                    - FloatingBarViewUserInterface.COMPONENT_BOTTOM_MARGIN);
            _windowPosX = POSITION_ZERO;
            _windowPosY = (int) screenBounds.getHeight() - _stageHeight
                    - PrimaryUserInterface.COMMAND_BAR_HEIGTH - PrimaryUserInterface.COMMAND_BAR_TOP_MARGIN
                    - PrimaryUserInterface.COMMAND_BAR_BOTTOM_MARGIN;
        } else {
            _stageWidth = CONPONENT_WIDTH;
            _stageHeight = (int) (screenBounds.getHeight() - PrimaryUserInterface.COMMAND_BAR_HEIGTH
                    - PrimaryUserInterface.COMMAND_BAR_TOP_MARGIN
                    - PrimaryUserInterface.COMMAND_BAR_BOTTOM_MARGIN
                    - FloatingBarViewUserInterface.COMPONENT_HEIGHT
                    - FloatingBarViewUserInterface.COMPONENT_TOP_MARGIN
                    - FloatingBarViewUserInterface.COMPONENT_BOTTOM_MARGIN);
            _windowPosX = (int) (screenBounds.getWidth()
                    - (screenBounds.getWidth() * PrimaryUserInterface.PREFERED_WINDOW_SCALE)) / 2;
            _windowPosY = (int) screenBounds.getHeight() - _stageHeight
                    - PrimaryUserInterface.COMMAND_BAR_HEIGTH - PrimaryUserInterface.COMMAND_BAR_TOP_MARGIN
                    - PrimaryUserInterface.COMMAND_BAR_BOTTOM_MARGIN;
        }
    }

    /**
     * Initialize the stage and the components in the stage.
     */
    public void initializeStage(Window owner, int applicationX, int applicationY, int windowWidth,
            int windowHeight, EventHandler<MouseEvent> mouseEvent) {
        _stage = new Stage();
        _stage.initOwner(owner);
        _stage.initStyle(StageStyle.TRANSPARENT);
        _stage.setX(applicationX);
        _stage.setY(applicationY);

        StackPane mainPanel = new StackPane();
        mainPanel.setId("cssRootDescriptionViewMainBackground");
        mainPanel.setPrefSize(_stageWidth, _stageHeight);
        mainPanel.setAlignment(Pos.TOP_RIGHT);

        _mainVbox = new GridPane();
        mainPanel.getChildren().add(_mainVbox);
        Scene scene = new Scene(mainPanel, windowWidth, windowHeight, Color.TRANSPARENT);
        scene.getStylesheets().add(_styleSheet);
        scene.setOnMousePressed(mouseEvent);

        _stage.setScene(scene);
    }

    /**
     * Rebuilds the component with a list of DescriptionLabels.
     * 
     * @param descriptionLabels
     * @param view
     */
    public void buildComponent(ArrayList<DescriptionLabel> descriptionLabels, int view) {
        _currentView = view;
        _mainVbox.getChildren().clear();
        double totalBuildedHeight = 0;
        if (descriptionLabels != null) {
            for (int i = 0; i < descriptionLabels.size(); i++) {
                _mainVbox.add(buildIndividualLabel(descriptionLabels.get(i), totalBuildedHeight), 0, i);
                totalBuildedHeight += descriptionLabels.get(i).getHeight();
            }
        }
    }

    /**
     * Builds the individual label.
     * (returns a stackPane because, before it has a Rectangle background.
     * Rectangle is unused.)
     * 
     * @param dLabel
     * @param totalBuildedHeight
     * @return StackPane
     */
    public StackPane buildIndividualLabel(DescriptionLabel dLabel, double totalBuildedHeight) {
        StackPane s = new StackPane();
        s.setMinHeight(dLabel.getHeight());
        s.setMinWidth(CONPONENT_WIDTH);
        VBox labelBox = buildLabel(dLabel, totalBuildedHeight, dLabel.isSelected());
        s.getChildren().add(labelBox);
        return s;
    }

    public VBox buildLabel(DescriptionLabel dLabel, double totalBuildedHeight, boolean isSelected) {
        VBox vbox = new VBox();
        if (isSelected) {
            vbox.setId("cssDescriptionLabelSelected");
        } else {
            vbox.setId("cssDescriptionLabelUnSelected");
        }
        vbox.setMinHeight(dLabel.getHeight());
        vbox.setMinWidth(CONPONENT_WIDTH);
        double posYStart = _translationY + totalBuildedHeight;
        double posYEnd = posYStart + dLabel.getHeight();
        createLabelBaseOnHeight(posYStart, posYEnd, vbox, dLabel);
        return vbox;
    }

```
###### src\userinterface\DescriptionComponent.java
``` java
    /**
     * Creates the label base on the height and position.
     * 
     * @param posYStart
     * @param posYEnd
     * @param vbox
     * @param dLabel
     */
    public void createLabelBaseOnHeight(double posYStart, double posYEnd, VBox vbox,
            DescriptionLabel dLabel) {
        Label main = new Label();
        main.getStyleClass().add(CSS_LABEL);
        Label extra = new Label();
        if ((posYStart >= 0 && posYStart < _stageHeight) || (posYEnd <= _stageHeight && posYEnd > 0)) {
            // partially or fully inside screen
            if (posYStart >= 0 && posYEnd <= _stageHeight) {
                // fully in screen
                main.setMinHeight(posYEnd - posYStart);
                vbox.getChildren().add(buildLabelBaseOnHeight(main, dLabel, posYEnd - posYStart));
            } else if (posYStart < 0) {
                // tail in screen only
                extra.setMinHeight(-posYStart);
                vbox.getChildren().add(extra);
                main.setMinHeight(posYEnd);
                vbox.getChildren().add(buildLabelBaseOnHeight(main, dLabel, posYEnd));
            } else if (posYStart >= 0) {
                // head in screen only
                main.setMinHeight(_stageHeight - posYStart);
                vbox.getChildren().add(buildLabelBaseOnHeight(main, dLabel, _stageHeight - posYStart));
                extra.setMinHeight(posYEnd - _stageHeight);
                vbox.getChildren().add(extra);
            }
        } else if (posYStart <= 0 && posYEnd >= _stageHeight) {
            // body in screen, head or tail or head and tail not in screen
            Label tempLabel = new Label();
            tempLabel.setMinHeight(-posYStart);
            vbox.getChildren().add(tempLabel);
            main.setMinHeight(_stageHeight);
            vbox.getChildren().add(buildLabelBaseOnHeight(main, dLabel, _stageHeight));
            extra.setMinHeight(posYEnd - _stageHeight);
            vbox.getChildren().add(extra);
        }
    }

    public Label buildLabelBaseOnHeight(Label label, DescriptionLabel dLabel, double height) {
        if (_currentView == UserInterfaceController.TASK_VIEW) {
            return setLabelForTaskView(label, dLabel, height);
        } else {
            return setLabelForDetailedView(label, dLabel, height);
        }
    }

    private Label setLabelForDetailedView(Label label, DescriptionLabel dLabel, double height) {
        if (height > LABEL_SIZE_MEDIUM) {
            label.setMinHeight(CONPONENT_WIDTH);
            label.setMinWidth(height);
            label.setRotate(270);
            double translationX = -(height / 2) + CONPONENT_WIDTH / 2;
            double translationY = (height / 2) - CONPONENT_WIDTH / 2;
            label.setTranslateX(translationX);
            label.setTranslateY(translationY);
            if (height > LABEL_SIZE_LARGE) {
                label.setText(dLabel.getFullDayLabel());
            } else {
                label.setText(dLabel.getMediumDayLabel());
            }
        } else if (height <= LABEL_SIZE_MEDIUM) {
            label.setText(dLabel.getSmallDayLabel());
            label.setMinWidth(CONPONENT_WIDTH);
        }
        label.setAlignment(Pos.CENTER);
        return label;
    }

    private Label setLabelForTaskView(Label label, DescriptionLabel dLabel, double height) {
        if (height > LABEL_SIZE_MEDIUM) {
            label.setMinHeight(CONPONENT_WIDTH);
            label.setMinWidth(height);
            label.setRotate(270);
            double translationX = -(height / 2) + CONPONENT_WIDTH / 2;
            double translationY = (height / 2) - CONPONENT_WIDTH / 2;
            label.setTranslateX(translationX);
            label.setTranslateY(translationY);
            if (height > LABEL_SIZE_LARGE) {
                label.setText(dLabel.getFullWeekLabel());
            } else {
                label.setText(dLabel.getMediumWeekLabel());
            }
        } else if (height <= LABEL_SIZE_MEDIUM) {
            label.setText(dLabel.getSmallWeekLabel());
            label.setMinWidth(CONPONENT_WIDTH);
        }
        label.setAlignment(Pos.CENTER);
        return label;
    }

    public void updateTranslateY(double value) {
        _translationY = value;
        _mainVbox.setTranslateY(value);
    }

    public void show() {
        _stage.show();
    }

    public void hide() {
        _stage.hide();
    }

    public GridPane getMainVBox() {
        return _mainVbox;
    }

    public void update(int value) {
    }

    public void destoryStage() {
        _myInstance = null;
        _stage.close();
    }

    public void changeTheme(String styleSheet) {
        _stage.getScene().getStylesheets().clear();
        _styleSheet = styleSheet;
        _stage.getScene().getStylesheets().add(styleSheet);
    }

}
```
###### src\userinterface\DetailComponent.java
``` java
 * 
 *          This class controls the items in the detail view.
 */
package userinterface;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import entity.TaskEntity;
import javafx.event.EventHandler;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.geometry.Rectangle2D;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Text;
import javafx.scene.text.TextAlignment;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import javafx.stage.Window;
import parser.ParserCommons;

public class DetailComponent implements ViewInterface {

    static final int COMPONENT_WIDTH = 300;
    static final int COMPONENT_LEFT_MARGIN = 2;

    private static final int TASK_VIEW = 1;
    private static final int EXPANDED_VIEW = 2;
    private static final int ASSOCIATE_VIEW = 3;
    private static final int TOTAL_VIEWS = 3;

    private static final int SPACING_SIZE = 10;
    private static final int ITEM_MARGIN = 4;

    private static final String LABEL_MESSAGE_NO_TASK = "This task has no associations.";
    private static final int LABEL_PROJECTHEAD_HEIGHT = 30;
    private static final int LABEL_TASK_HEIGHT = 25;
    private static final int LEFT_RIGHT_MARGIN_INDIVIDUAL_ITEMS = 20;
    private static final int BOTTOM_MARGIN_INDIVIDUAL_ITEMS = 10;

    private static DetailComponent _myInstance;
    private static final String CSS_LABEL = "cssLabelsDetails";

    private String _styleSheet;

    private Stage _stage;
    private int _stageWidth;
    private int _stageHeight;
    private int _windowPosX;
    private int _windowPosY;

    private VBox[] _mainVbox;
    private Scene[] _scenes;
    private int _currentSelectView;
    private int _selectedIndex;
    private int _individualItemWidth;

    private boolean _haveAssociation;
    private TaskEntity _targetedTask;

    /**
     * Create an instance of DetailComponent.
     * 
     * @param primaryStage
     * @param screenBounds
     * @param isFixedSize
     * @param styleSheet
     * @param mouseEvent
     * @return Instance of DetailComponent only if there isn't an instance
     *         already.
     */
    public static DetailComponent getInstance(Stage parentStage, Rectangle2D screenBounds,
            boolean isFixedSize, String styleSheet, EventHandler<MouseEvent> mouseEvent) {
        if (_myInstance == null) {
            _myInstance = new DetailComponent(parentStage, screenBounds, isFixedSize, styleSheet, mouseEvent);
            return _myInstance;
        }
        return null;
    }

    private DetailComponent(Stage parentStage, Rectangle2D screenBounds, boolean isFixedSize,
            String styleSheet, EventHandler<MouseEvent> mouseEvent) {
        _currentSelectView = TASK_VIEW;
        _styleSheet = styleSheet;
        initializeVaribles(screenBounds, isFixedSize);
        initializeScenes(mouseEvent);
        initializeStage(parentStage, _windowPosX, _windowPosY, _stageWidth, _stageHeight, mouseEvent);
    }

    private void initializeScenes(EventHandler<MouseEvent> mouseEvent) {
        _scenes = new Scene[TOTAL_VIEWS];
        _mainVbox = new VBox[TOTAL_VIEWS];
        for (int i = 0; i < TOTAL_VIEWS; i++) {
            _mainVbox[i] = new VBox();
            _mainVbox[i].setMinSize(_stageWidth, _stageHeight);
            _mainVbox[i].setId("cssDetailComponentRoot");
            _scenes[i] = new Scene(_mainVbox[i], _stageWidth, _stageHeight);
            _scenes[i].setFill(Color.TRANSPARENT);
            _scenes[i].getStylesheets().add(_styleSheet);
            _scenes[i].setOnMousePressed(mouseEvent);
        }
    }

    /**
     * Initialize view dimensions and position.
     */
    public void initializeVaribles(Rectangle2D screenBounds, boolean fixedSize) {
        if (fixedSize) {
            _stageWidth = COMPONENT_WIDTH;
            _stageHeight = (int) (screenBounds.getHeight() - PrimaryUserInterface.COMMAND_BAR_HEIGTH
                    - PrimaryUserInterface.COMMAND_BAR_BOTTOM_MARGIN
                    - PrimaryUserInterface.COMMAND_BAR_TOP_MARGIN
                    - FloatingBarViewUserInterface.COMPONENT_HEIGHT
                    - FloatingBarViewUserInterface.COMPONENT_BOTTOM_MARGIN);
            _windowPosX = (int) (screenBounds.getWidth() - COMPONENT_WIDTH);
            _windowPosY = (int) screenBounds.getHeight() - _stageHeight
                    - PrimaryUserInterface.COMMAND_BAR_HEIGTH - PrimaryUserInterface.COMMAND_BAR_TOP_MARGIN
                    - PrimaryUserInterface.COMMAND_BAR_BOTTOM_MARGIN;
        } else {
            _stageWidth = COMPONENT_WIDTH;
            _stageHeight = (int) (screenBounds.getHeight() - PrimaryUserInterface.COMMAND_BAR_HEIGTH
                    - PrimaryUserInterface.COMMAND_BAR_TOP_MARGIN
                    - PrimaryUserInterface.COMMAND_BAR_BOTTOM_MARGIN
                    - FloatingBarViewUserInterface.COMPONENT_HEIGHT
                    - FloatingBarViewUserInterface.COMPONENT_TOP_MARGIN
                    - FloatingBarViewUserInterface.COMPONENT_BOTTOM_MARGIN);
            _windowPosX = (int) ((screenBounds.getWidth()
                    - (screenBounds.getWidth() * PrimaryUserInterface.PREFERED_WINDOW_SCALE)) / 2
                    + (screenBounds.getWidth() * PrimaryUserInterface.PREFERED_WINDOW_SCALE)
                    - COMPONENT_WIDTH);
            _windowPosY = (int) screenBounds.getHeight() - _stageHeight
                    - PrimaryUserInterface.COMMAND_BAR_HEIGTH - PrimaryUserInterface.COMMAND_BAR_TOP_MARGIN
                    - PrimaryUserInterface.COMMAND_BAR_BOTTOM_MARGIN;
        }
        _individualItemWidth = _stageWidth - ITEM_MARGIN;
    }

    /**
     * Initialize the stage and the components in the stage.
     */
    public void initializeStage(Window owner, int applicationX, int applicationY, int windowWidth,
            int windowHeight, EventHandler<MouseEvent> mouseEvent) {
        _stage = new Stage();
        _stage.initOwner(owner);
        _stage.initStyle(StageStyle.TRANSPARENT);
        _stage.setX(applicationX);
        _stage.setY(applicationY);
        _stage.setScene(_scenes[_currentSelectView]);
    }

    /**
     * Builds the component base on the selectedView.
     * 
     * @param task
     */
    public void buildComponent(TaskEntity task) {
        if (_currentSelectView == TASK_VIEW) {
            buildUIForTaskView(task);
        } else if (_currentSelectView == EXPANDED_VIEW || _currentSelectView == ASSOCIATE_VIEW) {
            _selectedIndex = 0;
            buildUIForExpandedView(task);
        }
    }

    public void setView(int view) {
        _currentSelectView = view;
        if (_currentSelectView == ASSOCIATE_VIEW) {
            _stage.setScene(_scenes[EXPANDED_VIEW]);
            _mainVbox[EXPANDED_VIEW].setId("cssDetailComponentRootAssociation");
        } else {
            _stage.setScene(_scenes[_currentSelectView]);
            _mainVbox[EXPANDED_VIEW].setId("cssDetailComponentRoot");
        }
    }

    public void buildUIForTaskView(TaskEntity task) {
        _mainVbox[TASK_VIEW].getChildren().clear();
        if (task != null) {
            VBox childToAdd = buildTaskForTaskView(task);
            _mainVbox[TASK_VIEW].getChildren().add(childToAdd);
        }
    }

    public void buildUIForExpandedView(TaskEntity task) {
        _targetedTask = task;
        _mainVbox[EXPANDED_VIEW].getChildren().clear();
        if (task != null) {
            VBox childToAdd = buildAssociationList(task);
            _mainVbox[EXPANDED_VIEW].getChildren().add(childToAdd);
        }
    }

    public VBox buildAssociationList(TaskEntity task) {
        VBox box = new VBox();
        box.setSpacing(SPACING_SIZE);
        box.setMinWidth(_stageWidth);
        box.setMaxHeight(0);
        box.setAlignment(Pos.CENTER);
        box.setId("cssDetailAssociationListBox");

        ArrayList<TaskEntity> association = task.getDisplayAssociations();

        if (association != null) {
            if (association.size() == 0) {
                box.getChildren().add(buildEmptyLabel());
                _haveAssociation = false;
            } else {
                VBox projectHeadToAdd = buildProjectHead(association.get(0));
                box.getChildren().add(projectHeadToAdd);
                for (int i = 1; i < association.size(); i++) {
                    VBox taskToAdd = buildTaskCollapse(association.get(i));
                    box.getChildren().add(taskToAdd);
                }
                _haveAssociation = true;
                _selectedIndex = task.getAssociationPosition();
            }
        }
        return box;
    }

    /**
     * Sets the selectedIndex, used when in ASSOCIATE_VIEW. Remove the
     * description component in the previous selected item and add the
     * description component in the selected component.
     * 
     * 
     * @param index
     */
    public void setSelectedIndex(int index) {
        if (isValidIndex(index)) {
            VBox parent = (VBox) _mainVbox[EXPANDED_VIEW].getChildren().get(0);
            if (_selectedIndex != -1) {
                VBox prev = (VBox) parent.getChildren().get(_selectedIndex);
                prev.setId("cssExpandedViewVBox");
                if (_selectedIndex != 0) {
                    removeDescription(prev);
                }
            }

            VBox curr = (VBox) parent.getChildren().get(index);
            curr.setId("cssExpandedViewVBoxSelected");
            if (index != 0) {
                addDescription(curr, index);
            }
            _selectedIndex = index;

            if (parent.getHeight() > _stageHeight) {
                double sizeOnTop = 0;
                for (int i = 0; i <= index; i++) {
                    VBox tempVBox = (VBox) parent.getChildren().get(i);
                    sizeOnTop += tempVBox.getHeight() + SPACING_SIZE;
                }

                double posY = 0;
                if (sizeOnTop > _stageHeight) {
                    posY = sizeOnTop - _stageHeight;
                }
                parent.setTranslateY(-posY);
            }
        }
    }

    /**
     * Checks if the index is valid.
     * 
     * @param index
     * @return true only if the index is valid
     */
    public boolean isValidIndex(int index) {
        if (!_haveAssociation) {
            return false;
        }
        if (index < 0) {
            return false;
        }
        if (_mainVbox[EXPANDED_VIEW].getChildren().size() < 0) {
            return false;
        }
        VBox child = (VBox) _mainVbox[EXPANDED_VIEW].getChildren().get(0);
        if (child.getChildren().size() > index) {
            return true;
        }
        return false;
    }

    /**
     * Build the label to indicate if there are no task.
     * 
     * @return Label
     */
    public Label buildEmptyLabel() {
        Label label = new Label(LABEL_MESSAGE_NO_TASK);
        label.getStyleClass().add(CSS_LABEL);
        label.setMinWidth(_stageWidth);
        label.setId("cssDetailComponentEmptyTitle");
        label.setAlignment(Pos.CENTER);
        return label;
    }

    /**
     * Removes the description component in the component.
     * 
     * @param curr
     */
    private void removeDescription(VBox curr) {
        int indexToRemove = curr.getChildren().size() - 1;
        curr.getChildren().remove(indexToRemove);
    }

    /**
     * Adds the description component in the selected item.
     * 
     * @param curr
     */
    private void addDescription(VBox curr, int index) {
        if (_targetedTask.getDisplayAssociations().size() < index || index < 0) {
            return;
        }
        TaskEntity task = _targetedTask.getDisplayAssociations().get(index);
        Text description = new Text(task.getDescription());
        description.getStyleClass().add(CSS_LABEL);
        description.setWrappingWidth(_individualItemWidth - LEFT_RIGHT_MARGIN_INDIVIDUAL_ITEMS * 2);
        description.setTextAlignment(TextAlignment.JUSTIFY);
        VBox.setMargin(description, new Insets(0, LEFT_RIGHT_MARGIN_INDIVIDUAL_ITEMS,
                BOTTOM_MARGIN_INDIVIDUAL_ITEMS, LEFT_RIGHT_MARGIN_INDIVIDUAL_ITEMS));
        curr.getChildren().add(description);
    }

    public VBox buildTaskForTaskView(TaskEntity task) {
        VBox itemMain = new VBox();
        itemMain.setSpacing(10);
        itemMain.setMinWidth(_stageWidth);
        itemMain.setId("cssExpandedViewVBox");

        Label titleLabel = new Label(task.getName());
        titleLabel.getStyleClass().add(CSS_LABEL);
        titleLabel.setId("cssDetailComponentEmptyTitle");
        titleLabel.setMinWidth(_stageWidth);
        titleLabel.setMinHeight(LABEL_PROJECTHEAD_HEIGHT);
        titleLabel.setAlignment(Pos.CENTER);
        itemMain.getChildren().add(titleLabel);

        itemMain.getChildren().add(buildComponentToShowDate(task));

        String description = task.getDescription();
        if (!description.equals("")) {
            Text descriptionLabel = new Text(task.getDescription());
            descriptionLabel.getStyleClass().add(CSS_LABEL);
            descriptionLabel.setWrappingWidth(_individualItemWidth - LEFT_RIGHT_MARGIN_INDIVIDUAL_ITEMS * 2);
            descriptionLabel.setTextAlignment(TextAlignment.JUSTIFY);
            itemMain.getChildren().add(descriptionLabel);
            itemMain.setMaxHeight(itemMain.getMaxHeight() + descriptionLabel.getBoundsInLocal().getHeight());
            VBox.setMargin(descriptionLabel,
                    new Insets(0, LEFT_RIGHT_MARGIN_INDIVIDUAL_ITEMS, 0, LEFT_RIGHT_MARGIN_INDIVIDUAL_ITEMS));
        }

        String hash = task.getHashtags();
        if (!hash.equals("")) {
            Text hashtag = new Text(task.getHashtags());
            hashtag.getStyleClass().add(CSS_LABEL);
            hashtag.setWrappingWidth(_individualItemWidth - LEFT_RIGHT_MARGIN_INDIVIDUAL_ITEMS * 2);
            hashtag.setTextAlignment(TextAlignment.JUSTIFY);
            itemMain.getChildren().add(hashtag);
            VBox.setMargin(hashtag, new Insets(0, LEFT_RIGHT_MARGIN_INDIVIDUAL_ITEMS,
                    BOTTOM_MARGIN_INDIVIDUAL_ITEMS, LEFT_RIGHT_MARGIN_INDIVIDUAL_ITEMS));
        }

        return itemMain;
    }

    /**
     * Get the date string in a readable form.
     * 
     * @param calendar
     * @return date string
     */
    private String getStringOfDate(Calendar calendar) {
        return ParserCommons.detailedDateTime((Calendar) calendar.clone());
    }

    public VBox buildComponentToShowDate(TaskEntity task) {
        VBox dateBox = new VBox();
        dateBox.setMinHeight(0.0);
        if (task.isFullDay()) {
            Label dateTitleLabel = new Label("Full Day : " + getFullDate(task.getDueDate()));
            dateTitleLabel.setMinHeight(LABEL_TASK_HEIGHT);
            dateTitleLabel.getStyleClass().add(CSS_LABEL);
            dateBox.getChildren().add(dateTitleLabel);
            dateBox.setMinHeight(dateBox.getMinHeight() + LABEL_TASK_HEIGHT);
        } else {

            if (task.getStartDate() != null) {
                Label dateTitleLabelStart = new Label("Start Date : " + getStringOfDate(task.getStartDate()));
                dateTitleLabelStart.setMinHeight(LABEL_TASK_HEIGHT);
                dateTitleLabelStart.getStyleClass().add(CSS_LABEL);
                dateBox.getChildren().add(dateTitleLabelStart);
                dateBox.setMinHeight(dateBox.getMinHeight() + LABEL_TASK_HEIGHT);
            }

            if (task.getDueDate() != null) {
                Label dateTitleLabel = new Label("End Date : " + getStringOfDate(task.getDueDate()));
                dateTitleLabel.setMinHeight(LABEL_TASK_HEIGHT);
                dateTitleLabel.getStyleClass().add(CSS_LABEL);
                dateBox.getChildren().add(dateTitleLabel);
                dateBox.setMinHeight(dateBox.getMinHeight() + LABEL_TASK_HEIGHT);
            }
        }

        VBox.setMargin(dateBox, new Insets(0, 20, 0, 20));
        return dateBox;
    }

    public VBox buildProjectHead(TaskEntity task) {
        VBox itemMain = new VBox();
        itemMain.setSpacing(10);
        itemMain.setMinWidth(_stageWidth);
        itemMain.setId("cssExpandedViewVBox");

        Label titleLabel = new Label(task.getName());
        titleLabel.getStyleClass().add(CSS_LABEL);
        titleLabel.setId("cssDetailComponentEmptyTitle");
        titleLabel.setMinWidth(_stageWidth);
        titleLabel.setMinHeight(LABEL_PROJECTHEAD_HEIGHT);
        titleLabel.setAlignment(Pos.CENTER);
        itemMain.getChildren().add(titleLabel);
        itemMain.setMaxHeight(LABEL_PROJECTHEAD_HEIGHT);

        VBox dateBox = buildComponentToShowDate(task);
        VBox.setMargin(dateBox, new Insets(0, 20, 0, 20));
        itemMain.getChildren().add(dateBox);
        itemMain.setMaxHeight(itemMain.getMaxHeight() + dateBox.getMinHeight());

        String description = task.getDescription();
        if (!description.equals("")) {
            Text descriptionLabel = new Text(task.getDescription());
            descriptionLabel.getStyleClass().add(CSS_LABEL);
            descriptionLabel.setWrappingWidth(_individualItemWidth - LEFT_RIGHT_MARGIN_INDIVIDUAL_ITEMS * 2);
            descriptionLabel.setTextAlignment(TextAlignment.JUSTIFY);
            itemMain.getChildren().add(descriptionLabel);
            itemMain.setMaxHeight(itemMain.getMaxHeight() + descriptionLabel.getBoundsInLocal().getHeight());
            VBox.setMargin(descriptionLabel, new Insets(0, LEFT_RIGHT_MARGIN_INDIVIDUAL_ITEMS,
                    BOTTOM_MARGIN_INDIVIDUAL_ITEMS, LEFT_RIGHT_MARGIN_INDIVIDUAL_ITEMS));
        }

        String hash = task.getHashtags();
        if (!hash.equals("")) {
            Text hashtag = new Text(task.getHashtags());
            hashtag.getStyleClass().add(CSS_LABEL);
            hashtag.setWrappingWidth(_individualItemWidth - LEFT_RIGHT_MARGIN_INDIVIDUAL_ITEMS * 2);
            hashtag.setTextAlignment(TextAlignment.JUSTIFY);
            itemMain.getChildren().add(hashtag);
            VBox.setMargin(hashtag, new Insets(0, LEFT_RIGHT_MARGIN_INDIVIDUAL_ITEMS,
                    BOTTOM_MARGIN_INDIVIDUAL_ITEMS, LEFT_RIGHT_MARGIN_INDIVIDUAL_ITEMS));
        }

        return itemMain;
    }

    public VBox buildTaskCollapse(TaskEntity task) {
        VBox itemMain = new VBox();
        itemMain.setMinWidth(_individualItemWidth);
        VBox.setMargin(itemMain, new Insets(0, 2, 0, 2));
        itemMain.setId("cssExpandedViewVBox");

        HBox dateBox = new HBox();
        dateBox.setId("cssDetailComponentTask");
        dateBox.setMinWidth(_individualItemWidth);
        dateBox.setMinHeight(LABEL_TASK_HEIGHT);
        dateBox.setAlignment(Pos.CENTER_LEFT);

        Label dateLabel = new Label();
        dateLabel.setText(getDate(task.getDueDate()));
        dateLabel.getStyleClass().add(CSS_LABEL);
        dateBox.getChildren().add(dateLabel);
        dateBox.setMinHeight(LABEL_TASK_HEIGHT);

        Label titleLabel = new Label(task.getName());
        titleLabel.getStyleClass().add(CSS_LABEL);
        titleLabel.setMinHeight(LABEL_TASK_HEIGHT);
        HBox.setMargin(titleLabel, new Insets(0, 0, 0, 5));
        dateBox.getChildren().add(titleLabel);

        VBox.setMargin(dateBox, new Insets(0, 20, 0, 20));
        itemMain.getChildren().add(dateBox);

        Text description = new Text();
        itemMain.getChildren().add(description);
        return itemMain;
    }

    /**
     * Adds child into parent component and increase parent MaxSize.
     * 
     * @param child
     * @param parent
     */
    public void addChildToParent(VBox child, VBox parent) {
        parent.getChildren().add(child);
        parent.setPrefHeight(parent.getMaxHeight() + child.getMaxHeight());
        parent.setMinHeight(parent.getMaxHeight() + child.getMaxHeight());
        parent.setMaxHeight(parent.getMaxHeight() + child.getMaxHeight());
    }

    public String getDate(Calendar cal) {
        String date = "";
        SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/YY hhmm");
        date = sdf.format(cal.getTime()).concat("hrs");
        return date;
    }

    public String getFullDate(Calendar cal) {
        String date = "";
        SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/YY");
        date = sdf.format(cal.getTime());
        return date;
    }

    public void update(int value) {
        int index = value + _selectedIndex;
        setSelectedIndex(index);
    }

    public void updateTranslateY(double posY) {

    }

    public void show() {
        _stage.show();
    }

    public void hide() {
        _stage.hide();
    }

    public void destoryStage() {
        _myInstance = null;
        _stage.close();
    }

    public void changeTheme(String styleSheet) {
        _styleSheet = styleSheet;
        for (int i = 0; i < TOTAL_VIEWS; i++) {
            _scenes[i].getStylesheets().clear();
            _scenes[i].getStylesheets().add(styleSheet);
        }
    }

    /**
     * Process the enter command.
     * 
     * @return the selected task.
     */
    public TaskEntity processEnter() {
        if (_currentSelectView == ASSOCIATE_VIEW) {
            if (_targetedTask != null) {
                if (_targetedTask.getAssociationState() == TaskEntity.PROJECT_HEAD) {
                    if (_selectedIndex - 1 > -1
                            && _selectedIndex - 1 < _targetedTask.getAssociations().size()) {
                        return _targetedTask.getAssociations().get(_selectedIndex - 1);
                    }
                } else {
                    TaskEntity pHead = _targetedTask.getProjectHead();
                    if (_selectedIndex - 1 > -1 && _selectedIndex - 1 < pHead.getAssociations().size()) {
                        return pHead.getAssociations().get(_selectedIndex - 1);
                    } else if (_selectedIndex == 0) {
                        return pHead;
                    }
                }
            }
        }
        return null;
    }

}
```
###### src\userinterface\FloatingBarAnimationThread.java
``` java
 * 
 *          This is the animation class that provides the service to animate the
 *          movement of the items in the floating bar.
 */
package userinterface;

import javafx.application.Platform;
import javafx.concurrent.Service;
import javafx.concurrent.Task;

public class FloatingBarAnimationThread extends Service<Void> {

    private UserInterfaceController _ui;
    private boolean _isAdded;
    private boolean _isDoneAnimating;
    private static final int ANIMATE_SPEED_TOTAL = 1500;
    private static final int ANIMATION_DELAY = 10;
    private static final int TIME_INTERVAL_FOR_NEXT_FLOATING_TASK = 10000;

    private double _percentageDone;

    public FloatingBarAnimationThread(UserInterfaceController userInterfaceController) {
        _ui = userInterfaceController;
        _percentageDone = 0;
    }

    public void reset() {
        _isAdded = false;
        _isDoneAnimating = false;
        _percentageDone = 0.0;
    }

    @Override
    protected Task<Void> createTask() {
        return new MyTask();
    }

    private class MyTask extends Task<Void> {

        @Override
        protected Void call() throws Exception {
            while (true) {
                Thread.sleep(TIME_INTERVAL_FOR_NEXT_FLOATING_TASK);
                reset();
                long timeStart = System.currentTimeMillis();
                while (!_isDoneAnimating) {
                    long timePast = System.currentTimeMillis() - timeStart;
                    _percentageDone = timePast / (double) ANIMATE_SPEED_TOTAL;
                    Platform.runLater(new Runnable() {
                        public void run() {
                            if (!_isAdded) {
                                _ui.addRandomTaskToDisplay();
                                _isAdded = true;
                            }
                            _isDoneAnimating = _ui.updateFloatingBar(_percentageDone);
                            if (_percentageDone > 1) {
                                _isDoneAnimating = true;
                            }
                        }
                    });
                    Thread.sleep(ANIMATION_DELAY);
                }
            }
        }

    }
}
```
###### src\userinterface\FloatingBarViewUserInterface.java
``` java
 * 
 *          This class builds the components and structure on the top.
 */
package userinterface;

import javafx.event.EventHandler;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.geometry.Rectangle2D;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import javafx.stage.Window;

public class FloatingBarViewUserInterface implements ViewInterface {

    static final int COMPONENT_HEIGHT = 50;
    static final int COMPONENT_TOP_MARGIN = 50;
    static final int COMPONENT_BOTTOM_MARGIN = 2;
    private static final int POSITION_ZERO = 0;
    private static final int LEFT_MARGIN = 10;

    private static final int LABEL_TITLE_WIDTH = 250;
    private static final int FONT_SIZE_TITLE_LABEL = 20;
    private static final int FONT_SIZE_TASK = 16;
    private static final Font FONT_LABEL_TITLE = new Font(PrimaryUserInterface.FONT_DEFAULT,
            FONT_SIZE_TITLE_LABEL);
    private static final Font FONT_LABEL_TASK = new Font(PrimaryUserInterface.FONT_DEFAULT, FONT_SIZE_TASK);

    private static FloatingBarViewUserInterface _myInstance;
    private static final String CSS_LABEL = "cssLabelsFloatingBar";

    private String _styleSheet;

    private Stage _stage;
    private int _stageWidth;
    private int _stageHeight;
    private int _windowPosX;
    private int _windowPosY;
    private HBox _mainHBox;
    private VBox _mainfloatingTaskArea;

    /**
     * Create an instance of FloatingBarViewUserInterface.
     * 
     * @param primaryStage
     * @param screenBounds
     * @param isFixedSize
     * @param styleSheet
     * @param mouseEvent
     * @return Instance of FloatingBarViewUserInterface only if there isn't an
     *         instance already.
     */
    public static FloatingBarViewUserInterface getInstance(Stage primaryStage, Rectangle2D screenBounds,
            boolean isFixedSize, String styleSheet, EventHandler<MouseEvent> mouseEvent) {
        if (_myInstance == null) {
            _myInstance = new FloatingBarViewUserInterface(primaryStage, screenBounds, isFixedSize,
                    styleSheet, mouseEvent);
            return _myInstance;
        }
        return null;
    }

    private FloatingBarViewUserInterface(Stage primaryStage, Rectangle2D screenBounds, boolean isFixedSize,
            String styleSheet, EventHandler<MouseEvent> mouseEvent) {
        _styleSheet = styleSheet;
        initializeVaribles(screenBounds, isFixedSize);
        initializeStage(primaryStage, _windowPosX, _windowPosY, _stageWidth, _stageHeight, mouseEvent);
    }

    /**
     * Initialize view dimensions and position.
     */
    public void initializeVaribles(Rectangle2D screenBounds, boolean isFixedSize) {
        if (isFixedSize) {
            _stageWidth = (int) screenBounds.getWidth();
            _stageHeight = COMPONENT_HEIGHT;
            _windowPosX = POSITION_ZERO;
            _windowPosY = POSITION_ZERO;
        } else {
            _stageWidth = (int) (screenBounds.getWidth() * PrimaryUserInterface.PREFERED_WINDOW_SCALE);
            _stageHeight = COMPONENT_HEIGHT;
            _windowPosX = (int) (screenBounds.getWidth()
                    - (screenBounds.getWidth() * PrimaryUserInterface.PREFERED_WINDOW_SCALE)) / 2;
            _windowPosY = COMPONENT_TOP_MARGIN;
        }
    }

    /**
     * Initialize the stage and the components in the stage.
     */
    public void initializeStage(Window owner, int applicationX, int applicationY, int windowWidth,
            int windowHeight, EventHandler<MouseEvent> mouseEvent) {
        _stage = new Stage();
        _stage.initOwner(owner);
        _stage.initStyle(StageStyle.TRANSPARENT);
        _stage.setX(applicationX);
        _stage.setY(applicationY);

        _mainHBox = new HBox();
        _mainHBox.setPrefHeight(_stageHeight);
        _mainHBox.setMaxHeight(_stageHeight);
        _mainHBox.setId("cssRootFloatingBar");

        Scene scene = new Scene(_mainHBox, windowWidth, windowHeight, Color.TRANSPARENT);
        scene.getStylesheets().add(_styleSheet);
        scene.setFill(Color.TRANSPARENT);
        scene.setOnMousePressed(mouseEvent);
        _stage.setScene(scene);

        build();
    }

    public void build() {
        Label floatTitleLabel = new Label("Floating task of the day");
        floatTitleLabel.getStyleClass().add(CSS_LABEL);
        floatTitleLabel.setMinHeight(_stageHeight);
        floatTitleLabel.setMinWidth(LABEL_TITLE_WIDTH);
        floatTitleLabel.setId("cssFloatingBarTitleLabel");
        floatTitleLabel.setAlignment(Pos.CENTER);
        floatTitleLabel.setFont(FONT_LABEL_TITLE);

        _mainfloatingTaskArea = new VBox();
        _mainfloatingTaskArea.setMinWidth(_stageWidth - LABEL_TITLE_WIDTH);
        _mainfloatingTaskArea.setId("cssFloatingBarContentArea");

        _mainHBox.getChildren().add(floatTitleLabel);
        _mainHBox.getChildren().add(_mainfloatingTaskArea);
    }

    /**
     * Adds a task at the bottom of the current task.
     * 
     * @param taskDesc
     */
    public void addTask(String taskDesc) {
        Label floatTask = new Label(taskDesc);
        floatTask.getStyleClass().add(CSS_LABEL);
        floatTask.setMinHeight(_stageHeight);
        floatTask.setMaxHeight(_stageHeight);
        floatTask.setAlignment(Pos.CENTER);
        floatTask.setFont(FONT_LABEL_TASK);
        VBox.setMargin(floatTask, new Insets(0, 0, 0, LEFT_MARGIN));
        _mainfloatingTaskArea.getChildren().add(floatTask);
    }

    /**
     * Removes the first item in the _mianFloatingTaskArea.
     */
    private void removeTopItem() {
        if (_mainfloatingTaskArea.getChildren().size() > 1) {
            _mainfloatingTaskArea.getChildren().remove(0);
            _mainfloatingTaskArea.setTranslateY(0);
        }
    }

    public void clearFloatingBar() {
        _mainfloatingTaskArea.getChildren().clear();
    }

    public void show() {
        _stage.show();
    }

    public void hide() {
        _stage.hide();
    }

    public void update(int value) {

    }

    public void updateTranslateY(double posY) {

    }

    /**
     * Translate the position of the _mainFloatingTaskArea base on
     * percentageDone
     * 
     * @param percentageDone
     * @return true only if animation is done
     */
    public boolean animateView(double percentageDone) {
        double posY = percentageDone * (double) _stageHeight;
        if (posY < _stageHeight) {
            _mainfloatingTaskArea.setTranslateY(-posY);
            return false;
        } else {
            removeTopItem();
            return true;
        }
    }

    public void destoryStage() {
        _myInstance = null;
        _stage.close();
    }

    public void changeTheme(String styleSheet) {
        _stage.getScene().getStylesheets().clear();
        _styleSheet = styleSheet;
        _stage.getScene().getStylesheets().add(styleSheet);
    }

}
```
###### src\userinterface\FloatingTaskUserInterface.java
``` java
 * 
 *          This class build and manage the floating panel where it shows the
 *          floating task.
 */
package userinterface;

import java.util.ArrayList;
import entity.TaskEntity;
import javafx.event.EventHandler;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.geometry.Rectangle2D;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.HBox;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import javafx.stage.Window;

public class FloatingTaskUserInterface implements ViewInterface {

    private static FloatingTaskUserInterface _myInstance;

    private String _styleSheet;

    private Stage _stage;
    private int _stageWidth;
    private int _stageHeight;
    private int _windowPosX;
    private int _windowPosY;

    private StackPane _mainVbox;
    private VBox _secondaryVbox;

    private static final String CSS_LABEL = "cssLabelsFloatingTaskInterface";

    // font
    static final int FONT_SIZE_LABEL = 20;
    static final int FONT_SIZE_LABEL_DATE = 10;
    static final int FONT_SIZE_TASK = 12;
    static final int FONT_SIZE_INDEX = 8;
    private static final Font FONT_LABEL = new Font(PrimaryUserInterface.FONT_TITLE_LABLES, FONT_SIZE_LABEL);
    private static final Font FONT_TASK = new Font(PrimaryUserInterface.FONT_DEFAULT, FONT_SIZE_TASK);

    static final int LABEL_TITLE_HEIGHT = 30;
    static final int LABEL_TASK_HEIGHT = 25;
    private static final int THRESHOLD = 20;

    // variables to control items in floatingView.
    private int _startIndex = -1;
    private int _endIndex = -1;
    private int _selectedIndex = -1;

    private ArrayList<TaskEntity> _floatingList;
    private ArrayList<HBox> _floatingBoxes = new ArrayList<HBox>();

    /**
     * Create an instance of FloatingTaskUserInterface.
     * 
     * @param primaryStage
     * @param screenBounds
     * @param isFixedSize
     * @param styleSheet
     * @param mouseEvent
     * @return Instance of FloatingTaskUserInterface only if there isn't an
     *         instance already.
     */
    public static FloatingTaskUserInterface getInstance(Stage primaryStage, Rectangle2D screenBounds,
            boolean isFixedSize, String styleSheet, EventHandler<MouseEvent> mouseEvent) {
        if (_myInstance == null) {
            if (primaryStage == null || screenBounds == null) {
                return null;
            }
            _myInstance = new FloatingTaskUserInterface(primaryStage, screenBounds, isFixedSize, styleSheet,
                    mouseEvent);
            return _myInstance;
        }
        return null;
    }

    private FloatingTaskUserInterface(Stage primaryStage, Rectangle2D screenBounds, boolean isFixedSize,
            String styleSheet, EventHandler<MouseEvent> mouseEvent) {
        _styleSheet = styleSheet;
        initializeVaribles(screenBounds, isFixedSize);
        initializeStage(primaryStage, _windowPosX, _windowPosY, _stageWidth, _stageHeight, mouseEvent);
        buildComponent();
    }

    /**
     * Initialize view dimensions and position.
     */
    public void initializeVaribles(Rectangle2D screenBounds, boolean isFixedSize) {
        if (isFixedSize) {
            _stageWidth = (int) screenBounds.getWidth();
            _stageHeight = (int) (screenBounds.getHeight() - PrimaryUserInterface.COMMAND_BAR_HEIGTH
                    - PrimaryUserInterface.COMMAND_BAR_TOP_MARGIN
                    - PrimaryUserInterface.COMMAND_BAR_BOTTOM_MARGIN
                    - FloatingBarViewUserInterface.COMPONENT_HEIGHT
                    - FloatingBarViewUserInterface.COMPONENT_BOTTOM_MARGIN);
            _windowPosX = DescriptionComponent.CONPONENT_WIDTH + DescriptionComponent.CONPONENT_RIGHT_MARGIN;
            _windowPosY = (int) screenBounds.getHeight() - _stageHeight
                    - PrimaryUserInterface.COMMAND_BAR_HEIGTH - PrimaryUserInterface.COMMAND_BAR_TOP_MARGIN
                    - PrimaryUserInterface.COMMAND_BAR_BOTTOM_MARGIN;
        } else {
            _stageWidth = (int) (screenBounds.getWidth() * PrimaryUserInterface.PREFERED_WINDOW_SCALE);
            _stageHeight = (int) (screenBounds.getHeight() - PrimaryUserInterface.COMMAND_BAR_HEIGTH
                    - PrimaryUserInterface.COMMAND_BAR_TOP_MARGIN
                    - PrimaryUserInterface.COMMAND_BAR_BOTTOM_MARGIN
                    - FloatingBarViewUserInterface.COMPONENT_HEIGHT
                    - FloatingBarViewUserInterface.COMPONENT_TOP_MARGIN
                    - FloatingBarViewUserInterface.COMPONENT_BOTTOM_MARGIN);
            _windowPosX = (int) (screenBounds.getWidth()
                    - (screenBounds.getWidth() * PrimaryUserInterface.PREFERED_WINDOW_SCALE)) / 2;
            _windowPosY = (int) screenBounds.getHeight() - _stageHeight
                    - PrimaryUserInterface.COMMAND_BAR_HEIGTH - PrimaryUserInterface.COMMAND_BAR_TOP_MARGIN
                    - PrimaryUserInterface.COMMAND_BAR_BOTTOM_MARGIN;
        }
    }

    /**
     * Initialize the stage and the components in the stage.
     */
    public void initializeStage(Window owner, int applicationX, int applicationY, int stageWidth,
            int stageHeight, EventHandler<MouseEvent> mouseEvent) {
        _stage = new Stage();
        _stage.initOwner(owner);
        _stage.initStyle(StageStyle.TRANSPARENT);
        _stage.setX(applicationX);
        _stage.setY(applicationY);

        _mainVbox = new StackPane();
        _mainVbox.setPrefSize(stageWidth, stageHeight);
        _mainVbox.setId("cssRootFloatingTaskView");

        Scene scene = new Scene(_mainVbox, stageWidth, stageHeight);
        scene.getStylesheets().add(_styleSheet);
        scene.setFill(Color.TRANSPARENT);
        scene.setOnMousePressed(mouseEvent);
        _stage.setScene(scene);
    }

    /**
     * Updates the selector index by the amount of value. Items are added and
     * removed to maintain THRESHOLD.
     */
    public void update(int value) {
        if (value > 0)// ctrl down
        {
            if (_endIndex + 1 < _floatingList.size()) {
                if (_selectedIndex - _startIndex >= THRESHOLD) {
                    removeFirstTask();
                    addLastItem();
                }
            }
        } else if (value < 0) {
            if (_startIndex > 0) {
                if (_endIndex - _selectedIndex >= THRESHOLD) {
                    removeLastTask();
                    addFirstItem();
                }
            }
        }
    }

    private void addFirstItem() {
        _startIndex--;
        HBox item = buildIndividualFloating(_floatingList.get(_startIndex), _startIndex);
        _floatingBoxes.add(0, item);
        _secondaryVbox.getChildren().add(0, item);
    }

    private void removeLastTask() {
        _endIndex--;
        HBox itemToRemove = _floatingBoxes.remove(_floatingBoxes.size() - 1);
        _secondaryVbox.getChildren().remove(itemToRemove);
    }

    private void addLastItem() {
        _endIndex++;
        HBox item = buildIndividualFloating(_floatingList.get(_endIndex), _endIndex);
        _floatingBoxes.add(item);
        _secondaryVbox.getChildren().add(item);
    }

    private void removeFirstTask() {
        _startIndex++;
        HBox item = _floatingBoxes.remove(0);
        _secondaryVbox.getChildren().remove(item);
    }

    public void updateTranslateY(double posY) {
    }

    public void show() {
        _stage.show();
    }

    public void hide() {
        _stage.hide();
    }

    /**
     * Build the main structure of the component.
     */
    public void buildComponent() {

        _mainVbox.getChildren().clear();
        _secondaryVbox = new VBox();
        _secondaryVbox.setMinHeight(_stageHeight - LABEL_TITLE_HEIGHT);
        _secondaryVbox.setMaxHeight(_stageHeight - LABEL_TITLE_HEIGHT);

        _mainVbox.getChildren().add(_secondaryVbox);
        HBox labelTitle = buildTilteLabel();
        _mainVbox.getChildren().add(labelTitle);
        StackPane.setAlignment(labelTitle, Pos.TOP_LEFT);
        StackPane.setAlignment(_secondaryVbox, Pos.TOP_LEFT);
    }

    /**
     * Check if there are any floating task and build the components base on
     * floatingList size.
     * 
     * @param floatingList
     * @param index
     */
    public void buildContent(ArrayList<TaskEntity> floatingList, int index) {
        _floatingList = floatingList;
        _floatingBoxes = new ArrayList<HBox>();
        // when there are no floating task yet
        if (_floatingList == null || _floatingList.size() == 0) {
            buildHelpWithFloating();
        } else {
            buildFloatingList(_floatingList, index);
        }
    }

    public HBox buildTilteLabel() {
        HBox titleLableBox = new HBox();
        titleLableBox.setId("cssFloatingTaskViewTitle");
        titleLableBox.setMinWidth(_stageWidth);
        titleLableBox.setMinHeight(LABEL_TITLE_HEIGHT);
        titleLableBox.setMaxHeight(LABEL_TITLE_HEIGHT);

        Label floatingTitle = new Label("Floating View");
        floatingTitle.getStyleClass().add(CSS_LABEL);
        floatingTitle.setMinWidth(_stageWidth);
        floatingTitle.setFont(FONT_LABEL);
        floatingTitle.setMinHeight(LABEL_TITLE_HEIGHT);
        floatingTitle.setMaxHeight(LABEL_TITLE_HEIGHT);
        HBox.setMargin(floatingTitle, new Insets(0, 0, 0, 30));

        titleLableBox.getChildren().add(floatingTitle);
        return titleLableBox;
    }

    /**
     * Builds the component when there are no floating task.
     */
    public void buildHelpWithFloating() {
        _secondaryVbox.getChildren().clear();
        Label helpLabel = new Label("You do not have any floating task yet.");
        helpLabel.getStyleClass().add(CSS_LABEL);
        helpLabel.setMinWidth(_stageWidth);
        helpLabel.setMinHeight(_stageHeight - LABEL_TITLE_HEIGHT);
        helpLabel.setAlignment(Pos.CENTER);
        _secondaryVbox.getChildren().add(helpLabel);
    }

    public void buildFloatingList(ArrayList<TaskEntity> floatingList, int index) {
        _secondaryVbox.getChildren().clear();
        if (index < floatingList.size() && index > -1) {
            _selectedIndex = index;
        } else {
            _selectedIndex = 0;
        }
        _startIndex = 0;

        if (floatingList.size() < THRESHOLD * 2) {
            _endIndex = floatingList.size() - 1;
        } else {
            _endIndex = THRESHOLD * 2;
        }

        for (int i = _startIndex; i <= _endIndex; i++) {
            HBox item = buildIndividualFloating(floatingList.get(i), i);
            _secondaryVbox.getChildren().add(item);
            _floatingBoxes.add(item);
        }
        setSelected(0);
    }

    /**
     * Build the individual component for each floating task.
     * 
     * @param task
     * @param index
     * @return HBox
     */
    public HBox buildIndividualFloating(TaskEntity task, int index) {
        HBox parentBox = new HBox();
        VBox parentBoxChild = new VBox();
        parentBoxChild.setMinWidth(_stageWidth);
        parentBoxChild.setMaxWidth(_stageWidth);

        HBox top = new HBox();
        top.setMinWidth(_stageWidth);
        top.setMaxWidth(_stageWidth);

        Label indexLabel = new Label("ID" + Integer.toString(index));
        indexLabel.getStyleClass().add(CSS_LABEL);
        indexLabel.setMinHeight(LABEL_TASK_HEIGHT);
        indexLabel.setMinWidth(60);
        indexLabel.setAlignment(Pos.CENTER);
        indexLabel.setFont(Font.font(PrimaryUserInterface.FONT_DEFAULT, FontWeight.BOLD, FONT_SIZE_TASK));
        top.getChildren().add(indexLabel);

        Label timeLabel = new Label();
        timeLabel.setText(task.getTime());
        timeLabel.getStyleClass().add(CSS_LABEL);
        timeLabel.setMinHeight(LABEL_TASK_HEIGHT);
        timeLabel.setAlignment(Pos.CENTER);
        timeLabel.setFont(FONT_TASK);
        HBox.setMargin(timeLabel, new Insets(0, 10, 0, 0));
        top.getChildren().add(timeLabel);

        Label nameLabel = new Label();
        nameLabel.getStyleClass().add(CSS_LABEL);
        nameLabel.setText(task.getName());
        nameLabel.setMinHeight(LABEL_TASK_HEIGHT);
        nameLabel.setAlignment(Pos.CENTER);
        nameLabel.setFont(FONT_TASK);
        HBox.setMargin(nameLabel, new Insets(0, 10, 0, 0));
        top.getChildren().add(nameLabel);
        top.setMinHeight(LABEL_TASK_HEIGHT);

        HBox mid = new HBox();
        Label indexPlaceHolder = new Label();
        indexPlaceHolder.getStyleClass().add(CSS_LABEL);
        indexPlaceHolder.setMinWidth(50);
        mid.getChildren().add(indexPlaceHolder);

        Text description = new Text();
        description.getStyleClass().add(CSS_LABEL);
        description.setText(task.getDescription());
        description.setWrappingWidth(_stageWidth - 50);
        mid.getChildren().add(description);
        mid.setMinHeight(description.getBoundsInLocal().getHeight() + 10);

        HBox btm = new HBox();
        Label indexPlaceHolder2 = new Label();
        indexPlaceHolder2.getStyleClass().add(CSS_LABEL);
        indexPlaceHolder2.setMinWidth(50);
        btm.getChildren().add(indexPlaceHolder2);

        Text hashtags = new Text();
        hashtags.getStyleClass().add(CSS_LABEL);
        hashtags.setText(task.getHashtags());
        hashtags.setWrappingWidth(_stageWidth - 50);
        btm.getChildren().add(hashtags);
        btm.setMinHeight(hashtags.getBoundsInLocal().getHeight() + 10);

        parentBoxChild.getChildren().add(top);
        parentBoxChild.getChildren().add(mid);
        parentBoxChild.getChildren().add(btm);
        parentBoxChild.setMinHeight(top.getMinHeight() + mid.getMinHeight() + btm.getMinHeight());
        parentBox.getChildren().add(parentBoxChild);
        parentBox.setMinHeight(parentBoxChild.getMinHeight());
        return parentBox;
    }

    /**
     * Sets the selected item base on value.
     * 
     * @param value
     */
    public void setSelected(int value) {
        int temp = _selectedIndex + value;
        if (isBetweenRange(temp)) {
            HBox prevItem = _floatingBoxes.get(_selectedIndex - _startIndex);
            prevItem.setId("");
            _selectedIndex = temp;
            HBox item = _floatingBoxes.get(_selectedIndex - _startIndex);
            item.setId("cssFloatingTaskViewSelected");
            translateY(calculateTopHeight(_selectedIndex - _startIndex));
        }
    }

    /**
     * Calculates the height above the selected component.
     * 
     * @param index
     * @return height
     */
    public double calculateTopHeight(int index) {
        double posY = 0;
        for (int i = 0; i <= index; i++) {
            posY += _floatingBoxes.get(i).getMinHeight();
        }
        return posY;
    }

    public void translateY(double itemTopHeight) {
        double posY = -LABEL_TITLE_HEIGHT;
        int entireAreaHeight = _stageHeight - LABEL_TITLE_HEIGHT;
        if (itemTopHeight + LABEL_TASK_HEIGHT > entireAreaHeight) {
            posY += itemTopHeight + LABEL_TASK_HEIGHT - entireAreaHeight;
        } else if (itemTopHeight < entireAreaHeight) {

        }
        _secondaryVbox.setTranslateY(-posY);
    }

    /**
     * Check if the index is between _startIndex and _endIndex.
     * 
     * @param index
     * @return true only if index is bewteen the range
     */
    public boolean isBetweenRange(int index) {
        if (index >= _startIndex && index <= _endIndex) {
            return true;
        }
        return false;
    }

    public StackPane getMainLayoutComponent() {
        return _mainVbox;
    }

    public void changeTheme(String styleSheet) {
        _stage.getScene().getStylesheets().clear();
        _styleSheet = styleSheet;
        _stage.getScene().getStylesheets().add(styleSheet);
    }

    public void destoryStage() {
        _myInstance = null;
        _stage.close();
    }
}
```
###### src\userinterface\HelpScreenUserInterface.java
``` java
 * 
 *          This class build a panel over the entire application to show
 *          information.
 */
package userinterface;

import javafx.event.EventHandler;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.geometry.Rectangle2D;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import javafx.stage.Window;

public class HelpScreenUserInterface implements ViewInterface {

    private static HelpScreenUserInterface _myInstance;

    private static final String HELP_DESCRIPTION_FLOATING_BAR_TITLE = "Floating Panel";
    private static final String HELP_DESCRIPTION_FLOATING_BAR = "This panel shows you tasks without deadlines assigned to them. It changes every 10 seconds.";
    private static final String FILE_PATH_MESSAGE = "Your file is currently saved to";

    private static final String HELP_DESCRIPTION_MAIN_TITLE = "Welcome to PCNM Help Manual!";
    private static final String HELP_DESCRIPTION_MAIN = "Press the left and right arrow keys to scroll through and F1 to close the Help Screen";

    private static final String HELP_DESCRIPTION_DESCRIPTION_COMPONENT_TITLE = "Description Panel";
    private static final String HELP_DESCRIPTION_DESCRIPTION_COMPONENT = "This panel shows you a range of dates of the tasks in the week.";

    private static final String HELP_DESCRIPTION_TASK_VIEW_TITLE = "Main View";
    private static final String HELP_DESCRIPTION_TASK_VIEW = "This panel shows your tasks in chronological order.";

    private static final String HELP_DESCRIPTION_DETAIL_COMPONENT_TITLE = "Details Panel";
    private static final String HELP_DESCRIPTION_DETAIL_COMPONENT = "This panel shows you more descriptions and links of the selected task.";

    private static final String[][] CHEAT_SHEET_SHORT_CUTS = { { "F1", "Brings up the Help Manual!" },
            { "F2", "Collapses application into Compact View" },
            { "F3", "Displays application in Full View" }, { "F4", "Shuffle through the themes" },
            { "Up/Down", "Retrieves previous commands entered" },
            { "Ctrl + Up/Down", "Scrolls through task list" },
            { "Ctrl + Left/Right", "Switches from Main to Floating to Search View" }, { "", "" } };
    private static final String[][] CHEAT_SHEET_COMMANDS = {
            { "ADD", "Adds a task into your task list, tasks without dates will be added to the Floating View" },
            { "DELETE", "Deletes a task with a specific ID" }, { "EDIT", "Edits your task based on ID" },
            { "LINK",
                    "Links two tasks together to create associations between the tasks, eg. LINK ID1-ID5 (ID1 will be project head)" },
            { "SEARCH", "Searches for any task based on keywords or hashtags" },
            { "HIDE", "Collapses the application into Compact View" },
            { "SHOW", "Displays the application in Full View" }, { "FLOAT", "Switches to Floating View" },
            { "MAIN", "Switches to Main View" }, { "THEME", "Changes application theme" },
            { "SAVETO", "Changes the directory of the saved task file" },
            { "LOADFROM", "Loads an existing task file" } };
    private static final String HELP_DESCRIPTION_COMMAND_BAR_TITLE = "Command Bar";
    private static final String HELP_DESCRIPTION_COMMAND_BAR = "This is where you input your commands. Start with a command word, followed by the necessary fields.";

    // Font
    private static final int FONT_SIZE_LABEL_TITLE = 18;
    private static final Font FONT_LABEL_TITLE = new Font(PrimaryUserInterface.FONT_DEFAULT,
            FONT_SIZE_LABEL_TITLE);
    private static final int FONT_SIZE_LABEL = 12;
    private static final Font FONT_LABEL = new Font(PrimaryUserInterface.FONT_DEFAULT, FONT_SIZE_LABEL);

    private static final int MARGIN = 10;
    private static final int MAX_ITEMS = 6;

    private static final int DESCRIPTION_BOX_WIDTH = 300;
    private static final int DESCRIPTION_BOX_SMALL_WIDTH = 200;
    private static final int DESCRIPTION_BOX_HEIGHT = 150;
    private static final int LINE_SIZE = 2;
    private static final int LINE_LENGTH = 20;

    private String _styleSheet;
    private String _filePathLoadFrom;
    private Label _filePathLabel;

    private Stage _stage;
    private int _stageWidth;
    private int _stageHeight;
    private int _windowPosX;
    private int _windowPosY;
    private boolean _isFixed;
    private Rectangle2D _screenBounds;
    private double _taskViewWidth;

    private StackPane _mainPanel;
    private Pane[] _items = new Pane[MAX_ITEMS];

    private int _selector = 0;

    /**
     * Create an instance of HelpScreenUserInterface.
     * 
     * @param primaryStage
     * @param screenBounds
     * @param isFixedSize
     * @param styleSheet
     * @param mouseEvent
     * @param filePathLoadFrom
     * @return Instance of HelpScreenUserInterface only if there isn't an
     *         instance already.
     */
    public static HelpScreenUserInterface getInstance(Stage primaryStage, Rectangle2D screenBounds,
            boolean isFixedSize, String styleSheet, EventHandler<MouseEvent> mouseEvent,
            String filePathLoadFrom) {
        if (_myInstance == null) {
            if (primaryStage == null || screenBounds == null) {
                return null;
            }
            _myInstance = new HelpScreenUserInterface(primaryStage, screenBounds, isFixedSize, styleSheet,
                    mouseEvent, filePathLoadFrom);
            return _myInstance;
        }
        return null;
    }

    public HelpScreenUserInterface(Stage primaryStage, Rectangle2D screenBounds, boolean isFixedSize,
            String styleSheet, EventHandler<MouseEvent> mouseEvent, String filePathLoadFrom) {
        _styleSheet = styleSheet;
        _filePathLoadFrom = filePathLoadFrom;
        initializeVaribles(screenBounds, isFixedSize);
        initializeStage(primaryStage, _windowPosX, _windowPosY, _stageWidth, _stageHeight, mouseEvent);
    }

    /**
     * Initialize view dimensions and position.
     */
    public void initializeVaribles(Rectangle2D screenBounds, boolean isFixedSize) {
        _isFixed = isFixedSize;
        _screenBounds = screenBounds;
        if (isFixedSize) {
            _stageWidth = (int) screenBounds.getWidth();
            _stageHeight = (int) (screenBounds.getHeight() - PrimaryUserInterface.COMMAND_BAR_BOTTOM_MARGIN);
            _windowPosX = 0;
            _windowPosY = 0;
        } else {
            _stageWidth = (int) (screenBounds.getWidth() * PrimaryUserInterface.PREFERED_WINDOW_SCALE);
            _stageHeight = (int) (screenBounds.getHeight() - PrimaryUserInterface.COMMAND_BAR_BOTTOM_MARGIN
                    - FloatingBarViewUserInterface.COMPONENT_TOP_MARGIN);
            _windowPosX = (int) (screenBounds.getWidth()
                    - (screenBounds.getWidth() * PrimaryUserInterface.PREFERED_WINDOW_SCALE)) / 2;
            _windowPosY = (int) screenBounds.getHeight() - _stageHeight
                    - PrimaryUserInterface.COMMAND_BAR_BOTTOM_MARGIN;
        }
    }

    /**
     * Initialize the stage and the components in the stage.
     */
    public void initializeStage(Window owner, int applicationX, int applicationY, int windowWidth,
            int windowHeight, EventHandler<MouseEvent> mouseEvent) {
        _stage = new Stage();
        _stage.initOwner(owner);
        _stage.initStyle(StageStyle.TRANSPARENT);
        _stage.setX(applicationX);
        _stage.setY(applicationY);

        _mainPanel = new StackPane();
        _mainPanel.setId("cssHelpScreenRoot");
        _mainPanel.setPrefSize(windowWidth, windowHeight);
        _mainPanel.setAlignment(Pos.TOP_CENTER);

        Scene scene = new Scene(_mainPanel, windowWidth, windowHeight);
        scene.getStylesheets().add(_styleSheet);
        scene.setFill(Color.TRANSPARENT);
        scene.setOnMousePressed(mouseEvent);

        _stage.setScene(scene);
        buildComponent();
    }

    public void buildComponent() {
        _items[0] = buildMainHelp();
        _items[1] = buildfloatingBarHelp();
        _items[2] = buildDescriptionHelp();
        _items[3] = buildTaskViewHelp();
        _items[4] = buildDetailComponentHelp();
        _items[5] = buildCommandBarHelp();
        _mainPanel.getChildren().add(_items[0]);
    }

    public void changeFilePath(String filePath) {
        _filePathLoadFrom = filePath;
        _filePathLabel.setText(FILE_PATH_MESSAGE.concat(" ").concat(_filePathLoadFrom));
    }

    public VBox buildMainHelp() {
        double minWidth = _stageWidth * 0.8;
        VBox main = new VBox();
        main.setAlignment(Pos.CENTER);

        VBox descriptionBox = new VBox();
        descriptionBox.setMaxWidth(minWidth);
        descriptionBox.setMinWidth(minWidth);
        descriptionBox.setId("cssHelpComponentDescriptionBox");

        Label title = new Label(HELP_DESCRIPTION_MAIN_TITLE);
        title.setFont(FONT_LABEL_TITLE);
        title.setId("cssHelpTitle");
        title.setMinWidth(minWidth - MARGIN * 2);
        title.setAlignment(Pos.CENTER);
        descriptionBox.getChildren().add(title);

        Label descLabel = new Label(HELP_DESCRIPTION_MAIN);
        descLabel.setMinWidth(minWidth - MARGIN * 2);
        descLabel.setFont(FONT_LABEL);
        descLabel.setAlignment(Pos.CENTER);
        descLabel.setWrapText(true);
        VBox.setMargin(descLabel, new Insets(MARGIN, MARGIN, MARGIN, MARGIN));
        VBox.setMargin(title, new Insets(MARGIN, MARGIN, MARGIN, MARGIN));
        descriptionBox.getChildren().add(descLabel);

        Label titleCheatSheet = new Label("Cheat Sheet");
        titleCheatSheet.setFont(FONT_LABEL_TITLE);
        titleCheatSheet.setId("cssHelpTitle");
        titleCheatSheet.setMinWidth(minWidth - MARGIN * 2);
        titleCheatSheet.setAlignment(Pos.CENTER);
        VBox.setMargin(titleCheatSheet, new Insets(MARGIN, MARGIN, MARGIN, MARGIN));
        descriptionBox.getChildren().add(titleCheatSheet);

        GridPane gp = new GridPane();
        Label shortcutsTitle = new Label("Short-cut Keys");
        shortcutsTitle.setMinWidth(120);
        Label shortcutDesriptionTitle = new Label("Description");
        gp.add(shortcutsTitle, 0, 0);
        gp.add(shortcutDesriptionTitle, 1, 0);
        int rowCount = 1;
        for (int i = 0; i < CHEAT_SHEET_SHORT_CUTS.length; i++) {
            Label shortcuts = new Label(CHEAT_SHEET_SHORT_CUTS[i][0]);
            shortcuts.setFont(FONT_LABEL);
            gp.add(shortcuts, 0, i + 1);
            Label shortcutsDescription = new Label(CHEAT_SHEET_SHORT_CUTS[i][1]);
            shortcutsDescription.setFont(FONT_LABEL);
            gp.add(shortcutsDescription, 1, i + 1);
            rowCount = i;
        }
        rowCount++;

        Label commandsTitle = new Label("Commands");
        GridPane.setMargin(commandsTitle, new Insets(MARGIN, 0, 0, 0));
        Label commandsDesriptionTitle = new Label("Description");
        GridPane.setMargin(commandsDesriptionTitle, new Insets(MARGIN, 0, 0, 0));
        gp.add(commandsTitle, 0, rowCount);
        gp.add(commandsDesriptionTitle, 1, rowCount);
        rowCount++;

        for (int i = 0; i < CHEAT_SHEET_COMMANDS.length; i++) {
            Label shortcuts = new Label(CHEAT_SHEET_COMMANDS[i][0]);
            shortcuts.setFont(FONT_LABEL);
            gp.add(shortcuts, 0, rowCount);
            Label shortcutsDescription = new Label(CHEAT_SHEET_COMMANDS[i][1]);
            shortcutsDescription.setFont(FONT_LABEL);
            gp.add(shortcutsDescription, 1, rowCount);
            rowCount++;
        }

        VBox.setMargin(gp, new Insets(MARGIN, MARGIN, MARGIN, MARGIN));
        descriptionBox.getChildren().add(gp);

        _filePathLabel = new Label(FILE_PATH_MESSAGE.concat(" ").concat(_filePathLoadFrom));
        _filePathLabel.setFont(FONT_LABEL);
        VBox.setMargin(_filePathLabel, new Insets(0, MARGIN, 0, MARGIN));
        descriptionBox.getChildren().add(_filePathLabel);

        main.getChildren().add(descriptionBox);
        return main;
    }

    public HBox buildDetailComponentHelp() {
        HBox main = new HBox();

        double componentHeight = 0;
        double componentWidth = 0;
        if (_isFixed) {
            componentWidth = DetailComponent.COMPONENT_WIDTH;
            componentHeight = (int) (_screenBounds.getHeight() - PrimaryUserInterface.COMMAND_BAR_HEIGTH
                    - PrimaryUserInterface.COMMAND_BAR_TOP_MARGIN
                    - PrimaryUserInterface.COMMAND_BAR_BOTTOM_MARGIN
                    - FloatingBarViewUserInterface.COMPONENT_HEIGHT
                    - FloatingBarViewUserInterface.COMPONENT_BOTTOM_MARGIN);
        } else {
            componentWidth = DetailComponent.COMPONENT_WIDTH;
            componentHeight = (int) (_screenBounds.getHeight() - PrimaryUserInterface.COMMAND_BAR_HEIGTH
                    - PrimaryUserInterface.COMMAND_BAR_TOP_MARGIN
                    - PrimaryUserInterface.COMMAND_BAR_BOTTOM_MARGIN
                    - FloatingBarViewUserInterface.COMPONENT_HEIGHT
                    - FloatingBarViewUserInterface.COMPONENT_TOP_MARGIN
                    - FloatingBarViewUserInterface.COMPONENT_BOTTOM_MARGIN);
        }
        main.setMaxHeight(componentHeight);
        main.setAlignment(Pos.CENTER_LEFT);

        HBox hbox = new HBox();
        hbox.setMinSize(componentWidth, componentHeight);
        hbox.setId("cssHelpComponentHighLighter");

        HBox link = new HBox();
        link.setMinHeight(LINE_SIZE);
        link.setMaxHeight(LINE_SIZE);
        link.setMinWidth(LINE_LENGTH);
        link.setId("cssHelpComponentLinker");

        VBox descriptionBox = new VBox();
        descriptionBox.setMaxWidth(200);
        descriptionBox.setMaxHeight(150);
        descriptionBox.setId("cssHelpComponentDescriptionBox");

        Label title = new Label(HELP_DESCRIPTION_DETAIL_COMPONENT_TITLE);
        title.setFont(FONT_LABEL_TITLE);
        title.setId("cssHelpTitle");
        descriptionBox.getChildren().add(title);

        Label descLabel = new Label(HELP_DESCRIPTION_DETAIL_COMPONENT);
        descLabel.setFont(FONT_LABEL);
        descLabel.setWrapText(true);
        VBox.setMargin(descLabel, new Insets(MARGIN, MARGIN, MARGIN, MARGIN));
        VBox.setMargin(title, new Insets(MARGIN, MARGIN, MARGIN, MARGIN));
        descriptionBox.getChildren().add(descLabel);

        main.getChildren().add(descriptionBox);
        main.getChildren().add(link);
        main.getChildren().add(hbox);
        main.setTranslateX(_taskViewWidth + DescriptionComponent.CONPONENT_WIDTH
                + DescriptionComponent.CONPONENT_RIGHT_MARGIN - 220);
        main.setTranslateY(FloatingBarViewUserInterface.COMPONENT_HEIGHT);
        return main;
    }

    public HBox buildTaskViewHelp() {
        HBox main = new HBox();

        double componentHeight = 0;
        if (_isFixed) {
            _taskViewWidth = (int) _screenBounds.getWidth() - DescriptionComponent.CONPONENT_WIDTH
                    - DescriptionComponent.CONPONENT_RIGHT_MARGIN - DetailComponent.COMPONENT_WIDTH
                    - DetailComponent.COMPONENT_LEFT_MARGIN;
            componentHeight = (int) (_screenBounds.getHeight() - PrimaryUserInterface.COMMAND_BAR_HEIGTH
                    - PrimaryUserInterface.COMMAND_BAR_TOP_MARGIN
                    - PrimaryUserInterface.COMMAND_BAR_BOTTOM_MARGIN
                    - FloatingBarViewUserInterface.COMPONENT_HEIGHT
                    - FloatingBarViewUserInterface.COMPONENT_BOTTOM_MARGIN);
        } else {
            _taskViewWidth = (int) (_screenBounds.getWidth() * PrimaryUserInterface.PREFERED_WINDOW_SCALE)
                    - DescriptionComponent.CONPONENT_WIDTH - DescriptionComponent.CONPONENT_RIGHT_MARGIN
                    - DetailComponent.COMPONENT_WIDTH - DetailComponent.COMPONENT_LEFT_MARGIN;
            componentHeight = (int) (_screenBounds.getHeight() - PrimaryUserInterface.COMMAND_BAR_HEIGTH
                    - PrimaryUserInterface.COMMAND_BAR_TOP_MARGIN
                    - PrimaryUserInterface.COMMAND_BAR_BOTTOM_MARGIN
                    - FloatingBarViewUserInterface.COMPONENT_HEIGHT
                    - FloatingBarViewUserInterface.COMPONENT_TOP_MARGIN
                    - FloatingBarViewUserInterface.COMPONENT_BOTTOM_MARGIN);
        }
        main.setMaxHeight(componentHeight);
        main.setAlignment(Pos.CENTER_LEFT);

        HBox hbox = new HBox();
        hbox.setMinSize(_taskViewWidth, componentHeight);
        hbox.setId("cssHelpComponentHighLighter");

        HBox link = new HBox();
        link.setMinHeight(2);
        link.setMaxHeight(2);
        link.setMinWidth(20);
        link.setId("cssHelpComponentLinker");

        VBox descriptionBox = new VBox();
        descriptionBox.setMaxWidth(DESCRIPTION_BOX_SMALL_WIDTH);
        descriptionBox.setMaxHeight(DESCRIPTION_BOX_HEIGHT);
        descriptionBox.setId("cssHelpComponentDescriptionBox");

        Label title = new Label(HELP_DESCRIPTION_TASK_VIEW_TITLE);
        title.setFont(FONT_LABEL_TITLE);
        title.setId("cssHelpTitle");
        descriptionBox.getChildren().add(title);

        Label descLabel = new Label(HELP_DESCRIPTION_TASK_VIEW);
        descLabel.setWrapText(true);
        descLabel.setFont(FONT_LABEL);
        VBox.setMargin(descLabel, new Insets(MARGIN, MARGIN, MARGIN, MARGIN));
        VBox.setMargin(title, new Insets(MARGIN, MARGIN, MARGIN, MARGIN));
        descriptionBox.getChildren().add(descLabel);

        main.getChildren().add(hbox);
        main.getChildren().add(link);
        main.getChildren().add(descriptionBox);
        main.setTranslateX(
                DescriptionComponent.CONPONENT_WIDTH + DescriptionComponent.CONPONENT_RIGHT_MARGIN);
        main.setTranslateY(FloatingBarViewUserInterface.COMPONENT_HEIGHT);
        return main;
    }

    public HBox buildDescriptionHelp() {
        HBox main = new HBox();

        double componentHeight = 0;
        if (_isFixed) {
            componentHeight = (int) (_screenBounds.getHeight() - PrimaryUserInterface.COMMAND_BAR_HEIGTH
                    - PrimaryUserInterface.COMMAND_BAR_BOTTOM_MARGIN
                    - PrimaryUserInterface.COMMAND_BAR_TOP_MARGIN
                    - FloatingBarViewUserInterface.COMPONENT_HEIGHT
                    - FloatingBarViewUserInterface.COMPONENT_BOTTOM_MARGIN);
        } else {
            componentHeight = (int) (_screenBounds.getHeight() - PrimaryUserInterface.COMMAND_BAR_HEIGTH
                    - PrimaryUserInterface.COMMAND_BAR_TOP_MARGIN
                    - PrimaryUserInterface.COMMAND_BAR_BOTTOM_MARGIN
                    - FloatingBarViewUserInterface.COMPONENT_HEIGHT
                    - FloatingBarViewUserInterface.COMPONENT_TOP_MARGIN
                    - FloatingBarViewUserInterface.COMPONENT_BOTTOM_MARGIN);
        }
        main.setMaxHeight(componentHeight);
        main.setAlignment(Pos.CENTER_LEFT);

        HBox hbox = new HBox();
        hbox.setMinSize(DescriptionComponent.CONPONENT_WIDTH, componentHeight);
        hbox.setId("cssHelpComponentHighLighter");

        HBox link = new HBox();
        link.setMinHeight(LINE_SIZE);
        link.setMaxHeight(LINE_SIZE);
        link.setMinWidth(LINE_LENGTH);
        link.setId("cssHelpComponentLinker");

        VBox descriptionBox = new VBox();
        descriptionBox.setMaxWidth(DESCRIPTION_BOX_WIDTH);
        descriptionBox.setMaxHeight(DESCRIPTION_BOX_HEIGHT);
        descriptionBox.setId("cssHelpComponentDescriptionBox");

        Label title = new Label(HELP_DESCRIPTION_DESCRIPTION_COMPONENT_TITLE);
        title.setFont(FONT_LABEL_TITLE);
        title.setId("cssHelpTitle");
        descriptionBox.getChildren().add(title);

        Label descLabel = new Label(HELP_DESCRIPTION_DESCRIPTION_COMPONENT);
        descLabel.setFont(FONT_LABEL);
        descLabel.setWrapText(true);
        VBox.setMargin(descLabel, new Insets(MARGIN, MARGIN, MARGIN, MARGIN));
        VBox.setMargin(title, new Insets(MARGIN, MARGIN, MARGIN, MARGIN));
        descriptionBox.getChildren().add(descLabel);

        main.getChildren().add(hbox);
        main.getChildren().add(link);
        main.getChildren().add(descriptionBox);
        main.setTranslateY(FloatingBarViewUserInterface.COMPONENT_HEIGHT);
        return main;
    }

    public VBox buildfloatingBarHelp() {
        VBox main = new VBox();
        main.setAlignment(Pos.TOP_CENTER);

        HBox hbox = new HBox();
        hbox.setPrefSize(_stageWidth, FloatingBarViewUserInterface.COMPONENT_HEIGHT);
        hbox.setId("cssHelpComponentHighLighter");

        HBox link = new HBox();
        link.setPrefHeight(LINE_LENGTH);
        link.setMaxWidth(LINE_SIZE);
        link.setId("cssHelpComponentLinker");

        VBox descriptionBox = new VBox();
        descriptionBox.setMaxWidth(DESCRIPTION_BOX_WIDTH);
        descriptionBox.setId("cssHelpComponentDescriptionBox");

        Label title = new Label(HELP_DESCRIPTION_FLOATING_BAR_TITLE);
        title.setFont(FONT_LABEL_TITLE);
        title.setId("cssHelpTitle");
        descriptionBox.getChildren().add(title);

        Label descLabel = new Label(HELP_DESCRIPTION_FLOATING_BAR);
        descLabel.setFont(FONT_LABEL);
        descLabel.setWrapText(true);
        VBox.setMargin(descLabel, new Insets(MARGIN, MARGIN, MARGIN, MARGIN));
        VBox.setMargin(title, new Insets(MARGIN, MARGIN, MARGIN, MARGIN));
        descriptionBox.getChildren().add(descLabel);

        main.getChildren().add(hbox);
        main.getChildren().add(link);
        main.getChildren().add(descriptionBox);
        return main;
    }

    public VBox buildCommandBarHelp() {
        VBox main = new VBox();
        main.setAlignment(Pos.TOP_CENTER);

        HBox hbox = new HBox();
        hbox.setPrefSize(_stageWidth, PrimaryUserInterface.COMMAND_BAR_HEIGTH);
        hbox.setId("cssHelpComponentHighLighter");

        HBox link = new HBox();
        link.setPrefHeight(LINE_LENGTH);
        link.setMaxWidth(LINE_SIZE);
        link.setId("cssHelpComponentLinker");

        VBox descriptionBox = new VBox();
        descriptionBox.setMaxWidth(DESCRIPTION_BOX_WIDTH);
        descriptionBox.setMaxHeight(DESCRIPTION_BOX_HEIGHT);
        descriptionBox.setMinHeight(DESCRIPTION_BOX_HEIGHT);
        descriptionBox.setId("cssHelpComponentDescriptionBox");

        Label title = new Label(HELP_DESCRIPTION_COMMAND_BAR_TITLE);
        title.setFont(FONT_LABEL_TITLE);
        title.setId("cssHelpTitle");
        descriptionBox.getChildren().add(title);

        Label descLabel = new Label(HELP_DESCRIPTION_COMMAND_BAR);
        descLabel.setFont(FONT_LABEL);
        descLabel.setWrapText(true);
        VBox.setMargin(descLabel, new Insets(MARGIN, MARGIN, MARGIN, MARGIN));
        VBox.setMargin(title, new Insets(MARGIN, MARGIN, MARGIN, MARGIN));
        descriptionBox.getChildren().add(descLabel);

        main.getChildren().add(descriptionBox);
        main.getChildren().add(link);
        main.getChildren().add(hbox);
        main.setTranslateY(_stageHeight - PrimaryUserInterface.COMMAND_BAR_HEIGTH - DESCRIPTION_BOX_HEIGHT
                - LINE_LENGTH);

        return main;
    }

    /**
     * Updates the selector by the value and changes the userInterface.
     */
    public void update(int value) {
        if (_stage.isShowing()) {
            int index = _selector + value;
            if (index < 0) {
            } else if (index >= MAX_ITEMS) {
            } else {
                _selector = index;
            }
            updateHelpPrompt();
        }
    }

    private void updateHelpPrompt() {
        _mainPanel.getChildren().clear();
        _mainPanel.getChildren().add(_items[_selector]);
    }

    public void updateTranslateY(double posY) {

    }

    public boolean toggleHelpView() {
        if (_stage.isShowing()) {
            hide();
            return false;
        } else {
            show();
            updateHelpPrompt();
            return true;
        }
    }

    public void show() {
        _stage.show();
    }

    public void hide() {
        _stage.hide();
        _selector = 0;
        updateHelpPrompt();
    }

    public void changeTheme(String styleSheet) {
        _stage.getScene().getStylesheets().clear();
        _styleSheet = styleSheet;
        _stage.getScene().getStylesheets().add(styleSheet);
    }

    public void destory() {
        _myInstance = null;
        _stage.close();
    }

}
```
###### src\userinterface\PrimaryUserInterface.java
``` java
 * 
 *          This class is the main UserInterface class, handles the inputs from
 *          user and relays them to the other components.
 */
package userinterface;

import java.util.ArrayList;

import entity.ResultSet;
import entity.TaskEntity;
import javafx.application.Application;
import javafx.event.EventHandler;
import javafx.geometry.Rectangle2D;
import javafx.scene.Scene;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.VBox;
import javafx.stage.Screen;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import logic.TaskUtils;
import parser.InputParser;
import parser.Pair;
import parser.CommandParser.COMMAND;
import userinterface.CommandBar;
import userinterface.UserInterfaceController;

public class PrimaryUserInterface extends Application {

    static final int PREFERED_WINDOW_WIDTH = 600;
    static final double PREFERED_WINDOW_SCALE = 0.8;

    private static final int SAME = 0;
    private static final int ZERO = 0;

    // Controls
    private static final int CTRL_UP_ARROW_KEY = -1;
    private static final int CTRL_DOWN_ARROW_KEY = 1;
    private static final int CTRL_LEFT_ARROW_KEY = -1;
    private static final int CTRL_RIGHT_ARROW_KEY = 1;

    static final int TYPE_1 = 0;
    static final int TYPE_2 = 1;

    // CommandBar dimensions.
    static final int COMMAND_BAR_HEIGTH = 70;
    static final int COMMAND_BAR_TOP_MARGIN = 10;
    static final int COMMAND_BAR_BOTTOM_MARGIN = 40;
    static final int TWO = 2;

    // Font and style.
    static final String FONT_DEFAULT = "lucida sans";
    static final String FONT_TITLE_LABLES = "lucida sans";
    static final int DEFAULT_FONT_SIZE = 24;

    private static final String[] STYLES = { "default.css", "blackandwhite.css", "red.css", "pastel.css" };
    private String _styleSheet = STYLES[ZERO];
    private int _styleSheetSelector = ZERO;

    private double _commandBarWidth;
    private Rectangle2D _screenBounds;
    private Stage _primaryStage;
    private CommandBar _commandBar;
    private boolean _isFixedSize = false;
    private UserInterfaceController uiController;
    private EventHandler<MouseEvent> _mainEventHandler;

    /**
     * This Constructor is called during JavaFX launch(). Determines user screen
     * size to set fixed value or scale value.
     */
    public PrimaryUserInterface() {
        _screenBounds = Screen.getPrimary().getVisualBounds();
        _commandBarWidth = _screenBounds.getWidth() * PREFERED_WINDOW_SCALE;
        if (_screenBounds.getWidth() * PREFERED_WINDOW_SCALE <= PREFERED_WINDOW_WIDTH) {
            _isFixedSize = true;
        }
    }

    /**
     * initialize stage and components, this is the first method JavaFx calls.
     * Initialize commandBar and components in commandBar as primary UI.
     * 
     */
    @Override
    public void start(Stage primaryStage) throws Exception {
        InputParser parser = new InputParser("");
        _primaryStage = primaryStage;
        _commandBar = CommandBar.getInstance(_commandBarWidth, COMMAND_BAR_HEIGTH);
        initializeControls();
        initializePrimaryStage(primaryStage);
        initializeUiController(primaryStage);
        ResultSet resultSet = uiController.isFileLoadedProper();
        if (resultSet != null) {
            _commandBar.showFeedBackMessage(COMMAND.LOADFROM, resultSet, null);
        }
        focus();
    }

    /**
     * set up the primary stage dimensions and display it on screen.
     * 
     * @param primaryStage.
     */
    private void initializePrimaryStage(Stage primaryStage) {
        primaryStage.setAlwaysOnTop(true);
        primaryStage.initStyle(StageStyle.TRANSPARENT);
        primaryStage.setX((_screenBounds.getWidth() - _commandBarWidth) / TWO);
        primaryStage.setY((_screenBounds.getHeight() - COMMAND_BAR_HEIGTH - COMMAND_BAR_BOTTOM_MARGIN));
        Scene primaryScene = new Scene(initializeRootLayout(), _commandBarWidth, COMMAND_BAR_HEIGTH);
        primaryScene.getStylesheets().add(_styleSheet);
        primaryStage.setScene(primaryScene);
        _primaryStage.show();
    }

    /**
     * initialize the content inside the primary stage, VBox used as rootLayout
     * 
     * @return mainLayout.
     */
    private VBox initializeRootLayout() {
        VBox commandBarPane = _commandBar.getCommandBar();
        return commandBarPane;
    }

    /**
     * initialize UserInterfaceController
     * 
     * @param primaryStage.
     */
    private void initializeUiController(Stage primaryStage) {
        uiController = UserInterfaceController.getInstance(primaryStage);
        String theme = uiController.loadTheme();
        if (isValidTheme(theme)) {
            _styleSheet = theme;
            _primaryStage.getScene().getStylesheets().clear();
            _primaryStage.getScene().getStylesheets().add(theme);
        }
        uiController.initializeInterface(_screenBounds, _isFixedSize, _styleSheet, _mainEventHandler);
    }

    /**
     * initialize the main controls for the application. _mainEventHandler is
     * the event thats get mouse click on any panel of the application and set
     * focus to the command bar.
     * 
     * 
     */
    private void initializeControls() {
        _mainEventHandler = new EventHandler<MouseEvent>() {
            public void handle(MouseEvent arg0) {
                focus();
            }
        };
        EventHandler<KeyEvent> commandBarMainEventHandler = new EventHandler<KeyEvent>() {
            public void handle(KeyEvent event) {
                processKeyPress(_commandBar.getTextField(), event);
            }
        };
        EventHandler<KeyEvent> releaseEventHandler = new EventHandler<KeyEvent>() {
            public void handle(KeyEvent event) {
                processKeyRelease(_commandBar.getTextField(), event);
            }
        };
        _commandBar.setTextFieldHandler(commandBarMainEventHandler, releaseEventHandler);
    }

    private void processKeyRelease(TextField textField, KeyEvent event) {
        _commandBar.release();
        if (event.getCode().compareTo(KeyCode.TAB) == SAME) {
            _commandBar.changeSelector();
        }
    }

```
###### src\userinterface\PrimaryUserInterface.java
``` java
    /**
     * Process the event receive to and execute the next action.
     * 
     * @param event
     */
    private void processControls(KeyEvent event) {
        KeyCode keyCode = event.getCode();
        if (keyCode.isFunctionKey()) {
            processFunctionKeys(keyCode);
        } else if (!event.isControlDown()) {
            processControlKeyNotPressed(keyCode);
        } else if (event.isControlDown()) {
            processControlKeyPressed(keyCode);
        }
    }

    private void processFunctionKeys(KeyCode keyCode) {
        if (keyCode.compareTo(KeyCode.F1) == SAME) {
            uiController.showHelpView();
        } else if (keyCode.compareTo(KeyCode.F2) == SAME) {
            uiController.hide();
        } else if (keyCode.compareTo(KeyCode.F3) == SAME) {
            uiController.show();
        } else if (keyCode.compareTo(KeyCode.F4) == SAME) {
            executeChangeTheme();
        } else if (keyCode.compareTo(KeyCode.F5) == SAME) {
            uiController.destroy();
            uiController.initializeInterface(_screenBounds, _isFixedSize, _styleSheet, _mainEventHandler);
            resetCommandInput();
        }
    }

    private void processControlKeyPressed(KeyCode keyCode) {
        if (keyCode.compareTo(KeyCode.DOWN) == SAME) {
            uiController.stopScrollingAnimation();
            uiController.updateComponents(CTRL_DOWN_ARROW_KEY);
        } else if (keyCode.compareTo(KeyCode.UP) == SAME) {
            uiController.stopScrollingAnimation();
            uiController.updateComponents(CTRL_UP_ARROW_KEY);
        } else if (keyCode.compareTo(KeyCode.RIGHT) == SAME) {
            uiController.changeView(CTRL_RIGHT_ARROW_KEY);
        } else if (keyCode.compareTo(KeyCode.LEFT) == SAME) {
            uiController.changeView(CTRL_LEFT_ARROW_KEY);
        }
    }

    private void processControlKeyNotPressed(KeyCode keyCode) {
        if (keyCode.compareTo(KeyCode.UP) == SAME) {
            _commandBar.getPrevCommand();
        } else if (keyCode.compareTo(KeyCode.DOWN) == SAME) {
            _commandBar.getNextCommand();
        } else if (keyCode.compareTo(KeyCode.LEFT) == SAME) {
            uiController.updateHelpView(CTRL_LEFT_ARROW_KEY);
        } else if (keyCode.compareTo(KeyCode.RIGHT) == SAME) {
            uiController.updateHelpView(CTRL_RIGHT_ARROW_KEY);
        }
    }

    /**
     * This method set the focus back on to the commandBar.
     * 
     */
    private void focus() {
        _primaryStage.requestFocus();
        _commandBar.focus();
    }

    private void executeExit() {
        uiController.saveStuff();
        System.exit(0);
    }

    /**
     * Get feedBack message and show user.
     */
    private void executeInvalidCommand() {
        _commandBar.showFeedBackMessage(COMMAND.INVALID, null, null);
    }

```
###### src\userinterface\PrimaryUserInterface.java
``` java

    private void executeChangeTheme() {
        _styleSheetSelector++;
        if (_styleSheetSelector >= STYLES.length) {
            _styleSheetSelector = ZERO;
        }
        _styleSheet = STYLES[_styleSheetSelector];
        _primaryStage.getScene().getStylesheets().clear();
        _primaryStage.getScene().getStylesheets().add(_styleSheet);
        uiController.changeTheme(_styleSheet);
    }

    private void executeChangeTheme(String themeChange) {
        if (isValidTheme(themeChange)) {
            _styleSheet = themeChange;
            _primaryStage.getScene().getStylesheets().clear();
            _primaryStage.getScene().getStylesheets().add(_styleSheet);
            ResultSet resultSet = uiController.changeTheme(_styleSheet);
            if (resultSet.isSuccess()) {
                resetCommandInput();
            }
            _commandBar.showFeedBackMessage(COMMAND.THEME, resultSet, getStyleSheetList());
        } else {
            _commandBar.showFeedBackMessage(COMMAND.THEME, null, getStyleSheetList());
        }
    }

    private boolean isValidTheme(String theme) {
        if (theme == null) {
            return false;
        }
        for (int i = 0; i < STYLES.length; i++) {
            if (STYLES[i].equals(theme)) {
                _styleSheetSelector = i;
                return true;
            }
        }
        return false;
    }

    private String getStyleSheetList() {
        String styleList = "";
        for (int i = 0; i < STYLES.length; i++) {
            styleList = styleList.concat(STYLES[i]);
            if (i < STYLES.length - 1) {
                styleList = styleList.concat(", ");
            }
        }
        return styleList;
    }

    /**
     * Reset the layout and style of the commandBar for new input. usually
     * called after a success in executing a command.
     * 
     */
    private void resetCommandInput() {
        _commandBar.reset();
        focus();
    }
}
```
###### src\userinterface\ScrollTaskAnimation.java
``` java
 * 
 *          This is the animation class that provides the service to animate the
 *          scrolling of task.
 */
package userinterface;

import javafx.application.Platform;
import javafx.concurrent.Service;
import javafx.concurrent.Task;

public class ScrollTaskAnimation extends Service<Integer> {

    private int _currentIndex;
    private int _indexToGo;
    private int _direction;
    private int _numberOfMilliSecondsBeforeIncreaseSpeed = 300;
    private UserInterfaceController _ui;
    private static ScrollTaskAnimation _myInstance;
    private Runnable _thread;

    /**
     * Return an instance of the animation, existing Thread will be discarded.
     * 
     * @param currentIndex
     * @param indexToGo
     * @param userInterfaceController
     * 
     * @return instance
     */
    public static ScrollTaskAnimation getInstance(int currentIndex, int indexToGo,
            UserInterfaceController userInterfaceController) {
        if (_myInstance != null) {
            if (_myInstance.isRunning()) {
                _myInstance.cancel();
            }
        }
        _myInstance = new ScrollTaskAnimation(currentIndex, indexToGo, userInterfaceController);
        return _myInstance;
    }

    private ScrollTaskAnimation(int currentIndex, int indexToGo,
            UserInterfaceController userInterfaceController) {
        this._currentIndex = currentIndex;
        this._indexToGo = indexToGo;
        _ui = userInterfaceController;
    }

    @Override
    protected Task<Integer> createTask() {
        return new MyTask();
    }

    private class MyTask extends Task<Integer> {
        @Override
        protected Integer call() throws Exception {
            _direction = 0;
            if (_currentIndex < _indexToGo) {
                _direction = 1;
            } else {
                _direction = -1;
            }
            long startTime = System.currentTimeMillis();
            while (true) {
                if (isCompleteAnimate()) {
                    break;
                }
                startTime = checkTime(startTime);
                if (_thread == null) {
                    _thread = new Runnable() {
                        public void run() {
                            checkExceed();
                            _ui.updateComponents(_direction);
                            _currentIndex = _currentIndex + _direction;
                            _thread = null;
                        }
                    };
                    Platform.runLater(_thread);
                }
                Thread.sleep(80);
            }
            return 1;
        }
    }

    /**
     * Checks if the direction to move will exceed the position required, if so,
     * set direction to be the difference.
     */
    public void checkExceed() {
        if (_direction > 0) {
            if (_currentIndex + _direction > _indexToGo) {
                _direction = _indexToGo - _currentIndex;
            }
        } else if (_direction < 0) {
            if (_currentIndex + _direction < _indexToGo) {
                _direction = -(_currentIndex - _indexToGo);
            }
        }
    }

    public boolean isCompleteAnimate() {
        if (_direction > 0) {
            if (_currentIndex >= _indexToGo) {
                return true;
            }
        } else if (_direction < 0) {
            if (_currentIndex <= _indexToGo) {
                return true;
            }
        }
        return false;
    }

    /**
     * Check the time pass since the animation stars. if its over the time,
     * increase speed of animation.
     * 
     * @param startTime
     * @return time of change
     */
    private long checkTime(long startTime) {
        long currTime = System.currentTimeMillis();
        if (currTime - startTime > _numberOfMilliSecondsBeforeIncreaseSpeed) {
            increaseSpeed();
            return currTime;
        }
        return startTime;
    }

    private void increaseSpeed() {
        if (_direction < 0) {
            _direction--;
        } else if (_direction > 0) {
            _direction++;
        }
    }
}
```
###### src\userinterface\SearchUserInterface.java
``` java
 * 
 *          This class build and manage the search panel where it shows the
 *          search results.
 */
package userinterface;

import java.util.ArrayList;
import entity.TaskEntity;
import javafx.event.EventHandler;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.geometry.Rectangle2D;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.HBox;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import javafx.stage.Window;

public class SearchUserInterface implements ViewInterface {

    private static SearchUserInterface _myInstance;

    private Stage _stage;
    private int _stageWidth;
    private int _stageHeight;
    private int _windowPosX;
    private int _windowPosY;

    private static final String CSS_LABEL = "cssLabelsSearchView";

    // Font
    static final int FONT_SIZE_LABEL = 20;
    static final int FONT_SIZE_LABEL_DATE = 10;
    static final int FONT_SIZE_TASK = 12;
    static final int FONT_SIZE_INDEX = 8;
    private static final Font FONT_LABEL = new Font(PrimaryUserInterface.FONT_TITLE_LABLES, FONT_SIZE_LABEL);
    private static final Font FONT_TASK = new Font(PrimaryUserInterface.FONT_DEFAULT, FONT_SIZE_TASK);

    static final int LABEL_TITLE_HEIGHT = 30;
    static final int LABEL_TASK_HEIGHT = 25;
    private static final int THRESHOLD = 20;

    private String _styleSheet;

    private StackPane _mainVbox;
    private VBox _secondaryVbox;

    // variables to control items in floatingView.
    private int _startIndex = -1;
    private int _endIndex = -1;
    private int _selectedIndex = -1;

    private ArrayList<TaskEntity> _searchList;
    private ArrayList<HBox> _searchBoxes = new ArrayList<HBox>();

    /**
     * Create an instance of SearchUserInterface.
     * 
     * @param primaryStage
     * @param screenBounds
     * @param isFixedSize
     * @param styleSheet
     * @param mouseEvent
     * @return Instance of SearchUserInterface only if there isn't an instance
     *         already.
     */
    public static SearchUserInterface getInstance(Stage primaryStage, Rectangle2D screenBounds,
            boolean isFixedSize, String styleSheet, EventHandler<MouseEvent> mouseEvent) {
        if (_myInstance == null) {
            if (primaryStage == null || screenBounds == null) {
                return null;
            }
            _myInstance = new SearchUserInterface(primaryStage, screenBounds, isFixedSize, styleSheet,
                    mouseEvent);
            return _myInstance;
        }
        return null;
    }

    private SearchUserInterface(Stage primaryStage, Rectangle2D screenBounds, boolean isFixedSize,
            String styleSheet, EventHandler<MouseEvent> mouseEvent) {
        _styleSheet = styleSheet;
        initializeVaribles(screenBounds, isFixedSize);
        initializeStage(primaryStage, _windowPosX, _windowPosY, _stageWidth, _stageHeight, mouseEvent);
        buildComponent();
    }

    /**
     * Initialize view dimensions and position.
     */
    public void initializeVaribles(Rectangle2D screenBounds, boolean isFixedSize) {
        if (isFixedSize) {
            _stageWidth = (int) screenBounds.getWidth();
            _stageHeight = (int) (screenBounds.getHeight() - PrimaryUserInterface.COMMAND_BAR_HEIGTH
                    - PrimaryUserInterface.COMMAND_BAR_TOP_MARGIN
                    - PrimaryUserInterface.COMMAND_BAR_BOTTOM_MARGIN
                    - FloatingBarViewUserInterface.COMPONENT_HEIGHT
                    - FloatingBarViewUserInterface.COMPONENT_BOTTOM_MARGIN);
            _windowPosX = DescriptionComponent.CONPONENT_WIDTH + DescriptionComponent.CONPONENT_RIGHT_MARGIN;
            _windowPosY = (int) screenBounds.getHeight() - _stageHeight
                    - PrimaryUserInterface.COMMAND_BAR_HEIGTH - PrimaryUserInterface.COMMAND_BAR_TOP_MARGIN
                    - PrimaryUserInterface.COMMAND_BAR_BOTTOM_MARGIN;
        } else {
            _stageWidth = (int) (screenBounds.getWidth() * PrimaryUserInterface.PREFERED_WINDOW_SCALE);
            _stageHeight = (int) (screenBounds.getHeight() - PrimaryUserInterface.COMMAND_BAR_HEIGTH
                    - PrimaryUserInterface.COMMAND_BAR_TOP_MARGIN
                    - PrimaryUserInterface.COMMAND_BAR_BOTTOM_MARGIN
                    - FloatingBarViewUserInterface.COMPONENT_HEIGHT
                    - FloatingBarViewUserInterface.COMPONENT_TOP_MARGIN
                    - FloatingBarViewUserInterface.COMPONENT_BOTTOM_MARGIN);
            _windowPosX = (int) (screenBounds.getWidth()
                    - (screenBounds.getWidth() * PrimaryUserInterface.PREFERED_WINDOW_SCALE)) / 2;
            _windowPosY = (int) screenBounds.getHeight() - _stageHeight
                    - PrimaryUserInterface.COMMAND_BAR_HEIGTH - PrimaryUserInterface.COMMAND_BAR_TOP_MARGIN
                    - PrimaryUserInterface.COMMAND_BAR_BOTTOM_MARGIN;
        }
    }

    /**
     * Initialize the stage and the components in the stage.
     */
    public void initializeStage(Window owner, int applicationX, int applicationY, int stageWidth,
            int stageHeight, EventHandler<MouseEvent> mouseEvent) {
        _stage = new Stage();
        _stage.initOwner(owner);
        _stage.initStyle(StageStyle.TRANSPARENT);
        _stage.setX(applicationX);
        _stage.setY(applicationY);

        _mainVbox = new StackPane();
        _mainVbox.setPrefSize(stageWidth, stageHeight);
        _mainVbox.setId("cssRootSearchView");

        Scene scene = new Scene(_mainVbox, stageWidth, stageHeight);
        scene.getStylesheets().add(_styleSheet);
        scene.setFill(Color.TRANSPARENT);
        scene.setOnMousePressed(mouseEvent);
        _stage.setScene(scene);
    }

    /**
     * Builds the main skeleton structure, no items added to the structure yet.
     */
    private void buildComponent() {
        _mainVbox.getChildren().clear();
        _secondaryVbox = new VBox();
        _secondaryVbox.setMinHeight(_stageHeight - LABEL_TITLE_HEIGHT);
        _secondaryVbox.setMaxHeight(_stageHeight - LABEL_TITLE_HEIGHT);
        _secondaryVbox.setId("cssFloatingViewSecondaryBox");

        _mainVbox.getChildren().add(_secondaryVbox);
        HBox labelTitle = buildTilteLabel();
        _mainVbox.getChildren().add(labelTitle);
        StackPane.setAlignment(labelTitle, Pos.TOP_LEFT);
        StackPane.setAlignment(_secondaryVbox, Pos.TOP_LEFT);
    }

    /**
     * Check if there are items in the search list and build component
     * accordingly.
     * 
     * @param searchList
     */
    public void buildContent(ArrayList<TaskEntity> searchList) {
        _searchList = searchList;
        _searchBoxes = new ArrayList<HBox>();
        // when there are no floating task yet
        if (_searchList == null || _searchList.size() == 0) {
            buildHelpWithSearch();
        } else {
            buildSearchList(_searchList);
        }
    }

    /**
     * Builds the individual items in the search list and add them to the
     * skeleton component.
     * 
     * @param searchList
     */
    private void buildSearchList(ArrayList<TaskEntity> searchList) {
        _secondaryVbox.getChildren().clear();
        _selectedIndex = 0;
        _startIndex = 0;
        if (searchList.size() < THRESHOLD * 2) {
            _endIndex = searchList.size() - 1;
        } else {
            _endIndex = THRESHOLD * 2;
        }

        for (int i = _startIndex; i <= _endIndex; i++) {
            HBox item = buildIndividualSearchItem(searchList.get(i), i);
            _secondaryVbox.getChildren().add(item);
            _searchBoxes.add(item);
        }
        setSelected(0);
    }

    /**
     * Build a help message whent there are no search results.
     */
    private void buildHelpWithSearch() {
        _secondaryVbox.getChildren().clear();
        Label helpLabel = new Label("Start searching by typing search in the command bar");
        helpLabel.getStyleClass().add(CSS_LABEL);
        helpLabel.setMinWidth(_stageWidth);
        helpLabel.setMinHeight(_stageHeight - LABEL_TITLE_HEIGHT);
        helpLabel.setAlignment(Pos.CENTER);
        _secondaryVbox.getChildren().add(helpLabel);
    }

    /**
     * Builds the individual item base on the input TaskEntity.
     * 
     * @param task
     * @param index
     * @return HBox
     */
    private HBox buildIndividualSearchItem(TaskEntity task, int index) {
        HBox parentBox = new HBox();

        VBox parentBoxChild = new VBox();
        parentBoxChild.setMinWidth(_stageWidth);
        parentBoxChild.setMaxWidth(_stageWidth);

        HBox top = new HBox();
        top.setMinWidth(_stageWidth);
        top.setMaxWidth(_stageWidth);

        Label indexLabel = new Label("ID" + Integer.toString(index));
        indexLabel.getStyleClass().add(CSS_LABEL);
        indexLabel.setMinHeight(LABEL_TASK_HEIGHT);
        indexLabel.setMinWidth(60);
        indexLabel.setAlignment(Pos.CENTER);
        indexLabel.setFont(Font.font(PrimaryUserInterface.FONT_DEFAULT, FontWeight.BOLD, FONT_SIZE_TASK));
        top.getChildren().add(indexLabel);

        Label timeLabel = new Label();
        timeLabel.setText(task.getTime());
        timeLabel.getStyleClass().add(CSS_LABEL);
        timeLabel.setMinHeight(LABEL_TASK_HEIGHT);
        timeLabel.setAlignment(Pos.CENTER);
        timeLabel.setFont(FONT_TASK);
        HBox.setMargin(timeLabel, new Insets(0, 10, 0, 0));
        top.getChildren().add(timeLabel);

        if (task.getAssociationState() == TaskEntity.PROJECT_HEAD) {
            top.getChildren().add(StarPane.createStar(LABEL_TASK_HEIGHT));
        }

        Label nameLabel = new Label();
        nameLabel.getStyleClass().add(CSS_LABEL);
        nameLabel.setText(task.getName());
        nameLabel.setMinHeight(LABEL_TASK_HEIGHT);
        nameLabel.setAlignment(Pos.CENTER);
        nameLabel.setFont(FONT_TASK);
        HBox.setMargin(nameLabel, new Insets(0, 10, 0, 0));
        top.getChildren().add(nameLabel);
        top.setMinHeight(LABEL_TASK_HEIGHT);

        HBox mid = new HBox();
        Label indexPlaceHolder = new Label();
        indexPlaceHolder.getStyleClass().add(CSS_LABEL);
        indexPlaceHolder.setMinWidth(50);
        mid.getChildren().add(indexPlaceHolder);

        Text description = new Text();
        description.getStyleClass().add(CSS_LABEL);
        description.setText(task.getDescription());
        description.setWrappingWidth(_stageWidth - 50);
        mid.getChildren().add(description);
        mid.setMinHeight(description.getBoundsInLocal().getHeight() + 10);

        HBox btm = new HBox();
        Label indexPlaceHolder2 = new Label();
        indexPlaceHolder2.getStyleClass().add(CSS_LABEL);
        indexPlaceHolder2.setMinWidth(50);
        btm.getChildren().add(indexPlaceHolder2);

        Text hashtags = new Text();
        hashtags.getStyleClass().add(CSS_LABEL);
        hashtags.setText(task.getHashtags());
        hashtags.setWrappingWidth(_stageWidth - 50);
        btm.getChildren().add(hashtags);
        btm.setMinHeight(hashtags.getBoundsInLocal().getHeight() + 10);

        parentBoxChild.getChildren().add(top);
        parentBoxChild.getChildren().add(mid);
        parentBoxChild.getChildren().add(btm);
        parentBoxChild.setMinHeight(top.getMinHeight() + mid.getMinHeight() + btm.getMinHeight());
        parentBox.getChildren().add(parentBoxChild);
        parentBox.setMinHeight(parentBoxChild.getMinHeight());
        return parentBox;
    }

    public HBox buildTilteLabel() {
        HBox titleLableBox = new HBox();
        titleLableBox.setId("cssSearchTitle");
        titleLableBox.setMinWidth(_stageWidth);
        titleLableBox.setMinHeight(LABEL_TITLE_HEIGHT);
        titleLableBox.setMaxHeight(LABEL_TITLE_HEIGHT);

        Label searchTitle = new Label("Search View");
        searchTitle.getStyleClass().add(CSS_LABEL);
        searchTitle.setMinWidth(_stageWidth);
        searchTitle.setFont(FONT_LABEL);
        searchTitle.setMinHeight(LABEL_TITLE_HEIGHT);
        searchTitle.setMaxHeight(LABEL_TITLE_HEIGHT);
        HBox.setMargin(searchTitle, new Insets(0, 0, 0, 30));

        titleLableBox.getChildren().add(searchTitle);
        return titleLableBox;
    }

    /**
     * Updates the selector index by the amount of value. Items are added and
     * removed to maintain THRESHOLD.
     */
    public void update(int value) {
        if (value > 0)// ctrl down
        {
            if (_endIndex + 1 < _searchList.size()) {
                if (_selectedIndex - _startIndex >= THRESHOLD) {
                    removeFirstTask();
                    addLastItem();
                }
            }
        } else if (value < 0) {
            if (_startIndex > 0) {
                if (_endIndex - _selectedIndex >= THRESHOLD) {
                    removeLastTask();
                    addFirstItem();
                }
            }
        }
    }

    /**
     * Adds a new search item in the beginning of the list.
     */
    private void addFirstItem() {
        _startIndex--;
        HBox item = buildIndividualSearchItem(_searchList.get(_startIndex), _startIndex);
        _searchBoxes.add(0, item);
        _secondaryVbox.getChildren().add(0, item);
    }

    /**
     * Removes the last component in the search list.
     */
    private void removeLastTask() {
        _endIndex--;
        HBox itemToRemove = _searchBoxes.remove(_searchBoxes.size() - 1);
        _secondaryVbox.getChildren().remove(itemToRemove);
    }

    /**
     * Adds a new search item in the end of the list.
     */
    private void addLastItem() {
        _endIndex++;
        HBox item = buildIndividualSearchItem(_searchList.get(_endIndex), _endIndex);
        _searchBoxes.add(item);
        _secondaryVbox.getChildren().add(item);
    }

    /**
     * Removes the first component in the search list.
     */
    private void removeFirstTask() {
        _startIndex++;
        HBox item = _searchBoxes.remove(0);
        _secondaryVbox.getChildren().remove(item);
    }

    /**
     * Sets the selected item base on value.
     * 
     * @param value
     */
    public void setSelected(int value) {
        int temp = _selectedIndex + value;
        if (isBetweenRange(temp)) {
            HBox prevItem = _searchBoxes.get(_selectedIndex - _startIndex);
            prevItem.setId("");
            _selectedIndex = temp;
            HBox item = _searchBoxes.get(_selectedIndex - _startIndex);
            item.setId("cssSearchSelected");
            translateY(calculateTopHeight(_selectedIndex - _startIndex));
        }
    }

    /**
     * Calculates the height above the selected component.
     * 
     * @param index
     * @return height
     */
    public double calculateTopHeight(int index) {
        double posY = 0;
        for (int i = 0; i <= index; i++) {
            posY += _searchBoxes.get(i).getMinHeight();
        }
        return posY;
    }

    public void translateY(double itemHeight) {
        int entireAreaHeight = _stageHeight - LABEL_TITLE_HEIGHT;
        double posY = LABEL_TITLE_HEIGHT;
        if (itemHeight < entireAreaHeight) {

        } else {
            posY -= (itemHeight - entireAreaHeight);
        }
        _secondaryVbox.setTranslateY(posY);
    }

    /**
     * Check if the index is between _startIndex and _endIndex.
     * 
     * @param index
     * @return true only if index is bewteen the range
     */
    public boolean isBetweenRange(int index) {
        if (index >= _startIndex && index <= _endIndex) {
            return true;
        }
        return false;
    }

    public void show() {
        _stage.show();
    }

    public void hide() {
        _stage.hide();
    }

    public void updateTranslateY(double posY) {
    }

    public void changeTheme(String styleSheet) {
        _stage.getScene().getStylesheets().clear();
        _styleSheet = styleSheet;
        _stage.getScene().getStylesheets().add(styleSheet);
    }

    /**
     * Gets the task that is current selected.
     * 
     * @return TaskEntity
     */
    public TaskEntity processEnter() {
        if (_selectedIndex > -1 && _selectedIndex < _searchList.size()) {
            return _searchList.get(_selectedIndex);
        }
        return null;
    }

    public void destoryStage() {
        _myInstance = null;
        _stage.close();
    }

}
```
###### src\userinterface\TaskViewAnimation.java
``` java
 * 
 *          This is the animation class that provides the service to animate the
 *          TaskView to the ExpandedView.
 */
package userinterface;

import javafx.application.Platform;
import javafx.concurrent.Service;
import javafx.concurrent.Task;

public class TaskViewAnimation extends Service<Integer> {

    // This variable to keep track if the animation is already in process
    private static TaskViewAnimation _myInstances;

    private static final int DIRECTION_TO_TASK_VIEW = 1;
    private static final int DIRECTION_TO_EXPANED_VIEW = -1;

    private UserInterfaceController _ui;
    private boolean _isDoneTranslatingToOtherView;
    private int _direction;

    /**
     * Returns a new instance of the thread, existing thread will stop running.
     * This method ensures only 1 instacne of the thread is runnign at any given
     * period.
     * 
     * @param userInterfaceInstance
     * @param direction
     *            - animate to TaskView or ExpandedView
     * 
     * @return instance
     */
    public static TaskViewAnimation getInstance(UserInterfaceController ui, int direction) {
        if (_myInstances != null) {
            if (_myInstances.isRunning()) {
                _myInstances.cancel();
            }
        }
        _myInstances = new TaskViewAnimation(ui, direction);
        return _myInstances;
    }

    private TaskViewAnimation(UserInterfaceController userInterfaceController, int direction) {
        _ui = userInterfaceController;
        _isDoneTranslatingToOtherView = false;
        _direction = direction;
    }

    @Override
    protected Task<Integer> createTask() {
        return new MyTask();
    }

    private class MyTask extends Task<Integer> {
        @Override
        protected Integer call() throws Exception {
            while (!_isDoneTranslatingToOtherView) {
                Thread.sleep(10);
                Platform.runLater(new Runnable() {
                    public void run() {
                        if (_direction == DIRECTION_TO_EXPANED_VIEW) {
                            _isDoneTranslatingToOtherView = _ui.isAtExpanedView();
                        } else if (_direction == DIRECTION_TO_TASK_VIEW) {
                            _isDoneTranslatingToOtherView = _ui.isAtTaskView();
                        }
                    }
                });
            }
            return null;
        }

    }
}
```
###### src\userinterface\TaskViewUserInterface.java
``` java
 * 
 *          This class builds the interface in the main view.
 */
package userinterface;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;

import entity.TaskEntity;
import javafx.event.EventHandler;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.geometry.Rectangle2D;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import javafx.stage.Window;
import parser.ReverseParser;
import userinterface.DescriptionLabel;

public class TaskViewUserInterface implements ViewInterface {

    private static TaskViewUserInterface _myInstance;

    private static final int GAP_SIZE = 10;
    private static final int THRESHOLD = 50;

    static final int TASK_VIEW_LABEL_HEIGHT = 50;
    static final int TASK_VIEW_ITEM_HEIGHT = 30;
    static final int DETAILED_VIEW_ITEM_HEIGHT = 50;
    static final int SELECTOR_POSITION_Y = TASK_VIEW_LABEL_HEIGHT + TASK_VIEW_ITEM_HEIGHT * 2;

    // Font
    static final int FONT_SIZE_LABEL_DATE = 24;
    static final int FONT_SIZE_TASK = 12;
    static final int FONT_SIZE_INDEX = 8;
    private static final Font FONT_LABEL = new Font(PrimaryUserInterface.FONT_TITLE_LABLES,
            FONT_SIZE_LABEL_DATE);
    private static final Font FONT_TASK = new Font(PrimaryUserInterface.FONT_DEFAULT, FONT_SIZE_TASK);

    private static final String CSS_LABEL = "cssLabels";

    private Stage _stage;
    private int _stageWidth;
    private int _stageHeight;
    private int _windowPosX;
    private int _windowPosY;

    // variables to control items in taskView.
    private int _startIndex = -1;
    private int _endIndex = -1;
    private int _selectedIndex = -1;
    private int _individualItemWidth = -1;
    private double transLationY = 0;

    private int _view = UserInterfaceController.TASK_VIEW;

    private VBox _mainVbox; // main parent for items.
    private int _itemIndexCounter = 0;
    private String _styleSheet;

    private ReverseParser _reverseParser = new ReverseParser();

    // container to store current gridPanes builded for easy reference.
    private ArrayList<GridPane> _gridPanes = new ArrayList<GridPane>();
    private ArrayList<TaskEntity> workingList;

    /**
     * Create an instance of TaskViewUserInterface.
     * 
     * @param primaryStage
     * @param screenBounds
     * @param isFixedSize
     * @param styleSheet
     * @param mouseEvent
     * @return Instance of TaskViewUserInterface only if there isn't an instance
     *         already.
     */
    public static TaskViewUserInterface getInstance(Stage primaryStage, Rectangle2D screenBounds,
            boolean isFixedSize, String styleSheet, EventHandler<MouseEvent> mouseEvent) {
        if (_myInstance == null) {
            if (primaryStage == null || screenBounds == null) {
                return null;
            }
            _myInstance = new TaskViewUserInterface(primaryStage, screenBounds, isFixedSize, styleSheet,
                    mouseEvent);
            return _myInstance;
        }
        return null;
    }

    private TaskViewUserInterface(Stage primaryStage, Rectangle2D screenBounds, boolean isFixedSize,
            String styleSheet, EventHandler<MouseEvent> mouseEvent) {
        _styleSheet = styleSheet;
        initializeVaribles(screenBounds, isFixedSize);
        initializeStage(primaryStage, _windowPosX, _windowPosY, _stageWidth, _stageHeight, mouseEvent);
    }

    /**
     * Initialize view dimensions and position.
     */
    public void initializeVaribles(Rectangle2D screenBounds, boolean isFixedSize) {
        if (isFixedSize) {
            _stageWidth = (int) screenBounds.getWidth() - DescriptionComponent.CONPONENT_WIDTH
                    - DescriptionComponent.CONPONENT_RIGHT_MARGIN - DetailComponent.COMPONENT_WIDTH
                    - DetailComponent.COMPONENT_LEFT_MARGIN;
            _stageHeight = (int) (screenBounds.getHeight() - PrimaryUserInterface.COMMAND_BAR_HEIGTH
                    - PrimaryUserInterface.COMMAND_BAR_TOP_MARGIN
                    - PrimaryUserInterface.COMMAND_BAR_BOTTOM_MARGIN
                    - FloatingBarViewUserInterface.COMPONENT_HEIGHT
                    - FloatingBarViewUserInterface.COMPONENT_BOTTOM_MARGIN);
            _windowPosX = DescriptionComponent.CONPONENT_WIDTH + DescriptionComponent.CONPONENT_RIGHT_MARGIN;
            _windowPosY = (int) screenBounds.getHeight() - _stageHeight
                    - PrimaryUserInterface.COMMAND_BAR_HEIGTH - PrimaryUserInterface.COMMAND_BAR_TOP_MARGIN
                    - PrimaryUserInterface.COMMAND_BAR_BOTTOM_MARGIN;
        } else {
            _stageWidth = (int) (screenBounds.getWidth() * PrimaryUserInterface.PREFERED_WINDOW_SCALE)
                    - DescriptionComponent.CONPONENT_WIDTH - DescriptionComponent.CONPONENT_RIGHT_MARGIN
                    - DetailComponent.COMPONENT_WIDTH - DetailComponent.COMPONENT_LEFT_MARGIN;
            _stageHeight = (int) (screenBounds.getHeight() - PrimaryUserInterface.COMMAND_BAR_HEIGTH
                    - PrimaryUserInterface.COMMAND_BAR_TOP_MARGIN
                    - PrimaryUserInterface.COMMAND_BAR_BOTTOM_MARGIN
                    - FloatingBarViewUserInterface.COMPONENT_HEIGHT
                    - FloatingBarViewUserInterface.COMPONENT_TOP_MARGIN
                    - FloatingBarViewUserInterface.COMPONENT_BOTTOM_MARGIN);
            _windowPosX = (int) (screenBounds.getWidth()
                    - (screenBounds.getWidth() * PrimaryUserInterface.PREFERED_WINDOW_SCALE)) / 2
                    + DescriptionComponent.CONPONENT_WIDTH + DescriptionComponent.CONPONENT_RIGHT_MARGIN;
            _windowPosY = (int) screenBounds.getHeight() - _stageHeight
                    - PrimaryUserInterface.COMMAND_BAR_HEIGTH - PrimaryUserInterface.COMMAND_BAR_TOP_MARGIN
                    - PrimaryUserInterface.COMMAND_BAR_BOTTOM_MARGIN;
        }
        _individualItemWidth = _stageWidth;
    }

    /**
     * Initialize the stage and the components in the stage.
     */
    public void initializeStage(Window owner, int applicationX, int applicationY, int stageWidth,
            int stageHeight, EventHandler<MouseEvent> mouseEvent) {
        _stage = new Stage();
        _stage.initOwner(owner);
        _stage.initStyle(StageStyle.TRANSPARENT);
        _stage.setX(applicationX);
        _stage.setY(applicationY);

        StackPane mainPanel = new StackPane();
        mainPanel.setPrefSize(stageWidth, stageHeight);
        mainPanel.setId("cssTaskViewMainBackground");
        mainPanel.setAlignment(Pos.TOP_LEFT);

        _mainVbox = new VBox();
        mainPanel.getChildren().add(_mainVbox);

        Scene scene = new Scene(mainPanel, stageWidth, stageHeight);
        scene.getStylesheets().add(_styleSheet);
        scene.setFill(Color.TRANSPARENT);
        _stage.setScene(scene);
        scene.setOnMousePressed(mouseEvent);
    }

    public void show() {
        _stage.show();
    }

    public void hide() {
        _stage.hide();
    }

    public VBox getMainLayoutComponent() {
        return _mainVbox;
    }

    public int get_stageWidth() {
        return _stageWidth;
    }

    public int get_stageHeight() {
        return _stageHeight;
    }

    /**
     * Builds the items inside taskView base on the workingList and the
     * workingIndex.
     * 
     * @param workingList
     *            - this is the list of all task that can be shown in the
     *            taskView.
     * @param workingIndex
     *            - this is the selected index of the task.
     */
    public void buildComponent(ArrayList<TaskEntity> workingList, int workingIndex) {

        _mainVbox.getChildren().clear();
        _gridPanes = new ArrayList<GridPane>();

        this.workingList = workingList;
        if (workingList.size() > 0) {

            assert (workingIndex < workingList.size());
            assert (workingIndex > -1);

            setIndexs(workingIndex);

            _itemIndexCounter = _startIndex;
            int countItemSameWeek = 0;
            ArrayList<TaskEntity> itemsInSameWeek = new ArrayList<TaskEntity>();
            for (int i = _startIndex; i < _endIndex + 1; i++) {
                if (countItemSameWeek == 0) {
                    countItemSameWeek++;
                    itemsInSameWeek.add(workingList.get(i));
                } else {
                    if (isSameWeek(workingList.get(i), itemsInSameWeek.get(0))) {
                        itemsInSameWeek.add(workingList.get(i));
                    } else {
                        _mainVbox.getChildren().add(creatWeek(itemsInSameWeek));
                        countItemSameWeek = 1;
                        itemsInSameWeek = new ArrayList<TaskEntity>();
                        itemsInSameWeek.add(workingList.get(i));
                    }
                }
            }
            if (itemsInSameWeek.size() > 0) {
                _mainVbox.getChildren().add(creatWeek(itemsInSameWeek));
            }
            _selectedIndex = workingIndex;
        }
    }

    /**
     * Sets _startIndex and _endIndex values base on the workingIndex,
     * workingList and THRESHOLD.
     * 
     * @param workingIndex
     */
    private void setIndexs(int workingIndex) {
        _startIndex = 0;
        _endIndex = workingList.size() - 1;
        if (workingIndex - THRESHOLD > _startIndex) {
            _startIndex = workingIndex - THRESHOLD;
        }
        if (workingIndex + THRESHOLD < _endIndex) {
            _endIndex = workingIndex + THRESHOLD;
        }
    }

    /**
     * Add child into the parent, and increase parent height base on child
     * height.
     * 
     * @param parent
     * @param child
     */
    private void childToParent(Pane parent, Pane child) {
        double pHeight = parent.getMinHeight();
        parent.setMinHeight(pHeight + child.getMinHeight());
        parent.getChildren().add(child);
    }

    /**
     * Creates VBox for the items, items must belong to same Week.
     * 
     * @param items
     * @return VBox
     */
    private VBox creatWeek(ArrayList<TaskEntity> items) {
        VBox weekParent = createWeekParent();
        int countItemSameDay = 0;
        ArrayList<TaskEntity> itemsSameDay = new ArrayList<TaskEntity>();
        for (int i = 0; i < items.size(); i++) {
            if (countItemSameDay == 0) {
                countItemSameDay++;
                itemsSameDay.add(items.get(i));
            } else {
                if (isSameDay(items.get(i), itemsSameDay.get(0))) {
                    itemsSameDay.add(items.get(i));
                } else {
                    childToParent(weekParent, createDayForWeek(itemsSameDay));
                    countItemSameDay = 1;
                    itemsSameDay = new ArrayList<TaskEntity>();
                    itemsSameDay.add(items.get(i));
                }
            }
        }
        if (itemsSameDay.size() > 0) {
            childToParent(weekParent, createDayForWeek(itemsSameDay));
        }
        return weekParent;
    }

    /**
     * Creates VBox for the items, items must belong to same day.
     * 
     * @param items
     * @return VBox
     */
    private VBox createDayForWeek(ArrayList<TaskEntity> items) {
        VBox dayParent = createDayParent(items.get(0));
        for (int i = 0; i < items.size(); i++) {
            childToParent(dayParent, buildIndividualTask(items.get(i), _itemIndexCounter++));
        }
        return dayParent;
    }

    /**
     * Creates the warper box for week.
     * 
     * @return VBox.
     */
    private VBox createWeekParent() {
        VBox vbox = new VBox();
        vbox.setId("cssTaskViewWeekUnSelected");
        vbox.setMinWidth(_stageWidth);
        vbox.setMinHeight(0);
        return vbox;
    }

    /**
     * Creates the warper for day with the title label.
     * 
     * @return VBox.
     */
    private VBox createDayParent(TaskEntity taskEntity) {
        VBox vbox = new VBox();
        vbox.setMinHeight(TASK_VIEW_LABEL_HEIGHT + 2);
        HBox hbox = new HBox();
        hbox.setMinHeight(TASK_VIEW_LABEL_HEIGHT); // setMax
        hbox.setId("cssTaskViewDayLabel");

        Label dateNLPLabel = new Label();
        dateNLPLabel.getStyleClass().add(CSS_LABEL);
        dateNLPLabel.setMinHeight(TaskViewUserInterface.TASK_VIEW_LABEL_HEIGHT);
        dateNLPLabel.setFont(FONT_LABEL);
        dateNLPLabel.setAlignment(Pos.BOTTOM_CENTER);

        Calendar calendar;
        if (taskEntity.getStartDate() != null) {
            calendar = taskEntity.getStartDate();
        } else {
            calendar = taskEntity.getDueDate();
        }
        String labelText = getStringOfDate(calendar);
        if (labelText != null) {
            dateNLPLabel.setText(labelText);
            hbox.getChildren().add(dateNLPLabel);
        } else {
            SimpleDateFormat daySdf = new SimpleDateFormat("d");
            SimpleDateFormat sdf = new SimpleDateFormat("MMMMM yyyy");
            dateNLPLabel.setText(daySdf.format(taskEntity.getDueDate().getTime()) + " "
                    + sdf.format(taskEntity.getDueDate().getTime()));
            hbox.getChildren().add(dateNLPLabel);
        }

        vbox.getChildren().add(hbox);
        VBox.setMargin(hbox, new Insets(0, 20, 0, 20));
        return vbox;
    }

    private String getStringOfDate(Calendar c) {
        return _reverseParser.reParse((Calendar) c.clone());
    }

    /**
     * Builds the wrapper for the components for each task.
     * 
     * @return VBox.
     */
    private HBox buildIndividualTask(TaskEntity taskEntity, int index) {
        HBox hbox = new HBox();
        GridPane gridPane = createGridPaneForTask(taskEntity, index);
        _gridPanes.add(gridPane);
        hbox.getChildren().add(gridPane);
        hbox.setMinHeight(gridPane.getMinHeight());
        hbox.setMaxHeight(gridPane.getMinHeight());
        return hbox;
    }

    /**
     * Build the individual components for each task.
     * 
     * @param taskEntity
     * @param index
     * @return
     */
    private GridPane createGridPaneForTask(TaskEntity taskEntity, int index) {
        GridPane grid = new GridPane();
        grid.setId("cssTaskViewUnSelectedTask");
        grid.setHgap(GAP_SIZE);
        grid.setMinWidth(_individualItemWidth);

        Label indexLabel = new Label("ID" + Integer.toString(index));
        indexLabel.getStyleClass().add(CSS_LABEL);
        indexLabel.setMinHeight(TASK_VIEW_ITEM_HEIGHT);
        indexLabel.setFont(Font.font(PrimaryUserInterface.FONT_DEFAULT, FontWeight.BOLD, FONT_SIZE_TASK));
        indexLabel.setMinWidth(60);
        indexLabel.setAlignment(Pos.CENTER_RIGHT);
        grid.add(indexLabel, 0, 0);

        HBox topBox = new HBox();
        Label timeLabel = new Label();
        timeLabel.getStyleClass().add(CSS_LABEL);
        timeLabel.setText(taskEntity.getTime());
        timeLabel.setMinWidth(80);
        timeLabel.setMinHeight(TASK_VIEW_ITEM_HEIGHT);
        timeLabel.setFont(FONT_TASK);
        timeLabel.setAlignment(Pos.CENTER_RIGHT);
        HBox.setMargin(timeLabel, new Insets(0, 10, 0, 0));
        topBox.getChildren().add(timeLabel);

        if (taskEntity.getAssociationState() == TaskEntity.PROJECT_HEAD) {
            topBox.getChildren().add(StarPane.createStar(TASK_VIEW_ITEM_HEIGHT));
        }

        Label titleLabel = new Label(taskEntity.getName());
        titleLabel.getStyleClass().add(CSS_LABEL);
        titleLabel.setMinHeight(TASK_VIEW_ITEM_HEIGHT);
        titleLabel.setFont(FONT_TASK);
        HBox.setMargin(titleLabel, new Insets(0, 10, 0, 0));
        topBox.getChildren().add(titleLabel);
        grid.add(topBox, 1, 0);

        HBox midBox = new HBox();
        midBox.setMinHeight(0);

        String text = taskEntity.getDescription();
        Label descriptionLabel = new Label(text);
        descriptionLabel.getStyleClass().add(CSS_LABEL);
        descriptionLabel.setMinHeight(0);
        descriptionLabel.setMaxWidth(_individualItemWidth - 80);
        descriptionLabel.setWrapText(true);
        descriptionLabel.setFont(FONT_TASK);

        Text textPlaceHolderDescription = new Text(text);
        textPlaceHolderDescription.setWrappingWidth(_individualItemWidth - 80);

        midBox.getChildren().add(descriptionLabel);
        grid.add(midBox, 1, 1);

        Label hashTagLabel = new Label(taskEntity.getHashtags());
        hashTagLabel.getStyleClass().add(CSS_LABEL);
        hashTagLabel.setMinHeight(0);
        hashTagLabel.setMaxWidth(_individualItemWidth - 80);
        hashTagLabel.setFont(FONT_TASK);
        hashTagLabel.setWrapText(true);
        grid.add(hashTagLabel, 1, 2);

        Text textPlaceHolder = new Text(taskEntity.getHashtags());
        textPlaceHolder.setWrappingWidth(_individualItemWidth - 80);

        if (_view == UserInterfaceController.TASK_VIEW) {
            grid.setMinHeight(TASK_VIEW_ITEM_HEIGHT);
        } else {
            grid.setMinHeight(
                    DETAILED_VIEW_ITEM_HEIGHT + textPlaceHolderDescription.getBoundsInLocal().getHeight()
                            + textPlaceHolder.getBoundsInLocal().getHeight());
        }
        grid.setMaxHeight(
                DETAILED_VIEW_ITEM_HEIGHT + textPlaceHolderDescription.getBoundsInLocal().getHeight()
                        + textPlaceHolder.getBoundsInLocal().getHeight());

        return grid;
    }

    /**
     * Check if the index is between the _startIndex and _endIndex, inclusive.
     * 
     * @param index.
     * @return boolean.
     */
    private boolean isBetweenStartEnd(int index) {
        if (index >= _startIndex && index <= _endIndex) {
            return true;
        }
        return false;
    }

    /**
     * Updates the selector index by the amount of value. Items are added and
     * removed to maintain THRESHOLD.
     */
    public void update(int value) {
        for (int i = 0; i < Math.abs(value); i++) {
            if (value > 0)// ctrl down
            {
                if (_endIndex + 1 < workingList.size()) {
                    if (_selectedIndex - _startIndex >= THRESHOLD) {
                        removeFirstTask();
                    }
                    addLastItem();
                } else {
                    break;
                }
            } else if (value < 0) {
                if (_startIndex > 0) {
                    if (_endIndex - _selectedIndex >= THRESHOLD) {
                        removeLastTask();
                    }
                    addFirstItem();
                } else {
                    break;
                }
            }
        }
    }

    /**
     * Removes the first item in the main component.
     */
    private void removeFirstTask() {
        try {
            GridPane gp = _gridPanes.get(0);
            VBox gpDayParent = (VBox) gp.getParent().getParent();
            VBox gpWeekParent = (VBox) gpDayParent.getParent();
            if (gpDayParent.getChildren().size() == 2) {
                gpWeekParent.getChildren().remove(gpDayParent);
                gpWeekParent.setMinHeight(gpWeekParent.getMinHeight() - gpDayParent.getMinHeight());
                if (gpWeekParent.getChildren().size() == 0) {
                    _mainVbox.getChildren().remove(gpWeekParent);
                }
                transLationY = transLationY - gpDayParent.getMinHeight();

            } else {
                HBox itemToRemove = (HBox) gpDayParent.getChildren().remove(1);
                gpDayParent.setMinHeight(gpDayParent.getMinHeight() - itemToRemove.getMinHeight());
                gpWeekParent.setMinHeight(gpWeekParent.getMinHeight() - itemToRemove.getMinHeight());
                transLationY = transLationY - itemToRemove.getMinHeight();
            }
            _gridPanes.remove(0);
            _startIndex += 1;
        } catch (IndexOutOfBoundsException e) {

        }
    }

    /**
     * Removes the last item in the main component.
     */
    private void removeLastTask() {
        try {
            GridPane gp = _gridPanes.get(_gridPanes.size() - 1);
            VBox gpDayParent = (VBox) gp.getParent().getParent();
            VBox gpWeekParent = (VBox) gpDayParent.getParent();
            if (gpDayParent.getChildren().size() == 2) {
                gpWeekParent.getChildren().remove(gpDayParent);
                gpWeekParent.setMinHeight(gpWeekParent.getMinHeight() - gpDayParent.getMinHeight());
                if (gpWeekParent.getChildren().size() == 0) {
                    _mainVbox.getChildren().remove(gpWeekParent);
                }
            } else {
                HBox itemToRemove = (HBox) gpDayParent.getChildren()
                        .remove(gpDayParent.getChildren().size() - 1);
                gpDayParent.setMinHeight(gpDayParent.getMinHeight() - itemToRemove.getMinHeight());
                gpWeekParent.setMinHeight(gpWeekParent.getMinHeight() - itemToRemove.getMinHeight());
            }
            _gridPanes.remove(_gridPanes.size() - 1);
            _endIndex -= 1;
        } catch (IndexOutOfBoundsException e) {

        }
    }

    /**
     * Adds an item to the last position in the main component.
     */
    private void addLastItem() {
        GridPane gp = _gridPanes.get(_gridPanes.size() - 1);
        VBox gpDayParent = (VBox) gp.getParent().getParent();
        VBox gpWeekParent = (VBox) gpDayParent.getParent();
        if (isSameDay(workingList.get(_endIndex), workingList.get(_endIndex + 1))) {
            HBox itemToAdd = buildIndividualTask(workingList.get(_endIndex + 1), (_endIndex + 1));
            gpDayParent.getChildren().add(itemToAdd);
            gpDayParent.setMinHeight(gpDayParent.getMinHeight() + itemToAdd.getMinHeight());
            gpWeekParent.setMinHeight(gpWeekParent.getMinHeight() + itemToAdd.getMinHeight());
        } else {
            VBox weekParent = null;
            if (isSameWeek(workingList.get(_endIndex), workingList.get(_endIndex + 1))) {
                weekParent = gpWeekParent;
            } else {
                weekParent = createWeekParent();
                _mainVbox.getChildren().add(weekParent);
            }
            VBox vbox = createDayParent(workingList.get(_endIndex + 1));
            HBox itemToAdd = buildIndividualTask(workingList.get(_endIndex + 1), (_endIndex + 1));
            vbox.getChildren().add(itemToAdd);
            vbox.setMinHeight(vbox.getMinHeight() + itemToAdd.getMinHeight());
            weekParent.setMinHeight(weekParent.getMinHeight() + vbox.getMinHeight());
            weekParent.getChildren().add(vbox);
        }
        _endIndex = _endIndex + 1;
    }

    /**
     * Adds an item to the first position in the main component.
     */
    private void addFirstItem() {
        GridPane gp = _gridPanes.get(0);
        VBox gpDayParent = (VBox) gp.getParent().getParent();
        VBox gpWeekParent = (VBox) gpDayParent.getParent();
        if (isSameDay(workingList.get(_startIndex), workingList.get(_startIndex - 1))) {
            HBox itemToAdd = buildIndividualTask(workingList.get(_startIndex - 1), (_startIndex - 1));
            gpDayParent.getChildren().add(1, itemToAdd);
            gpDayParent.setMinHeight(gpDayParent.getMinHeight() + itemToAdd.getMinHeight());
            gpWeekParent.setMinHeight(gpWeekParent.getMinHeight() + itemToAdd.getMinHeight());
            transLationY += itemToAdd.getMinHeight();
        } else {
            VBox weekBox = null;
            if (isSameWeek(workingList.get(_startIndex), workingList.get(_startIndex - 1))) {
                weekBox = (VBox) gpDayParent.getParent();
            } else {
                weekBox = createWeekParent();
                _mainVbox.getChildren().add(0, weekBox);
            }
            VBox vbox = createDayParent(workingList.get(_startIndex - 1));
            HBox itemToAdd = buildIndividualTask(workingList.get(_startIndex - 1), (_startIndex - 1));
            vbox.getChildren().add(itemToAdd);
            vbox.setMinHeight(vbox.getMinHeight() + itemToAdd.getMinHeight());
            weekBox.getChildren().add(0, vbox);
            weekBox.setMinHeight(weekBox.getMinHeight() + vbox.getMinHeight());
            transLationY += vbox.getMinHeight();
        }
        _gridPanes.add(0, _gridPanes.remove(_gridPanes.size() - 1));
        _startIndex = _startIndex - 1;
    }

    /**
     * Set the item as selected base on the value.
     * 
     * @param value
     * @return TaskEntity
     */
    public TaskEntity setItemSelected(int value) {
        int index = value + _selectedIndex;
        if (_gridPanes.size() > 0) {
            if (index > -1 && index < workingList.size()) {
                if (isBetweenStartEnd(index)) {
                    if (_selectedIndex > -1) {
                        GridPane gpPrevious = _gridPanes.get(_selectedIndex - _startIndex);
                        setItemAsDeSelected(gpPrevious);
                    }
                    GridPane selectedGp = _gridPanes.get(index - _startIndex);
                    setItemAsSelected(selectedGp);
                    _selectedIndex = index;
                    updateTranslationY();
                }
            } else {
                if (value > 0) {
                    GridPane gpPrevious = _gridPanes.get(_selectedIndex - _startIndex);
                    setItemAsDeSelected(gpPrevious);
                    GridPane selectedGp = _gridPanes.get(_gridPanes.size() - 1);
                    setItemAsSelected(selectedGp);
                    _selectedIndex = _endIndex;
                } else if (value < 0) {
                    GridPane gpPrevious = _gridPanes.get(_selectedIndex - _startIndex);
                    setItemAsDeSelected(gpPrevious);
                    GridPane selectedGp = _gridPanes.get(0);
                    setItemAsSelected(selectedGp);
                    _selectedIndex = 0;
                }
                updateTranslationY();
            }
            return workingList.get(_selectedIndex);
        }
        return null;
    }

    /**
     * Set the item CSS to be Selected.
     * 
     * @param selectedGp
     */
    public void setItemAsSelected(GridPane selectedGp) {
        selectedGp.setId("cssTaskViewSelectedTask");
        VBox selectedParent = (VBox) selectedGp.getParent().getParent();
        selectedParent.setId("cssTaskViewDayBoxSelected");
        VBox weekParentSelected = (VBox) selectedParent.getParent();
        weekParentSelected.setId("cssTaskViewWeekSelected");
    }

    /**
     * Set the item CSS to be unSelected.
     * 
     * @param gpPrevious
     */
    public void setItemAsDeSelected(GridPane gpPrevious) {
        gpPrevious.setId("cssTaskViewUnSelectedTask");
        VBox previousParent = (VBox) gpPrevious.getParent().getParent();
        previousParent.setId("cssTaskViewDayBoxUnSelected");
        VBox weekParent = (VBox) previousParent.getParent();
        weekParent.setId("cssTaskViewWeekUnSelected");
    }

    /**
     * Updates the transLationY to be current selected item position addition
     * with threshold.
     */
    public void updateTranslationY() {
        if ((_selectedIndex - _startIndex) >= _gridPanes.size()) {
            return;
        }
        GridPane gp = _gridPanes.get(_selectedIndex - _startIndex);
        HBox gpParent = (HBox) gp.getParent();
        VBox dayParent = (VBox) gpParent.getParent();
        VBox weekParent = (VBox) dayParent.getParent();
        double heightAboveItem = 0;
        for (int i = 0; i < _mainVbox.getChildren().indexOf(weekParent); i++) {
            VBox weekBox = (VBox) _mainVbox.getChildren().get(i);
            heightAboveItem += weekBox.getMinHeight();
        }
        for (int i = 0; i < weekParent.getChildren().indexOf(dayParent); i++) {
            VBox dayBox = (VBox) weekParent.getChildren().get(i);
            heightAboveItem += dayBox.getMinHeight();
        }
        for (int i = 0; i < dayParent.getChildren().indexOf(gpParent); i++) {
            if (dayParent.getChildren().get(i) instanceof Label) {
                heightAboveItem += TASK_VIEW_LABEL_HEIGHT;
            } else {
                heightAboveItem += ((HBox) dayParent.getChildren().get(i)).getMinHeight();
            }
        }
        transLationY = heightAboveItem;
    }

    /**
     * Calculates the height above the selected item.
     * 
     * @return height
     */
    public double getTranslationY() {
        double totalHeight = 0;
        for (int i = 0; i < _mainVbox.getChildren().size(); i++) {
            VBox weekBox = (VBox) _mainVbox.getChildren().get(i);
            totalHeight += weekBox.getMinHeight();
        }
        if (totalHeight > _stageHeight) {
            totalHeight -= _stageHeight;
            double itemPosY = -transLationY + SELECTOR_POSITION_Y;
            if (itemPosY > 0) {
                return 0;
            }
            if (itemPosY < -totalHeight) {
                return -totalHeight;
            }
            return itemPosY;
        }
        return 0;
    }

    public void updateTranslateY(double itemPosY) {
        _mainVbox.setTranslateY(itemPosY);
    }

    /**
     * Checks if task1 and task2 belong in the same day.
     * 
     * @param task1
     * @param task2
     * @return true only if task belong in the same day
     */
    public static boolean isSameDay(TaskEntity task1, TaskEntity task2) {
        if (task1 == null) { // new day
            return false;
        }
        Calendar calendar1;
        Calendar calendar2;
        if (task1.getStartDate() != null) {
            calendar1 = task1.getStartDate();
        } else {
            calendar1 = task1.getDueDate();
        }
        if (task2.getStartDate() != null) {
            calendar2 = task2.getStartDate();
        } else {
            calendar2 = task2.getDueDate();
        }
        if (calendar1.get(Calendar.YEAR) == calendar2.get(Calendar.YEAR)) {
            if (calendar1.get(Calendar.MONTH) == calendar2.get(Calendar.MONTH)) {
                if (calendar1.get(Calendar.DATE) == calendar2.get(Calendar.DATE)) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Check if task1 and task2 belong in the same week.
     * 
     * @param task1
     * @param task2
     * @return true only if task1 and task2 belong in the same week.
     */
    public static boolean isSameWeek(TaskEntity task1, TaskEntity task2) {
        if (task1 == null) {
            return false;
        }
        Calendar calendar1;
        Calendar calendar2;
        if (task1.getStartDate() != null) {
            calendar1 = task1.getStartDate();
        } else {
            calendar1 = task1.getDueDate();
        }
        if (task2.getStartDate() != null) {
            calendar2 = task2.getStartDate();
        } else {
            calendar2 = task2.getDueDate();
        }

        if (calendar1.get(Calendar.YEAR) == calendar2.get(Calendar.YEAR)) {
            if (calendar1.get(Calendar.WEEK_OF_YEAR) == calendar2.get(Calendar.WEEK_OF_YEAR)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Builds a list of DescriptionLabels base on the position and items in the
     * TaskView.
     * 
     * @return list of DescriptionLabel
     */
    public ArrayList<DescriptionLabel> rebuildDescriptionLabelsForWeek() {
        ArrayList<DescriptionLabel> descriptionLables = new ArrayList<DescriptionLabel>();
        GridPane gp = getSelectedGridPane();
        if (gp == null) { // no selected gridPane
            return null;
        }
        HBox hbox = (HBox) gp.getParent();
        int countOfItems = 0;
        for (int i = 0; i < _mainVbox.getChildren().size(); i++) {
            VBox weekBox = (VBox) _mainVbox.getChildren().get(i);
            TaskEntity firstTaskInWeek = workingList.get(_startIndex + countOfItems);
            int numberOfTaskInWeek = countNumberOfTaskInWeek(weekBox);
            int indexForLastTaskInWeek = countOfItems + numberOfTaskInWeek - 1;
            TaskEntity lastTaskInWeek = null;
            if (indexForLastTaskInWeek < workingList.size()) {
                lastTaskInWeek = workingList.get(_startIndex + indexForLastTaskInWeek);
                countOfItems += numberOfTaskInWeek;
            }
            DescriptionLabel dLabel = new DescriptionLabel(firstTaskInWeek, lastTaskInWeek);
            dLabel.setHeight(weekBox.getMinHeight());
            if (weekBox.getChildren().contains(hbox.getParent())) {
                dLabel.setSelected();
            }
            descriptionLables.add(dLabel);
        }
        return descriptionLables;
    }

    /**
     * Builds a list of DescriptionLabels base on the position and items in the
     * ExpendedView.
     * 
     * @return list of DescriptionLabels
     */
    public ArrayList<DescriptionLabel> rebuildDescriptionLabelsForDay() {
        ArrayList<DescriptionLabel> descriptionLables = new ArrayList<DescriptionLabel>();
        GridPane gp = getSelectedGridPane();
        if (gp == null) {
            return null;
        }
        HBox hbox = (HBox) gp.getParent();
        int countOfItems = 0;
        for (int i = 0; i < _mainVbox.getChildren().size(); i++) {
            VBox weekBox = (VBox) _mainVbox.getChildren().get(i);
            for (int k = 0; k < weekBox.getChildren().size(); k++) {
                VBox dayParent = (VBox) weekBox.getChildren().get(k);
                TaskEntity firstTaskInWeek = workingList.get(_startIndex + countOfItems);
                int numberOfTaskInDay = countNumberOfTaskInDay(dayParent);
                countOfItems += numberOfTaskInDay;
                DescriptionLabel dLabel = new DescriptionLabel(firstTaskInWeek);
                dLabel.setHeight(dayParent.getMinHeight());
                if (dayParent.getChildren().contains(hbox)) {
                    dLabel.setSelected();
                }
                descriptionLables.add(dLabel);
            }
        }
        return descriptionLables;
    }

    /**
     * Calculates the of items in the week.
     * 
     * @param weekBox
     * @return number of items
     */
    public int countNumberOfTaskInWeek(VBox weekBox) {
        int noOfTask = 0;
        for (int i = 0; i < weekBox.getChildren().size(); i++) {
            VBox dayBox = (VBox) weekBox.getChildren().get(i);
            noOfTask += countNumberOfTaskInDay(dayBox);
        }
        return noOfTask;
    }

    /**
     * Calculates the of items in the day.
     * 
     * @param dayBox
     * @return number of items
     */
    public int countNumberOfTaskInDay(VBox dayBox) {
        return dayBox.getChildren().size() - 1;
    }

    /**
     * Gets the item that is selected.
     * 
     * @return GridPane
     */
    public GridPane getSelectedGridPane() {
        if (_gridPanes.size() <= (_selectedIndex - _startIndex)) {
            return null;
        }
        GridPane gridPane = _gridPanes.get(_selectedIndex - _startIndex);
        return gridPane;
    }

    public void destoryStage() {
        _myInstance = null;
        _stage.close();
    }

    public void setView(int view) {
        _view = view;
    }

    /**
     * Animates the current view to the detailed view base on the value.
     * 
     * @param value
     * @return true only if animation is done
     */
    public boolean isAtExpandedView(double value) {
        double totalHeight = 0;
        int index = _selectedIndex - _startIndex;
        int counterForDoneItems = 0;
        for (int i = 0; i < _gridPanes.size(); i++) {
            GridPane gp = _gridPanes.get(i);
            HBox gpParent = (HBox) gp.getParent();
            VBox dayParent = (VBox) gpParent.getParent();
            VBox weekParent = (VBox) dayParent.getParent();
            if (gp.getMinHeight() < gp.getMaxHeight()) {
                if (gp.getMaxHeight() - gp.getMinHeight() < value) {
                    value = gp.getMaxHeight() - gp.getMinHeight();
                }
                if (i < index) {
                    totalHeight += value;
                }
                gp.setMinHeight(gp.getMinHeight() + value);
                gpParent.setMinHeight(gpParent.getMinHeight() + value);
                dayParent.setMinHeight(dayParent.getMinHeight() + value);
                weekParent.setMinHeight(weekParent.getMinHeight() + value);
            } else {
                counterForDoneItems++;
            }
        }
        transLationY += totalHeight;
        if (counterForDoneItems >= _gridPanes.size()) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Animates the current view to the task view base on the value.
     * 
     * @param value
     * @return true only if the animation is done
     */
    public boolean isAtTaskView(double value) {
        double totalHeight = 0;
        int counterForDoneItems = 0;
        int index = _selectedIndex - _startIndex;
        for (int i = 0; i < _gridPanes.size(); i++) {
            GridPane gp = _gridPanes.get(i);
            HBox gpParent = (HBox) gp.getParent();
            VBox dayParent = (VBox) gpParent.getParent();
            VBox weekParent = (VBox) dayParent.getParent();
            if (gp.getMinHeight() > TASK_VIEW_ITEM_HEIGHT) {
                if (gp.getMinHeight() - TASK_VIEW_ITEM_HEIGHT < value) {
                    value = gp.getMinHeight() - TASK_VIEW_ITEM_HEIGHT;
                }
                if (i < index) {
                    totalHeight += value;
                }
                gp.setMinHeight(gp.getMinHeight() + value);
                gpParent.setMinHeight(gpParent.getMinHeight() + value);
                gpParent.setMaxHeight(gpParent.getMinHeight());
                dayParent.setMinHeight(dayParent.getMinHeight() + value);
                weekParent.setMinHeight(weekParent.getMinHeight() + value);
            } else {
                counterForDoneItems++;
            }
        }
        transLationY += totalHeight;
        if (counterForDoneItems >= _gridPanes.size()) {
            return true;
        } else {
            return false;
        }
    }

    public int getSelectIndex() {
        return _selectedIndex;
    }

    public void setSelectedIndex(int index) {
        _selectedIndex = index;
    }

    public void changeTheme(String styleSheet) {
        _styleSheet = styleSheet;
        _stage.getScene().getStylesheets().clear();
        _stage.getScene().getStylesheets().add(_styleSheet);
    }

}
```
###### src\userinterface\UserInterfaceController.java
``` java
 * 
 *          This class controls all the other components except the command bar.
 */
package userinterface;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Queue;
import java.util.logging.FileHandler;
import java.util.logging.Handler;
import java.util.logging.Level;
import java.util.logging.Logger;

import entity.ResultSet;
import entity.TaskEntity;
import javafx.event.EventHandler;
import javafx.geometry.Rectangle2D;
import javafx.scene.input.MouseEvent;
import javafx.stage.Stage;
import logic.TaskManager;
import logic.TaskUtils;
import parser.InputParser;
import parser.Pair;
import parser.ParserCommons;
import parser.CommandParser.COMMAND;

public class UserInterfaceController {

    // Singleton
    private static UserInterfaceController _instance;

    private static final int ZERO_VALUE = 0;

    // view indicators
    final static int CALENDAR_VIEW = 0;
    final static int TASK_VIEW = 1;
    final static int EXPANDED_VIEW = 2;
    final static int ASSOCIATE_VIEW = 3;
    final static int FLOATING_VIEW = 4;
    final static int SEARCH_VIEW = 5;
    private int _previousView = -1;

    // Return values
    private static final int SUCCESSFULLY_ADDED_DIFF = -1;

    private String _styleSheet;
    private Stage _parentStage;
    private TaskViewUserInterface _taskViewInterface;
    private DescriptionComponent _descriptionComponent;
    private DetailComponent _detailComponent;
    private FloatingBarViewUserInterface _floatingBarComponent;
    private FloatingTaskUserInterface _floatingViewInterface;
    private SearchUserInterface _searchViewInterface;
    private HelpScreenUserInterface _helpScreen;

    // This mouseEvent is to aid focus, when user click on other areas of the
    // application, focus will be triggered to command bar.
    private EventHandler<MouseEvent> _mouseEvent;

    private Rectangle2D _screenBounds;
    private boolean _isFixedSize;

    // variables for animation and changing views;
    private int _currentView = TASK_VIEW;
    private ScrollTaskAnimation _scorllAnimation;
    private FloatingBarAnimationThread _floatingThread;

    // Main logic class to interact
    private UserInterfaceExecuter _logicFace;
    private boolean _isLoaded;

    // Debug purpose
    private static Logger logger = Logger.getLogger("UserInterfaceController");

    /**
     * Create an instance of UserInterfaceController.
     * 
     * @param PrimaryStage
     * @return Instance of UserInterfaceController only if there isn't an
     *         instance already.
     */
    public static UserInterfaceController getInstance(Stage primaryStage) {
        if (_instance == null) {
            _instance = new UserInterfaceController(primaryStage);
            return _instance;
        } else {
            return null;
        }
    }

    /**
     * Initialize logic components and recover any lost data.
     * 
     * @param primaryStage
     */
    private UserInterfaceController(Stage primaryStage) {
        try {
            Handler handler = new FileHandler("uiinterfaceLog.log");
            logger.addHandler(handler);
            logger.setLevel(Level.FINEST);
        } catch (IOException e) {
        }
        logger.log(Level.INFO, "Init");

        _parentStage = primaryStage;
        _logicFace = new UserInterfaceExecuter();
        _isLoaded = _logicFace.isFileLoadedSuccess();
        if (_isLoaded) {
            recoverLostCommands();
            logger.log(Level.INFO, "Recovery done.");
        }

    }

    /**
     * Initialize the other views.
     * 
     * @param screenBounds
     * @param isFixedSize
     * @param styleSheet
     * @param mouseEvent
     */
    public void initializeInterface(Rectangle2D screenBounds, boolean isFixedSize, String styleSheet,
            EventHandler<MouseEvent> mouseEvent) {
        this._styleSheet = styleSheet;
        this._screenBounds = screenBounds;
        this._isFixedSize = isFixedSize;
        this._mouseEvent = mouseEvent;
        initializeViews();
        show();
    }

    /**
     * Initialize an instance of FloatingBarViewUserInterface,
     * TaskViewUserInterface, DescriptionComponent, DetailsComponent,
     * FloatingTaskUserInterface, SearchUserInterface, HelpScreenUserInterface.
     */
    public void initializeViews() {
        _currentView = TASK_VIEW;
        setManagerView(TASK_VIEW);
        logger.log(Level.INFO, "initializing views.");
        initializeHelpScreen();
        initializeFloatingBar();
        initializeFloatingView();
        initializeSearchView();
        initializeTaskView();
        initializeDescriptionComponent();
        initializeDetailComponent();
        updateComponents(ZERO_VALUE);
    }

    private void initializeHelpScreen() {
        logger.log(Level.INFO, "initializing help view.");
        String loadFromFilePath = _logicFace.getLoadFromFilePath();
        _helpScreen = HelpScreenUserInterface.getInstance(_parentStage, _screenBounds, _isFixedSize,
                _styleSheet, _mouseEvent, loadFromFilePath);
    }

    private void initializeTaskView() {
        logger.log(Level.INFO, "initializing task view.");
        _taskViewInterface = TaskViewUserInterface.getInstance(_parentStage, _screenBounds, _isFixedSize,
                _styleSheet, _mouseEvent);
        _taskViewInterface.buildComponent(_logicFace.getWorkingList(), _logicFace.getNextTimeListId());
    }

    private void initializeFloatingView() {
        logger.log(Level.INFO, "initializing floating view.");
        _floatingViewInterface = FloatingTaskUserInterface.getInstance(_parentStage, _screenBounds,
                _isFixedSize, _styleSheet, _mouseEvent);
    }

    private void initializeFloatingBar() {
        logger.log(Level.INFO, "initializing floating bar component.");
        _floatingBarComponent = FloatingBarViewUserInterface.getInstance(_parentStage, _screenBounds,
                _isFixedSize, _styleSheet, _mouseEvent);
        TaskEntity floatingTask = _logicFace.getRandomFloating();
        if (floatingTask != null) {
            startFloatingThread();
        }
    }

    private void initializeSearchView() {
        logger.log(Level.INFO, "initializing search view.");
        _searchViewInterface = SearchUserInterface.getInstance(_parentStage, _screenBounds, _isFixedSize,
                _styleSheet, _mouseEvent);
    }

    private void initializeDetailComponent() {
        logger.log(Level.INFO, "initializing detail component.");
        _detailComponent = DetailComponent.getInstance(_parentStage, _screenBounds, _isFixedSize, _styleSheet,
                _mouseEvent);
    }

    private void initializeDescriptionComponent() {
        logger.log(Level.INFO, "initializing description component.");
        _descriptionComponent = DescriptionComponent.getInstance(_parentStage, _screenBounds, _isFixedSize,
                _styleSheet, _mouseEvent);
    }

    /**
     * Show the various components depending on _currentView.
     */
    public void show() {
        if (_currentView == TASK_VIEW) {
            _taskViewInterface.show();
            _descriptionComponent.show();
            _floatingBarComponent.show();
            _detailComponent.show();
            _floatingViewInterface.hide();
            _searchViewInterface.hide();
            _helpScreen.hide();
        } else if (_currentView == EXPANDED_VIEW || _currentView == ASSOCIATE_VIEW) {
            _taskViewInterface.show();
            _descriptionComponent.show();
            _floatingBarComponent.show();
            _detailComponent.show();
            _floatingViewInterface.hide();
            _searchViewInterface.hide();
            _helpScreen.hide();
        } else if (_currentView == FLOATING_VIEW) {
            _taskViewInterface.hide();
            _descriptionComponent.hide();
            _detailComponent.hide();
            _searchViewInterface.hide();
            _floatingBarComponent.show();
            _floatingViewInterface.show();
            _helpScreen.hide();
        } else if (_currentView == SEARCH_VIEW) {
            _taskViewInterface.hide();
            _descriptionComponent.hide();
            _detailComponent.hide();
            _searchViewInterface.hide();
            _floatingViewInterface.hide();
            _floatingBarComponent.show();
            _searchViewInterface.show();
            _helpScreen.hide();
        }
    }

    /**
     * Hide all views other then the PrimaryUserInterface.
     */
    public void hide() {
        _taskViewInterface.hide();
        _descriptionComponent.hide();
        _floatingBarComponent.hide();
        _detailComponent.hide();
        _floatingViewInterface.hide();
        _searchViewInterface.hide();
        _helpScreen.hide();
    }

    /**
     * De-initialize the components and kills the floating thread.
     */
    public void destroy() {
        _taskViewInterface.destoryStage();
        _descriptionComponent.destoryStage();
        _detailComponent.destoryStage();
        _floatingBarComponent.destoryStage();
        _floatingViewInterface.destoryStage();
        _searchViewInterface.destoryStage();
        _helpScreen.destory();
        killFloatingThread();
    }

    /**
     * Updates the TaskViewInterface, DetailComponent, DescriptionComponet
     * according to the selected value;
     * 
     * @param value
     */
    public void updateComponents(int value) {
        if (_currentView == TASK_VIEW || _currentView == EXPANDED_VIEW) {
            _taskViewInterface.update(value);
            TaskEntity selectedTask = _taskViewInterface.setItemSelected(value);
            _detailComponent.buildComponent(selectedTask);
            translateComponentsY(_taskViewInterface.getTranslationY());
            updateDescriptionComponent();
        } else if (_currentView == ASSOCIATE_VIEW) {
            _detailComponent.update(value);
        } else if (_currentView == FLOATING_VIEW) {
            _floatingViewInterface.update(value);
            _floatingViewInterface.setSelected(value);
        } else if (_currentView == SEARCH_VIEW) {
            _searchViewInterface.update(value);
            _searchViewInterface.setSelected(value);
        }
    }

    /**
     * Updates the description panel to reflect the updates on the task view.
     */
    public void updateDescriptionComponent() {
        if (_currentView == TASK_VIEW) {
            _taskViewInterface.rebuildDescriptionLabelsForWeek();
            _descriptionComponent.buildComponent(_taskViewInterface.rebuildDescriptionLabelsForWeek(),
                    TASK_VIEW);
        } else if (_currentView == EXPANDED_VIEW || _currentView == ASSOCIATE_VIEW) {
            _descriptionComponent.buildComponent(_taskViewInterface.rebuildDescriptionLabelsForDay(),
                    EXPANDED_VIEW);
        }
    }

    /**
     * Translates the views base on the user controls.
     * 
     * @param value
     */
    public void translateComponentsY(double value) {
        _descriptionComponent.updateTranslateY(value);
        _taskViewInterface.updateTranslateY(value);
    }

    /**
     * Changes the view according by the value.
     * 
     * @param value
     */
    public void changeView(int value) {
        _helpScreen.hide();
        int view = _currentView + value;
        switch (view) {
            case TASK_VIEW : {
                setPreviousView();
                _currentView = view;
                _taskViewInterface.setView(_currentView);
                _detailComponent.setView(_currentView);
                updateComponents(0);
                startExpandAnimation(1);
                break;
            }
            case EXPANDED_VIEW : {
                setPreviousView();
                _currentView = view;
                _taskViewInterface.setView(_currentView);
                _detailComponent.setView(_currentView);
                updateComponents(0);
                startExpandAnimation(-1);
                break;
            }
            case ASSOCIATE_VIEW : {
                setPreviousView();
                if (_currentView == FLOATING_VIEW) {
                    showMainView(ASSOCIATE_VIEW);
                } else {
                    _currentView = view;
                    _taskViewInterface.setView(_currentView);
                    _detailComponent.setView(_currentView);
                    updateComponents(0);
                }
                break;
            }
            case FLOATING_VIEW : {
                showFloatingView(0);
                break;
            }
            case SEARCH_VIEW : {
                showSearchView();
                break;
            }
            default :
                break;
        }
    }

    public void setPreviousView() {
        if (_currentView != FLOATING_VIEW && _currentView != SEARCH_VIEW) {
            _previousView = _currentView;
        }
    }

    /**
     * Switches the view to the task view and brings up the help screen. If help
     * screen is already shown, hides the help screen.
     */
    public void showHelpView() {
        boolean isShown = _helpScreen.toggleHelpView();
        if (isShown) {
            showMainView(-1);
            _helpScreen.show();
        }
    }

    public void updateHelpView(int value) {
        _helpScreen.update(value);
    }

    public void showSearchView() {
        if (_currentView != FLOATING_VIEW && _currentView != SEARCH_VIEW) {
            _previousView = _currentView;
        }
        _currentView = SEARCH_VIEW;
        _logicFace.switchView(TaskManager.DISPLAY_SEARCH);
        ArrayList<TaskEntity> searchList = _logicFace.getWorkingList();
        _searchViewInterface.buildContent(searchList);
        show();
    }

    public void showFloatingView(int index) {
        if (_currentView != FLOATING_VIEW && _currentView != SEARCH_VIEW) {
            _previousView = _currentView;
        }
        _currentView = FLOATING_VIEW;
        _logicFace.switchView(TaskManager.DISPLAY_FLOATING);
        ArrayList<TaskEntity> floatingList = _logicFace.getWorkingList();
        _floatingViewInterface.buildContent(floatingList, index);
        show();
    }

    public void showMainView(int view) {
        _logicFace.switchView(TaskManager.DISPLAY_MAIN);
        if (view == -1) {
            if (_currentView == FLOATING_VIEW || _currentView == SEARCH_VIEW) {
                _currentView = _previousView;
                _taskViewInterface.setView(_currentView);
                _detailComponent.setView(_currentView);
                reBuildFrontView(-1);
            }
        } else {
            _currentView = ASSOCIATE_VIEW;
            _taskViewInterface.setView(_currentView);
            _detailComponent.setView(_currentView);
            reBuildFrontView(-1);
        }
        show();
    }

    /**
     * Rebuilds the content of TaskViewUserInterface, DetailComponent,
     * DescriptionComponent after a command is executed.
     * 
     * @param index
     *            - if index is less then zero. rebuild views base on last, else
     *            build with the index as selected.
     */
    public void reBuildFrontView(int index) {
        int selelcted = 0;
        if (index < 0) {
            selelcted = _taskViewInterface.getSelectIndex();
            if (!(selelcted < _logicFace.getWorkingList().size() && selelcted > -1)) {
                selelcted = 0;
            }
        } else {
            selelcted = index;
        }
        _taskViewInterface.buildComponent(_logicFace.getWorkingList(), selelcted);
        _taskViewInterface.update(0);
        TaskEntity selectedTask = _taskViewInterface.setItemSelected(0);
        _detailComponent.buildComponent(selectedTask);
        if (_currentView == ASSOCIATE_VIEW) {
            _detailComponent.update(0);
        }
        translateComponentsY(_taskViewInterface.getTranslationY());
        updateDescriptionComponent();
    }

    /**
     * Starts the service to animate the current view to the selected view.
     * 
     * @param direction
     *            - direction -1 indicates ExpandedView to TaskView, direction 1
     *            indicates TaskView to ExpandedView.
     */
    public void startExpandAnimation(int direction) {
        TaskViewAnimation.getInstance(this, direction).start();
    }

    /**
     * Increase the sizes of all components in the TaskView.
     * 
     * @return - true only when animation is done.
     */
    public boolean isAtExpanedView() {
        boolean isDoneTranslating = _taskViewInterface.isAtExpandedView(1);
        _descriptionComponent.buildComponent(_taskViewInterface.rebuildDescriptionLabelsForDay(),
                EXPANDED_VIEW);
        translateComponentsY(_taskViewInterface.getTranslationY());
        return isDoneTranslating;
    }

    /**
     * Decrease the sizes of all components in the TaskView.
     * 
     * @return - true only when animation is done.
     */
    public boolean isAtTaskView() {
        boolean isDoneTranslating = _taskViewInterface.isAtTaskView(-1);
        _descriptionComponent.buildComponent(_taskViewInterface.rebuildDescriptionLabelsForWeek(), TASK_VIEW);
        translateComponentsY(_taskViewInterface.getTranslationY());
        return isDoneTranslating;
    }

    /**
     * Starts the thread to load a new floating task into the
     * FloatingBarUserInterface.
     */
    private void startFloatingThread() {
        if (_floatingThread == null) {
            if (_logicFace.getRandomFloating() != null) {
                _floatingBarComponent.addTask(_logicFace.getRandomFloating().getName());
                _floatingThread = new FloatingBarAnimationThread(this);
                _floatingThread.start();
            }
        }
    }

    /**
     * Kills the thread that loads a new floating task into the
     * FloatingBarUserInterface.
     */
    public void killFloatingThread() {
        if (_floatingThread != null) {
            _floatingBarComponent.clearFloatingBar();
            _floatingThread.cancel();
            _floatingThread = null;
        }
    }

    /**
     * Gets a random floating tasks and adds it to the FloatingBarUserInterface.
     */
    public void addRandomTaskToDisplay() {
        TaskEntity task = _logicFace.getRandomFloating();
        if (task != null) {
            _floatingBarComponent.addTask(task.getName());
            if (_floatingThread == null) {
                startFloatingThread();
            }
        } else {
            if (_floatingThread != null) {
                killFloatingThread();
            }
        }
    }

    /**
     * Translate the component in FloatingBarAnimation according to the
     * percentageDone.
     * 
     * @param percentageDone
     * @return - true only if animation is done.
     */
    public boolean updateFloatingBar(double percentageDone) {
        boolean isDoneAnimating = _floatingBarComponent.animateView(percentageDone);
        return isDoneAnimating;
    }

    /**
     * Add the task into the list.
     * 
     * @param task
     * @param rawInput
     * @param shouldUpdateView
     *            (false only when recovering lost commands and testing)
     * @return ResultSet
     */
    public ResultSet addTask(TaskEntity task, String rawInput, boolean shouldUpdateView) {
        ResultSet resultSet = _logicFace.addTask(task, buildRawCommand(rawInput));
        if (resultSet.isSuccess()) {
            if (shouldUpdateView) {
                updateChangesToViews(resultSet.getIndex());
            }
        }

        return resultSet;
    }

    public ResultSet deleteTask(String id, String rawInput, boolean shouldUpdateView) {
        ResultSet resultSet = _logicFace.delete(id, buildRawCommand(rawInput));
        if (resultSet != null) {
            if (resultSet.isSuccess()) {
                if (shouldUpdateView) {
                    updateChangesToViews(resultSet.getIndex());
                }
            }
            return resultSet;
        }
        return null;
    }

    /**
     * Gets the task base on the id.
     * 
     * @param id
     * @return TaskEntity
     */
    public TaskEntity getTaskByID(int id) {
        ArrayList<TaskEntity> tasks = _logicFace.getWorkingList();
        if (id < tasks.size()) {
            return tasks.get(id);
        } else {
            return null;
        }
    }

    /**
     * Unused.
     * 
     * @param taskToCheck
     * @return
     */
    public int getTaskID(TaskEntity taskToCheck) {
        int index = -1;
        ArrayList<TaskEntity> tasks = _logicFace.getWorkingList();
        for (int i = 0; i < tasks.size(); i++) {
            TaskEntity taskOnList = tasks.get(i);
            Calendar toCheckDate = taskToCheck.getDueDate();
            toCheckDate.clear(Calendar.MILLISECOND);
            Calendar onListDate = taskOnList.getDueDate();
            onListDate.clear(Calendar.MILLISECOND);
            if (toCheckDate.compareTo(onListDate) == 0) {
                if (taskToCheck.getName().equals(taskOnList.getName())) {
                    index = i;
                }
            }
        }
        return index;
    }

    /**
     * Calls the logic component to modify the task.
     * 
     * @param idToModify
     * @param task
     * @param rawInput
     * @param shouldUpdateView
     * @return ResultSet
     */
    public ResultSet modifyTask(int idToModify, TaskEntity task, String rawInput, boolean shouldUpdateView) {
        ResultSet resultSet = _logicFace.modify(idToModify, task, buildRawCommand(rawInput));
        if (resultSet.isSuccess()) {
            if (shouldUpdateView) {
                updateChangesToViews(resultSet.getIndex());
            }
        }
        return resultSet;
    }

    /**
     * Starts the scrolling animation to auto scroll to the selected index.
     * 
     * @param indexToJump
     * @return true only if index is valid
     */
    public boolean jumpToIndex(String indexToJump) {
        int selected = _taskViewInterface.getSelectIndex();
        if (selected != -1) {
            _scorllAnimation = ScrollTaskAnimation.getInstance(selected,
                    TaskUtils.convertStringToInteger(indexToJump), this);
            _scorllAnimation.start();
            return true;
        } else {
            return false;
        }
    }

    public ResultSet executeSearch(String stringToSearch, String rawString, boolean shouldUpdateView) {
        ResultSet resultSet = _logicFace.searchString(stringToSearch, buildRawCommand(rawString));
        if (resultSet.getSearchCount() > 0) {
            if (shouldUpdateView) {
                showSearchView();
            }
        }
        return resultSet;
    }

    public ResultSet markAsCompleted(String indexZZ, String rawString, boolean shouldUpdateView) {
        int indexInt = TaskUtils.convertStringToInteger(indexZZ);
        if (indexInt == -1) {
            return null;
        }
        ResultSet resultSet = _logicFace.markAsDone(indexInt, buildRawCommand(rawString));
        if (resultSet.isSuccess()) {
            if (shouldUpdateView) {
                updateChangesToViews(resultSet.getIndex());
            }
        }
        return resultSet;
    }

    public void stopScrollingAnimation() {
        if (_scorllAnimation != null) {
            if (_scorllAnimation.isRunning()) {
                _scorllAnimation.cancel();
            }
        }
        _scorllAnimation = null;
    }

    /**
     * Calls the logic component to link the two task together.
     * 
     * @param indexZZ1
     * @param indexZZ2
     * @param rawString
     * @param shouldUpdateView
     * @return ResultSet
     */
    public ResultSet link(String indexZZ1, String indexZZ2, String rawString, boolean shouldUpdateView) {
        int index1 = TaskUtils.convertStringToInteger(indexZZ1);
        int index2 = TaskUtils.convertStringToInteger(indexZZ2);
        if (index1 != -1 && index2 != -1) {
            if (index1 < _logicFace.getWorkingList().size() && index2 < _logicFace.getWorkingList().size()) {
                _logicFace.getWorkingList().get(index1);
                _logicFace.getWorkingList().get(index2);
                ResultSet resultSet = _logicFace.link(_logicFace.getWorkingList().get(index1),
                        _logicFace.getWorkingList().get(index2), buildRawCommand(rawString));
                if (resultSet.isSuccess()) {
                    if (shouldUpdateView) {
                        updateChangesToViews(resultSet.getIndex());
                    }
                }
                return resultSet;
            } else {
                ResultSet rs = new ResultSet();
                rs.setFail();
                rs.setIndex(-1);
                return rs;
            }
        }
        return null;
    }

    /**
     * Updates the UserInterface Components to reflect the changes upon command
     * execution.
     * 
     * @param index
     *            - determines if the command executed is in the selected view.
     *            - if index is -1, the task current targeted task is at another
     *            view.
     */
    public void updateChangesToViews(int index) {
        if (_currentView == TASK_VIEW || _currentView == EXPANDED_VIEW || _currentView == ASSOCIATE_VIEW) {
            if (index == SUCCESSFULLY_ADDED_DIFF) {
                startFloatingThread();
            }
            reBuildFrontView(index);
        } else if (_currentView == FLOATING_VIEW) {
            ArrayList<TaskEntity> floatingList = _logicFace.getWorkingList();
            if (floatingList == null || floatingList.size() == 0) {
                killFloatingThread();
            } else {
                startFloatingThread();
            }
            _floatingViewInterface.buildContent(floatingList, index);
        } else if (_currentView == SEARCH_VIEW) {
            showSearchView();
        }
    }

    /**
     * Builds the String command base on the index of the task.
     * 
     * @param indexToModify
     * @return command.
     */
    public String getTaskToEditString(int indexToModify) {
        TaskEntity toPopulate = getTaskByID(indexToModify);
        if (toPopulate != null) {
            String toSet = " " + toPopulate.getName();
            if ((toPopulate.getDescription() != null) && (toPopulate.getDescription().trim().length() > 0)) {
                toSet += " : " + toPopulate.getDescription();
            }
            if (toPopulate.getStartDate() != null) {
                Calendar c = toPopulate.getStartDate();
                int day = c.get(Calendar.DATE);
                int month = c.get(Calendar.MONTH) + 1;
                int year = c.get(Calendar.YEAR);
                int hour = c.get(Calendar.HOUR_OF_DAY);
                int min = c.get(Calendar.MINUTE);
                String hourStr = ParserCommons.padTime(hour);
                String minStr = ParserCommons.padTime(min);
                toSet += " " + day + "-" + month + "-" + year + " " + hourStr + minStr + "hrs to ";
            }
            if (toPopulate.getDueDate() != null) {
                Calendar c = toPopulate.getDueDate();
                int day = c.get(Calendar.DATE);
                int month = c.get(Calendar.MONTH) + 1;
                int year = c.get(Calendar.YEAR);
                int hour = c.get(Calendar.HOUR_OF_DAY);
                int min = c.get(Calendar.MINUTE);
                String hourStr = ParserCommons.padTime(hour);
                String minStr = ParserCommons.padTime(min);
                toSet += " " + day + "-" + month + "-" + year + " " + hourStr + minStr + "hrs ";
            }
            if (toPopulate.getProjectHead() != null) {
                toSet += " @" + toPopulate.getProjectHead().getName();
            }
            return toSet;
        }
        return null;
    }

    public void saveStuff() {
        _logicFace.closeTaskManager();
    }

    /**
     * Append the index of the view in-front of the raw command.
     * 
     * @param rawWithView
     * @return actual raw command.
     */
    public String buildRawCommand(String raw) {
        String full = Integer.toString(_currentView).concat(" ").concat(raw);
        return full;
    }

    /**
     * Breaks the String into the view index and the actual raw command.
     * 
     * @param rawWithView
     * @return actual raw command.
     */
    public String deStructToRawCommand(String rawWithView) {
        if (rawWithView.split(" ").length > 0) {
            int index = rawWithView.indexOf(" ");
            if (index != -1) {
                return rawWithView.substring(index + 1);
            }
        }
        return null;
    }

    /**
     * Breaks the String into the view index and the actual raw command.
     * 
     * @param rawWithView
     * @return index of view.
     */
    public String deStructToView(String rawWithView) {
        if (rawWithView.split(" ").length > 1) {
            String[] spilt = rawWithView.split(" ");
            return spilt[0];
        }
        return null;
    }

    /**
     * Sets TaskManger view, serves only for recovering commands.
     * 
     * @param view
     */
    private void setManagerView(int view) {
        if (view == TASK_VIEW) {
            _logicFace.switchView(TaskManager.DISPLAY_MAIN);
        } else if (view == EXPANDED_VIEW) {
            _logicFace.switchView(TaskManager.DISPLAY_MAIN);
        } else if (view == ASSOCIATE_VIEW) {
            _logicFace.switchView(TaskManager.DISPLAY_MAIN);
        } else if (view == SEARCH_VIEW) {
            _logicFace.switchView(TaskManager.DISPLAY_SEARCH);
        } else if (view == FLOATING_VIEW) {
            _logicFace.switchView(TaskManager.DISPLAY_FLOATING);
        }
    }

    /**
     * Gets the list of commands that has been saves and has not been executed.
     * Execute those commands.
     */
    public void recoverLostCommands() {
        Queue<String> qCommands = _logicFace.getBackedupCommands();
        while (!qCommands.isEmpty()) {
            String rawCommandWithView = qCommands.poll();
            runCommands(rawCommandWithView);
        }
        _logicFace.switchView(TaskManager.DISPLAY_MAIN);
    }

    /**
     * Process the rawCommand and execute the command. This method is only
     * called during an undo command or during recovery.
     * 
     * @param rawCommandWithView
     * @return the view the command was previously executed in.
     */
    private int runCommands(String rawCommandWithView) {
        String rawCommand = deStructToRawCommand(rawCommandWithView);
        String view = deStructToView(rawCommandWithView);
        int viewInt = TaskUtils.convertStringToInteger(view);
        if (viewInt != -1) {
            setManagerView(viewInt);
        }
        if (rawCommand != null) {
            InputParser parser = new InputParser(rawCommand);
            COMMAND cmd = parser.getCommand();
            switch (cmd) {
                case ADD : {
                    ArrayList<TaskEntity> tasks = parser.getTask();
                    if (tasks.size() == 1) {
                        addTask(tasks.get(0), rawCommand, false);
                    }
                    break;
                }
                case DELETE : {
                    String id = parser.getID();
                    deleteTask(id, rawCommand, false);
                    break;
                }
                case EDIT : {
                    int id = TaskUtils.convertStringToInteger(parser.getID());
                    parser.removeId();
                    ArrayList<TaskEntity> tasks = parser.getTask();
                    if (tasks.size() == 1) {
                        modifyTask(id, tasks.get(0), rawCommand, false);
                    }
                    break;
                }
                case DONE : {
                    String id = parser.getID();
                    markAsCompleted(id, rawCommand, false);
                    break;
                }
                case SEARCH : {
                    String searchStirng = parser.getSearchString();
                    executeSearch(searchStirng, rawCommand, false);
                    _logicFace.switchView(TaskManager.DISPLAY_SEARCH);
                    break;
                }
                case LINK : {
                    Pair<String, String> ids = parser.getLinkID();
                    link(ids.getFirst(), ids.getSecond(), rawCommand, false);
                    break;
                }
                default :
                    break;
            }
        }
        return viewInt;
    }

    public ResultSet changeSaveDir(String dirPath) {
        ResultSet resultSet = _logicFace.changeSaveDir(dirPath);
        if (resultSet.isSuccess()) {
            _helpScreen.changeFilePath(_logicFace.getLoadFromFilePath());
        }
        return resultSet;
    }

    /**
     * Gets the list of commands to run on the file start state.
     * 
     * @return ResultSet
     */
    public ResultSet undoLastCommand() {
        int managerView = _logicFace.getCurrentManagerView();
        ArrayList<String> commandsToRun = _logicFace.getCommandsToRun();
        ResultSet resultSet = new ResultSet();
        if (commandsToRun == null) {
            resultSet.setFail();
            return resultSet;
        }
        resultSet.setSuccess();
        if (commandsToRun.size() == 0) {
            _logicFace.switchView(managerView);
            updateChangesToViews(-1);
            return resultSet;
        }

        for (int i = 0; i < commandsToRun.size(); i++) {
            runCommands(commandsToRun.get(i));
        }
        _logicFace.switchView(managerView);
        updateChangesToViews(-1);
        _logicFace.undoComplete();
        return resultSet;
    }

    /**
     * Change the theme of all components.
     * 
     * @param styleSheet
     * @return ResultSet
     */
    public ResultSet changeTheme(String styleSheet) {
        _taskViewInterface.changeTheme(styleSheet);
        _descriptionComponent.changeTheme(styleSheet);
        _detailComponent.changeTheme(styleSheet);
        _floatingBarComponent.changeTheme(styleSheet);
        _floatingViewInterface.changeTheme(styleSheet);
        _searchViewInterface.changeTheme(styleSheet);
        _helpScreen.changeTheme(styleSheet);
        ResultSet resultSet = _logicFace.changeTheme(styleSheet);
        return resultSet;
    }

    public String loadTheme() {
        return _logicFace.loadTheme();
    }

    /**
     * Calls the logic component to load the new file. Kills all threads and
     * rebuild interface if loads returns true.
     * 
     * @param loadFrom
     * @return ResultSet
     */
    public ResultSet processLoadFrom(String loadFrom) {
        ResultSet resultSet = _logicFace.loadFrom(loadFrom);
        if (resultSet != null) {
            if (resultSet.isSuccess()) {
                _helpScreen.changeFilePath(_logicFace.getLoadFromFilePath());
                setManagerView(TASK_VIEW);
                _currentView = TASK_VIEW;
                killFloatingThread();
                int id = _logicFace.getNextTimeListId();
                updateChangesToViews(id);
                showMainView(-1);
                startFloatingThread();
            }
        }
        return resultSet;
    }

    /**
     * Process the enter command.
     * 
     * @return true only if selection is valid.
     */
    public boolean processEnter() {
        if (_currentView == SEARCH_VIEW) {
            TaskEntity task = _searchViewInterface.processEnter();
            if (task != null) {
                if (!task.isFloating()) {
                    setManagerView(TASK_VIEW);
                    _currentView = TASK_VIEW;
                    ArrayList<TaskEntity> tasks = _logicFace.getWorkingList();

                    for (int i = 0; i < tasks.size(); i++) {
                        if (task.getId() == tasks.get(i).getId()) {
                            updateChangesToViews(i);
                            showMainView(-1);
                            break;
                        }
                    }
                    return true;
                } else {
                    setManagerView(FLOATING_VIEW);
                    _currentView = FLOATING_VIEW;
                    ArrayList<TaskEntity> tasks = _logicFace.getWorkingList();
                    for (int i = 0; i < tasks.size(); i++) {
                        if (task.getId() == tasks.get(i).getId()) {
                            showFloatingView(i);
                            break;
                        }
                    }
                    return true;
                }
            }
        } else if (_currentView == ASSOCIATE_VIEW) {
            TaskEntity task = _detailComponent.processEnter();
            if (task != null) {
                setManagerView(TASK_VIEW);
                ArrayList<TaskEntity> tasks = _logicFace.getWorkingList();

                for (int i = 0; i < tasks.size(); i++) {
                    if (task.getId() == tasks.get(i).getId()) {
                        updateChangesToViews(i);
                        break;
                    }
                }
                return true;
            }
        }
        return false;
    }

    /**
     * Checks if the file given has loaded properly.
     * 
     * @return ResultSet
     */
    public ResultSet isFileLoadedProper() {
        if (!_isLoaded) {
            ResultSet rs = new ResultSet();
            rs.setFail();
            rs.setStatus(ResultSet.STATUS_BAD);
            return rs;
        }
        return null;
    }
}
```
###### src\userinterface\UserInterfaceExecuter.java
``` java
 * 
 *          This class is the only class that interacts with Logic component.
 */
package userinterface;

import java.util.ArrayList;
import java.util.Queue;
import entity.ResultSet;
import entity.TaskEntity;
import logic.TaskManagerInterface;

public class UserInterfaceExecuter {

    private TaskManagerInterface _taskManager = new TaskManagerInterface();

    /**
     * Gets the working list, depending on _currentView.
     * 
     * @return list of task (floating list, task list, search list)
     */
    public ArrayList<TaskEntity> getWorkingList() {
        return _taskManager.getWorkingList();
    }

    /**
     * Get the index of the most upcoming task in the working list.
     * 
     * @return index
     */
    public int getNextTimeListId() {
        return _taskManager.getNextTimeListId();
    }

    /**
     * Gets a random task from the floating list.
     * 
     * @return TaskEntity
     */
    public TaskEntity getRandomFloating() {
        return _taskManager.getRandomFloating();
    }

    /**
     * Switches the view in logic to switch all working lists to the selected
     * list.
     * 
     * @param displaySearch
     */
    public void switchView(int view) {
        _taskManager.switchView(view);
    }

    // commands execution //

    /**
     * Adds a task into the task list.
     * 
     * @param task
     * @param rawCommandWithView
     * @return ResultSet
     */
    public ResultSet addTask(TaskEntity task, String rawCommandWithView) {
        return _taskManager.add(task, rawCommandWithView);
    }

    /**
     * Deletes task based on _currentView and id.
     * 
     * @param id
     * @param rawCommandWithView
     * @return ResultSet
     */
    public ResultSet delete(String id, String rawCommandWithView) {
        if (id == null) {
            return null;
        }
        return _taskManager.delete(id, rawCommandWithView);
    }

    /**
     * Modifies the task base on _currentView and id.
     * 
     * @param idToModify
     * @param task
     * @param rawCommandWithView
     * @return ResultSet
     */
    public ResultSet modify(int idToModify, TaskEntity task, String rawCommandWithView) {
        return _taskManager.modify(idToModify, task, rawCommandWithView);
    }

    /**
     * Searches for the task that is similar to the search string.
     * 
     * @param stringToSearch
     * @param rawCommandWithView
     * @return ResultSet
     */
    public ResultSet searchString(String stringToSearch, String rawCommandWithView) {
        return _taskManager.searchString(stringToSearch, rawCommandWithView);
    }

    /**
     * Marks the given task based on id and the current workingList as
     * completed.
     * 
     * @param indexInt
     * @param rawCommandWithView
     * @return ResultSet
     */
    public ResultSet markAsDone(int indexInt, String rawCommandWithView) {
        return _taskManager.markAsDone(indexInt, rawCommandWithView);
    }

    /**
     * Links the task together.
     * 
     * @param taskEntity as project head
     * @param taskEntity2 as sub task
     * @param rawCommandWithView
     * @return ResultSet
     */
    public ResultSet link(TaskEntity taskEntity, TaskEntity taskEntity2, String rawCommandWithView) {
        return _taskManager.link(taskEntity, taskEntity2, rawCommandWithView);
    }

    /**
     * Changes the saving directory.
     * 
     * @param dirPath
     * @return ResultSet
     */
    public ResultSet changeSaveDir(String dirPath) {
        return _taskManager.changeDirectory(dirPath);
    }

    /**
     * Closes the manager and triggers saving of file.
     */
    public void closeTaskManager() {
        _taskManager.closeTaskManager();
    }

    /**
     * Gets all commands that have not been saved to file.
     * 
     * @return Queue<String>
     */
    public Queue<String> getBackedupCommands() {
        return _taskManager.getBackedupCommands();
    }

    /**
     * Gets all commands to run after an undo is executed.
     * 
     * @return ArrayList<String>
     */
    public ArrayList<String> getCommandsToRun() {
        return _taskManager.undo();
    }

    /**
     * Resets the state for undo.
     */
    public void undoComplete() {
        _taskManager.undoComplete();
    }

    /**
     * Changes the theme, saves theme preference in Configuration File.
     * 
     * @param styleSheet
     * @return ResultSet
     */
    public ResultSet changeTheme(String styleSheet) {
        return _taskManager.saveTheme(styleSheet);
    }

    /**
     * Loads file specified by user.
     * 
     * @param loadFrom
     * @return ResultSet
     */
    public ResultSet loadFrom(String loadFrom) {
        return _taskManager.loadFrom(loadFrom);
    }

    /**
     * Retrieves theme saved in Configuration File.
     * 
     * @return String
     */
    public String loadTheme() {
        return _taskManager.loadTheme();
    }

    /**
     * Gets filePath where file was loaded from.
     * 
     * @return String
     */
    public String getLoadFromFilePath() {
        return _taskManager.getMainFilePath();
    }

    /**
     * Checks if the file has loaded successfully.
     * 
     * @return true only if the file has loaded successfully
     */
    public boolean isFileLoadedSuccess() {
        return _taskManager.checkLoad();
    }

    /**
     * Gets the current view of the manager.
     * 
     * @return view
     */
    public int getCurrentManagerView() {
        return _taskManager.getView();
    }
}
```
###### src\userinterface\ViewInterface.java
``` java
 * 
 *          All user interface components controlled by the
 *          UserInterfaceController should implement this class.
 */
package userinterface;

import javafx.event.EventHandler;
import javafx.geometry.Rectangle2D;
import javafx.scene.input.MouseEvent;
import javafx.stage.Window;

public interface ViewInterface {

    public void initializeVaribles(Rectangle2D screenBounds, boolean isFixedSize);

    public void initializeStage(Window owner, int applicationX, int applicationY, int windowWidth,
            int windowHeight, EventHandler<MouseEvent> mouseEvent);

    public void update(int value);

    public void updateTranslateY(double posY);

    public void show();

    public void hide();

    public void changeTheme(String styleSheet);

}
```
###### target\classes\blackandwhite.css
``` css
.cssLabels,.cssLabelsFloatingBar,.cssLabelsFloatingTaskInterface,
.cssLabelsSearchView{
	-fx-text-fill:rgba(255,255,255,1.0);
	-fx-fill:rgba(255,255,255,1.0);
}
.cssLabelsDescription,.cssLabelsDetails,.cssLabelsCommandBar{
	-fx-text-fill:rgba(0,0,0,1.0);
	-fx-fill:rgba(0,0,0,1.0);
}

#cssCommandMainUserInput {
    -fx-background-color: rgba(0,0,0,1);
    -fx-font: 12.0px "Arial";
}

#commandText {
	-fx-font: 12.0px "Arial";
}

/* Help Screen */

#cssHelpScreenRoot{
	-fx-background-color: rgba(255.0,255.0,255.0,0.5);
}

#cssHelpComponentHighLighter{
	-fx-background-color: rgba(0.0,0.0,0.0,0.1);
	-fx-border-width: 1.0; 
	-fx-border-color: black;
}

#cssHelpComponentLinker{
	-fx-background-color: rgba(0.0,0.0,0.0,1.0);
}

#cssHelpComponentDescriptionBox{
	-fx-background-color: rgba(255.0,255.0,255.0,1.0);
	-fx-border-width: 1.0; 
	-fx-border-color: black;
}

#cssHelpTitle{
	-fx-text-fill: rgba(240.0,180.0,50.0,1.0);
	-fx-border-width: 0.0 0.0 1.0 0.0; 
	-fx-border-color: black;
}


#rootPane{
	-fx-border-color: #d3d3d3;
    -fx-border-width: 2.0px;
}

.controlFocus {
	-fx-border-color: #FF00FF;
	-fx-border-width: 2.0px;
}

/* css Task view  */
#cssTaskViewMainBackground{
	-fx-background-color: rgba(0,0,0,0.9);
}

#cssTaskViewWeekSelected{
	-fx-background-color: rgba(28, 22, 22,1);
}

#cssTaskViewWeekUnSelected{
	-fx-background-color: rgba(0,0,0,0.5);
}

#cssTaskViewDayBoxSelected{
}

#cssTaskViewDayBoxUnSelected{	
}

#cssTaskViewSelectedTask{
	-fx-background-radius: 20.0; 
	-fx-background-color:  rgba(255.0,178.5,127.5,0.3);
	-fx-background-insets: 1.0 5.0 1.0 5.0;
}

#cssTaskViewUnSelectedTask{
}

#cssTaskViewDayLabel{
	-fx-border-width: 0.0 0.0 1.0 0.0; 
	-fx-border-color: black;
}

/* css description panel */

#cssDescriptionLabelSelected{
	-fx-background-color:rgba(255.0,178.5,127.5,1);
}

#cssDescriptionLabelUnSelected{
	-fx-background-color:rgba(255,255,255,0.2);
}

#cssRootDescriptionViewMainBackground{
	-fx-background-color: rgba(0,0,0,0.9);
}



#cssDetailComponentRoot{
	-fx-background-color: rgba(0,0,0,0.9);
}

#cssDetailComponentRootAssociation{
	-fx-background-color: rgba(255.0,178.5,127.5,1),rgba(0,0,0,0.9);
	-fx-background-insets: 0,2;
}

#cssDetailComponentEmptyTitle {
	-fx-background-color: rgba(255.0,178.5,127.5,1.0);	
}

#cssDetailComponentProjectHeadBox{
	-fx-background-color: rgba(255.0,255.0,255.0,0.95);
}

#cssExpandedViewVBox{
	-fx-background-color: rgba(255.0,255.0,255.0,0.9);
	-fx-background-radius: 7.0;
	-fx-background-insets: 0.0 5.0 0.0 5.0;
}

#cssExpandedViewVBoxSelected{
	-fx-background-color: rgba(255.0,178.5,127.5,0.8);
	-fx-background-radius: 7.0;
	-fx-background-insets: 0.0 5.0 0.0 5.0;
}

#cssDetailAssociationListBox
{
	-fx-background-color: rgba(255.0,255.0,255.0,0.0);
	-fx-background-insets: 0.0 0.0 0.0 0.0;
}

/* Floating Bar CSS */
#cssRootFloatingBar{
	-fx-background-color: rgba(255.0,178.5,127.5,1.0), rgba(0,0,0,1);
	-fx-background-insets: 0.0,0.0 10.0 0.0 10.0;
}
#cssFloatingBarContentArea{
	-fx-border-width:  0.0 0.0 0.0 1.0; 
	-fx-border-color: black;
}

#cssFloatingBarTitleLabel{

}

/* Floating Task View CSS */

#cssRootFloatingTaskView{
	-fx-background-color: rgba(255.0,178.5,127.5,1.0),rgba(0,0,0,1.0);
	-fx-background-insets: 0.0,5.0;
}

#cssFloatingTaskViewTitle
{
	-fx-background-color: rgba(255.0,178.5,127.5,1.0);
}
#cssFloatingTaskViewSelected{
	-fx-background-radius: 20.0; 
	-fx-background-color:  rgba(255.0,178.5,127.5,0.3);
	-fx-background-insets: 1.0 7.0 1.0 7.0;
}

/* Search View CSS */
#cssRootSearchView{
	-fx-background-color: rgba(191.0, 80.0, 191.0,1.0,1.0),rgba(0,0,0,1.0);
	-fx-background-insets: 0.0,5.0;
}
#cssSearchTitle{
	-fx-background-color: rgba(191.0, 80.0, 191.0,1.0);
}

#cssSearchSelected{
	-fx-background-color: rgba(191.0, 80.0, 191.0,0.3);
	-fx-background-radius: 20.0; 
	-fx-background-insets: 1.0 7.0 1.0 7.0;
}

/* CommandsBar CSS */

#cssCommandBarMainStructure{
	-fx-background-color: rgba(0,0,0,1);
}

#cssCommandBarContentZone{
	-fx-border-width: 1.0 0.0 1.0 0.0; 
	-fx-border-color: black;
}

#cssCommandBarfeedback_normal
{
	-fx-background-color: rgba(179.0, 255.0, 153.0, 1.0);
}
#cssCommandBarfeedback_conflict
{
	-fx-background-color: rgba(249.0, 186.0, 122.0, 1.0);
}
#cssCommandBarfeedback_past{
	-fx-background-color: rgba(246.0, 246.0, 39.0, 1.0);
}

#cssCommandBarfeedback_conflict_past{
	-fx-background-color: rgba(180, 251.0, 212.0, 1.0);
}

#cssCommandBarfeedback_error
{
	-fx-background-color: rgba(249.0, 122.0, 122.0,1.0);
}

/* Commands CSS */

#cssCommandBarAdd {
	-fx-background-color: rgba(72.0, 238.0, 56.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
	
}

#cssCommandBarInvalid{
	-fx-text-fill:rgba(255.0,0.0,0.0,1.0);
}

#cssCommandBarDelete {
	-fx-background-color: rgba(56.0, 238.0, 223.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}

#cssCommandBarEdit {
	-fx-background-color: rgba(56.0, 163.0, 238.0, 0.5);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}

#cssCommandBarLink {
	-fx-background-color: rgba(163.0, 238.0, 56.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}

#cssCommandBarDone {
	-fx-background-color: rgba(238.0, 132.0, 56.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}

#cssCommandTitle {
	-fx-background-color: rgba(202.0, 247.0, 140.0, 1.0);
	-fx-background-radius: 7.0; 
}
#cssCommandDate {
	-fx-background-color: rgba(247.0, 140.0, 149.0, 1.0);
	-fx-background-radius: 7.0; 
}
#cssCommandHashTag{
	-fx-background-color: rgba(247.0, 238.0, 140.0, 1.0);
	-fx-background-radius: 7.0; 
}

#cssCommandID {
	-fx-background-color: rgba(247.0, 184.0, 140.0, 1.0);
	-fx-background-radius: 7.0; 
}
#cssCommandDescription {
	-fx-background-color: rgba(140.0, 202.0, 247.0, 1.0);
	-fx-background-radius: 7.0; 
}

#cssCommandJump {
	-fx-background-color: rgba(238.0, 56.0, 163.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}
#cssCommandSearch{
	-fx-background-color: rgba(132.0, 56.0, 238.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}

#cssCommandExit{
	-fx-text-fill:white;
	-fx-background-color: rgba(238.0, 56.0, 72.0, 1.0);
	-fx-font-weight:bold;
	 -fx-font: 20.0px "Arial";
}

#cssCommandFloat{
	-fx-background-color: rgba(238.0, 132.0, 56.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}
#cssCommandShow{
	-fx-background-color: rgba(223.0, 56.0, 238.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}
#cssCommandHide{
	-fx-background-color: rgba(223.0, 56.0, 238.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}
#cssCommandMain{
	-fx-background-color: rgba(238.0, 56.0, 163.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}
#cssCommandSaveDir{
	-fx-background-color: rgba(183.0, 220.0, 40.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}
#cssCommandUndo{
	-fx-background-color: rgba(240.0, 180.0, 20.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}

#cssCommandOther{
	-fx-text-fill:rgba(255,255,255,1.0);
}

#cssCommandTheme{
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(238.0, 120, 163.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}
#cssCommandLoadFrom{
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(183.0, 220.0, 40.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}
```
###### target\classes\default.css
``` css
.cssLabels,.cssLabelsDescription,.cssLabelsDetails,.cssLabelsFloatingBar,.cssLabelsFloatingTaskInterface,
.cssLabelsSearchView, .cssLabelsCommandBar{
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-fill:rgba(0.0,0.0,0.0,1.0);
}

#cssCommandMainUserInput {
    -fx-background-color: -fx-control-inner-background;
    -fx-font: 12.0px "Arial";
}

#commandText {
	-fx-font: 12.0px "Arial";
}

/* Help Screen */

#cssHelpScreenRoot{
	-fx-background-color: rgba(255.0,255.0,255.0,0.5);
}

#cssHelpComponentHighLighter{
	-fx-background-color: rgba(0.0,0.0,0.0,0.1);
	-fx-border-width: 1.0; 
	-fx-border-color: black;
}

#cssHelpComponentLinker{
	-fx-background-color: rgba(0.0,0.0,0.0,1.0);
}

#cssHelpComponentDescriptionBox{
	-fx-background-color: rgba(255.0,255.0,255.0,1.0);
	-fx-border-width: 1.0; 
	-fx-border-color: black;
}

#cssHelpTitle{
	-fx-text-fill: rgba(240.0,180.0,50.0,1.0);
	-fx-border-width: 0.0 0.0 1.0 0.0; 
	-fx-border-color: black;
}


#rootPane{
	-fx-border-color: #d3d3d3;
    -fx-border-width: 2.0px;
}

.controlFocus {
	-fx-border-color: #FF00FF;
	-fx-border-width: 2.0px;
}

/* css Task view  */
#cssTaskViewMainBackground{
	-fx-background-color: rgba(255.0,255.0,255.0,0.9);
}

#cssTaskViewWeekSelected{
	-fx-background-color: rgba(193.0,230.0,255.0,0.95);
}

#cssTaskViewWeekUnSelected{
	-fx-background-color: rgba(255.0,255.0,255.0,0.9);
}

#cssTaskViewDayBoxSelected{
}

#cssTaskViewDayBoxUnSelected{	
}

#cssTaskViewSelectedTask{
	-fx-background-radius: 20.0; 
	-fx-background-color:  rgba(255.0, 255.0, 255.0, 0.8);
	-fx-background-insets: 1.0 5.0 1.0 5.0;
}

#cssTaskViewUnSelectedTask{
}

#cssTaskViewDayLabel{
	-fx-border-width: 0.0 0.0 1.0 0.0; 
	-fx-border-color: black;
}

/* css expanded panel */
#cssExpandedViewVBox{
	-fx-background-color: rgba(255.0,255.0,255.0,0.9);
	-fx-background-radius: 7.0;
	-fx-background-insets: 0.0 5.0 0.0 5.0;
}

#cssExpandedViewVBoxSelected{
	-fx-background-color: rgba(255.0,230.0,255.0,1.0);
	-fx-background-radius: 7.0;
	-fx-background-insets: 0.0 5.0 0.0 5.0;
}

/* css description panel */

#cssRootDescriptionViewMainBackground{
	-fx-background-color: rgba(255.0,255.0,255.0,0.9);
}

#cssDescriptionLabelSelected{
	-fx-background-color:rgba(255.0,178.5,127.5,1.0);
}

#cssDescriptionLabelUnSelected{
	-fx-background-color:rgba(255.0,255.0,255.0,0.3);
}

/* Detail Componenet CSS */

#cssDetailComponentRoot{
	-fx-background-color: rgba(255.0,255.0,255.0,0.7),rgba(193.0,230.0,255.0,0.95);
}

#cssDetailComponentRootAssociation{
	-fx-background-color: rgba(255.0,178.5,127.5,1),rgba(255.0,255.0,255.0,0.7),rgba(193.0,230.0,255.0,0.95);
	-fx-background-insets: 0,2,2;
}

#cssDetailComponentEmptyTitle {
	-fx-background-color: rgba(255.0,178.5,127.5,1.0);	
}

#cssDetailComponentProjectHeadBox{
	-fx-background-color: rgba(255.0,255.0,255.0,0.95);
}

#cssDetailAssociationListBox{
	-fx-background-color: rgba(255.0,255.0,255.0,0.0);
	-fx-background-insets: 0.0 0.0 0.0 0.0;
}


/* Floating Bar CSS */

#cssRootFloatingBar{
	-fx-background-color: rgba(255.0,178.5,127.5,1.0), rgba(255.0,255.0,255.0,0.7);
	-fx-background-insets: 0.0,0.0 10.0 0.0 10.0;
}

#cssFloatingBarContentArea{
	-fx-border-width:  0.0 0.0 0.0 1.0; 
	-fx-border-color: black;
}

#cssFloatingBarTitleLabel{

}

/* Floating Task View CSS */

#cssRootFloatingTaskView{
	-fx-background-color: rgba(255.0,178.5,127.5,1.0),rgba(255.0,255.0,255.0,1.0);
	-fx-background-insets: 0.0,5.0;
}

#cssFloatingTaskViewTitle{
	-fx-background-color: rgba(255.0,178.5,127.5,1.0);
}

#cssFloatingTaskViewSelected{
	-fx-background-radius: 20.0; 
	-fx-background-color:  rgba(255.0,178.5,127.5,0.3);
	-fx-background-insets: 1.0 7.0 1.0 7.0;
}

/* Search View CSS */
#cssRootSearchView{
	-fx-background-color: rgba(191.0, 80.0, 191.0,1.0,1.0),rgba(255.0,255.0,255.0,1.0);
	-fx-background-insets: 0.0,5.0;
}

#cssSearchTitle{
	-fx-background-color: rgba(191.0, 80.0, 191.0,1.0);
}

#cssSearchSelected{
	-fx-background-color: rgba(191.0, 80.0, 191.0,0.3);
	-fx-background-radius: 20.0; 
	-fx-background-insets: 1.0 7.0 1.0 7.0;
}

/* CommandsBar CSS */

#cssCommandBarMainStructure{
	-fx-background-color: rgba(255.0,255.0,255.0,0.8);
}

#cssCommandBarContentZone{
	-fx-border-width: 1.0 0.0 1.0 0.0; 
	-fx-border-color: black;
}


#cssCommandBarfeedback_normal{
	-fx-background-color: rgba(179.0, 255.0, 153.0, 1.0);
}

#cssCommandBarfeedback_conflict{
	-fx-background-color: rgba(249.0, 186.0, 122.0, 1.0);
}

#cssCommandBarfeedback_past{
	-fx-background-color: rgba(246.0, 246.0, 39.0, 1.0);
}

#cssCommandBarfeedback_conflict_past{
	-fx-background-color: rgba(180.0, 251.0, 212.0, 1.0);
}

#cssCommandBarfeedback_error{
	-fx-background-color: rgba(249.0, 122.0, 122.0,1.0);
}

/* Commands CSS */

#cssCommandBarAdd {
	-fx-background-color: rgba(72.0, 238.0, 56.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}

#cssCommandBarInvalid{
	-fx-text-fill:rgba(255.0,0.0,0.0,1.0);
}

#cssCommandBarDelete {
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(56.0, 238.0, 223.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}

#cssCommandBarEdit {
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(56.0, 163.0, 238.0, 0.5);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}

#cssCommandBarLink {
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(163.0, 238.0, 56.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}

#cssCommandBarDone {
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(238.0, 132.0, 56.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}

#cssCommandTitle {
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(202.0, 247.0, 140.0, 1.0);
	-fx-background-radius: 7.0; 
}
#cssCommandDate {
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(247.0, 140.0, 149.0, 1.0);
	-fx-background-radius: 7.0; 
}
#cssCommandHashTag{
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(247.0, 238.0, 140.0, 1.0);
	-fx-background-radius: 7.0; 
}

#cssCommandID {
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(247.0, 184.0, 140.0, 1.0);
	-fx-background-radius: 7.0; 
}
#cssCommandDescription {
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(140.0, 202.0, 247.0, 1.0);
	-fx-background-radius: 7.0; 
}

#cssCommandJump {
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(238.0, 56.0, 163.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}
#cssCommandSearch{
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(132.0, 56.0, 238.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}

#cssCommandExit{
	-fx-text-fill:white;
	-fx-background-color: rgba(238.0, 56.0, 72.0, 1.0);
	-fx-font-weight:bold;
	 -fx-font: 20.0px "Arial";
}

#cssCommandFloat{
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(238.0, 132.0, 56.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}
#cssCommandShow{
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(223.0, 56.0, 238.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}
#cssCommandHide{
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(223.0, 56.0, 238.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}
#cssCommandMain{
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(238.0, 56.0, 163.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}
#cssCommandSaveDir{
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(183.0, 220.0, 40.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}
#cssCommandUndo{
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(240.0, 180.0, 20.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}

#cssCommandOther{
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
}

#cssCommandTheme{
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(238.0, 120.0, 163.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}
#cssCommandLoadFrom{
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(183.0, 220.0, 40.0, 1.0);
	-fx-font-weight:bold;
	-fx-background-radius: 7.0; 
}
```
