# A0126357A
###### src\entity\AllTaskLists.java
``` java
 *          AllTaskLists to facilitate passing of data from Logic to Storage and
 *          back.
 */

package entity;

import java.util.ArrayList;

public class AllTaskLists {

    private ArrayList<TaskEntity> mainTaskList;
    private ArrayList<TaskEntity> floatingTaskList;

    public AllTaskLists() {
        mainTaskList = new ArrayList<TaskEntity>();
        floatingTaskList = new ArrayList<TaskEntity>();
    }

    public AllTaskLists(ArrayList<TaskEntity> main, ArrayList<TaskEntity> floating) {
        setMainTaskList(main);
        setFloatingTaskList(floating);
    }

    public ArrayList<TaskEntity> getMainTaskList() {
        return mainTaskList;
    }

    public void setMainTaskList(ArrayList<TaskEntity> mainTaskList) {
        this.mainTaskList = mainTaskList;
    }

    public ArrayList<TaskEntity> getFloatingTaskList() {
        return floatingTaskList;
    }

    public void setFloatingTaskList(ArrayList<TaskEntity> floatingTaskList) {
        this.floatingTaskList = floatingTaskList;
    }
}
```
###### src\entity\ResultSet.java
``` java
 */
package entity;

public class ResultSet {
    private static final boolean SUCCESS = true;
    private static final boolean FAILURE = false;

    public final static int CALENDAR_VIEW = 0;
    public final static int TASK_VIEW = 1;
    public final static int EXPANDED_VIEW = 2;
    public final static int ASSOCIATE_VIEW = 3;
    public final static int FLOATING_VIEW = 4;
    public final static int SEARCH_VIEW = 5;

    public final static int STATUS_GOOD = 1;
    public final static int STATUS_BAD = 2;
    public final static int STATUS_CONFLICT = 3;
    public final static int STATUS_PAST = 4;
    public final static int STATUS_CONFLICT_AND_PAST = 5;
    public final static int STATUS_INVALID_NAME = 6;
    public final static int STATUS_NOFILE = 7;
    public final static int STATUS_INVALID_DATE = 8;
    public final static int STATUS_JSON_ERROR = 9;

    private int _index;
    private int _view;
    private int _status;
    private boolean _isSuccess;
    private int _searchCount;

    public ResultSet() {
        _index = -1;
    }

    public int getIndex() {
        return _index;
    }

    public void setIndex(int index) {
        _index = index;
    }

    public int getView() {
        return _view;
    }

    public void setView(int view) {
        _view = view;
    }

    public int getStatus() {
        return _status;
    }

    /**
     * Sets the status of ResultSet, keeping both warnings of CONFLICT and PAST
     * when set accordingly
     * 
     * @param status to set to
     */
    public void setStatus(int status) {
        // Statuses are added on rather than overwritten for warning messages
        if (status == STATUS_CONFLICT && _status == STATUS_PAST) {
            _status = STATUS_CONFLICT_AND_PAST;
        } else if (status == STATUS_PAST && _status == STATUS_CONFLICT) {
            _status = STATUS_CONFLICT_AND_PAST;
        } else if (status == STATUS_GOOD && (_status == STATUS_CONFLICT || _status == STATUS_PAST
                || _status == STATUS_CONFLICT_AND_PAST)) {
            // Do nothing - Keeps the warning messages not overwritten by good
            // outcomes
        } else {
            _status = status;
        }
    }

    public boolean isSuccess() {
        return _isSuccess;
    }

    public void setSuccess() {
        _isSuccess = SUCCESS;
    }

    public void setFail() {
        _isSuccess = FAILURE;
    }

    public void setSearchCount(int searchCount) {
        _searchCount = searchCount;
    }

    public int getSearchCount() {
        return _searchCount;
    }
}
```
###### src\entity\TaskEntity.java
``` java
 */
package entity;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;

import edu.emory.mathcs.backport.java.util.Collections;
import logic.TaskDateComparator;
import logic.TaskManager;
import logic.TaskUtils;

public class TaskEntity {
    public static final int NOT_ASSOCIATED = 0;
    public static final int ASSOCIATED = 1;
    public static final int PROJECT_HEAD = 2;

    private boolean _isFloating;
    private boolean _isFullDay;
    private Calendar _startDate;
    private Calendar _dueDate;
    private Calendar _dateCreated;
    private Calendar _completionDate;
    private String _name;
    private String _description;
    private int _id;
    private int _association_status;
    private boolean _isCompleted;

    private String _hashtags;
    private ArrayList<TaskEntity> _associations;
    private String _associationIDs;

    private static int currentId = 0;

    public static void setCurrentId(int newId) {
        currentId = newId;
    }

    public static int getCurrentId() {
        return currentId;
    }

    public int getId() {
        return _id;
    }

    public void setId(int id) {
        this._id = id;
    }

    public void setFloating(boolean isFloating) {
        this._isFloating = isFloating;
    }

    /**
     * Assigns an ID to the new object and record its created timing. ONLY to be
     * used by task's constructor
     */
    private void initCommonData() {
        _id = currentId;
        currentId++;
        _dateCreated = Calendar.getInstance();
        _association_status = NOT_ASSOCIATED;
        _associations = new ArrayList<TaskEntity>();
        _completionDate = Calendar.getInstance();
        // Tasks to have a default same value of completion date at the start
        _completionDate.set(0, 0, 0);
        _hashtags = "";
    }

    public TaskEntity() {
        initCommonData();

        _name = "";
        _description = "";
        _isFloating = true;
    }

    public TaskEntity(String name) {
        initCommonData();

        _name = name;
        _description = "";
        _isFloating = true;
    }

    public TaskEntity(String name, Calendar startDate, Calendar dueDate, boolean isFullDay) {
        initCommonData();

        _name = name;
        _description = "";
        _startDate = startDate;
        _dueDate = dueDate;
        _isFloating = false;
        _isFullDay = isFullDay;
    }

    public TaskEntity(String name, Calendar startDate, Calendar dueDate, boolean isFullDay,
            String description) {
        initCommonData();

        _name = name;
        _description = description;
        _startDate = startDate;
        _dueDate = dueDate;
        _isFullDay = isFullDay;
        _isFloating = false;
    }

    public TaskEntity(String name, String description) {
        initCommonData();

        _name = name;
        _description = description;
        _isFloating = true;
    }

    public TaskEntity(boolean isFloating, boolean isFullDay, Calendar startDate, Calendar dueDate,
            Calendar dateCreated, String name, String description, int id, int association_status,
            ArrayList<TaskEntity> associations, String associationIDs, boolean isCompleted,
            Calendar completionDate, String hashtags) {
        _isFloating = isFloating;
        _isFullDay = isFullDay;
        _startDate = startDate;
        _dueDate = dueDate;
        _dateCreated = dateCreated;
        _name = name;
        _description = description;
        _id = id;
        _association_status = association_status;
        _associations = associations;
        _associationIDs = associationIDs;
        _isCompleted = isCompleted;
        _completionDate = completionDate;
        _hashtags = hashtags;
    }

    public int getAssociationState() {
        return _association_status;
    }

    public ArrayList<TaskEntity> getAssociations() {
        return _associations;
    }

    /**
     * Mark a task as done and move the completed task into the
     * completedTaskEntities array.
     */
    public void markAsDone() {
        // Skip the whole process if it was already done in the first place
        if (_isCompleted) {
            return;
        }
        _isCompleted = true;
        _completionDate = Calendar.getInstance();
    }

    public boolean isCompleted() {
        return _isCompleted;
    }

    public Calendar getCompletionDate() {
        return _completionDate;
    }

    /**
     * Function to initialize associations array if it is null (Used for
     * overwriting it being set to null by the file loader)
     */
    public void initAssociations() {
        if (_associations == null) {
            _associations = new ArrayList<TaskEntity>();
        }
    }

    /**
     * Builds an ArrayList of all task's ID in associations for saving. Used to
     * rebuild associations on load from file
     * 
     * @return - ArrayList matching associations, but instead of having the task
     *         object, has its corresponding ID
     */
    public void buildAssociationsId() {
        _associationIDs = "";

        assert _associations != null : "Associations is null at build associations when saving task: "
                + getName();

        for (int i = 0; i < _associations.size(); i++) {
            _associationIDs += Integer.toString(_associations.get(i).getId()) + ",";
        }
        _associations = null;
    }

    public TaskEntity clone() {
        TaskEntity newInstance = new TaskEntity(_isFloating, _isFullDay, _startDate, _dueDate, _dateCreated,
                _name, _description, _id, _association_status, _associations, _associationIDs, _isCompleted,
                _completionDate, _hashtags);
        return newInstance;
    }

    public void addHashtag(String newTag) {
        if (_hashtags == null) {
            _hashtags = "";
        }
        _hashtags += newTag;
    }

    /**
     * Gets the saved string of IDs for the association list
     * 
     * @return String of all association IDs separated by a comma
     */
    public String getSavedAssociations() {
        return _associationIDs;
    }

    /**
     * Gets the task representing the project head
     * 
     * @return null if project head cant be found, or if this task is not under
     *         another task TaskEntity item that is he project head of this
     *         object
     */
    public TaskEntity getProjectHead() {
        if (_association_status == NOT_ASSOCIATED || _association_status == PROJECT_HEAD) {
            return null;
        } else {
            try {
                return _associations.get(0);
            } catch (IndexOutOfBoundsException e) {
                TaskManager.getInstance()
                        .logError("Error at TaskEntity.java: Associated task has no project head");
                return null;
            }
        }
    }

    /**
     * Function to link this object as a task under projectHead. Project heads
     * are not allowed to be under other tasks
     * 
     * @param projectHead
     *            - Task to be added under
     */
    public void setAssociationHead(TaskEntity projectHead) {
        if (_association_status == PROJECT_HEAD) {
            return;
        }

        if (_associations == null) {
            _associations = new ArrayList<TaskEntity>();
        } else {
            // Unlink from last project first
            removeSelfFromProject();
            _associations.clear();
        }
        // Tasks under other tasks only have the project head in their
        // associations array
        _associations.add(projectHead);
        _association_status = ASSOCIATED;
    }

    /**
     * Called when the project head is deleted
     * 
     * @return
     */
    public void disassociateFromDeletedProject() {
        _association_status = TaskEntity.NOT_ASSOCIATED;
        _associations.clear();
    }

    public boolean removeSelfFromProject() {
        if (getAssociationState() == TaskEntity.ASSOCIATED) {
            TaskEntity prevProjectHead = getAssociations().get(0);
            prevProjectHead.getAssociations().remove(this);
            return true;
        } else if (getAssociationState() == TaskEntity.PROJECT_HEAD) {
            for (int i = 0; i < _associations.size(); i++) {
                _associations.get(i).disassociateFromDeletedProject();
            }
            return true;
        } else {
            return false;
        }
    }

    /**
     * Function for init function to reload all the associations
     * 
     * @param taskToInsert
     *            - Task to be inserted into the associations list
     */
    public void loadAssociation(TaskEntity taskToInsert) {
        if (_associations == null) {
            _associations = new ArrayList<TaskEntity>();
        }
        _associations.add(taskToInsert);
    }

    /**
     * Function to link an object under this task
     * 
     * @param childTask
     *            - Task to be under this task
     * @return true if this task can be a project head false if this task is
     *         under another task and cannot be a project head
     */
    public boolean addAssociation(TaskEntity childTask) {
        if (_association_status == ASSOCIATED) {
            return false;
        } else {
            _association_status = PROJECT_HEAD;
            int idToInsert = findPositionToInsert(childTask);
            _associations.add(idToInsert, childTask);
            return true;
        }
    }

    /**
     * Gets this TaskEntity's position in its association list
     * 
     * @return slot number in the project head's _association array, or -1 if it
     *         doesn't belong to any projects
     */
    public int getAssociationPosition() {
        if (_association_status == PROJECT_HEAD) {
            return 0;
        } else if (_association_status == ASSOCIATED) {
            ArrayList<TaskEntity> displayedAssociations = getProjectHead().getAssociations();
            for (int i = 0; i < displayedAssociations.size(); i++) {
                if (displayedAssociations.get(i) == this) {
                    // i + 1 because accounting for project head being slotted
                    // into the first position of the list
                    return i + 1;
                }
            }
            return -1;
        } else {
            return -1;
        }
    }

    public ArrayList<TaskEntity> getDisplayAssociations() {
        if (_association_status == PROJECT_HEAD) {
            ArrayList<TaskEntity> displayedAssociations = (ArrayList<TaskEntity>) _associations.clone();
            displayedAssociations.add(0, this);
            return displayedAssociations;
        } else if (_association_status == ASSOCIATED) {
            ArrayList<TaskEntity> displayedAssociations = (ArrayList<TaskEntity>) getProjectHead()
                    .getAssociations().clone();
            displayedAssociations.add(0, getProjectHead());
            return displayedAssociations;
        } else {
            return new ArrayList<TaskEntity>();
        }
    }

    private int findPositionToInsert(TaskEntity newTask) {
        if (_associations == null) {
            _associations = new ArrayList<TaskEntity>();
        }
        int idToInsert = Collections.binarySearch(_associations, newTask, new TaskDateComparator());

        // Due to Collections.binarySearch's implementation, all objects
        // that can't be found will return a negative value, which indicates
        // the position where the object that is being searched is supposed
        // to be minus 1. This if case figures out the position to slot it in
        if (idToInsert < 0) {
            idToInsert = -(idToInsert + 1);
        }
        return idToInsert;
    }

    public String getName() {
        return _name;
    }

    /**
     * Prints the start date to a string for junit
     * 
     * @return String containing the date in DD/MM/YYYY
     */
    public String printStartDate() {
        String returnDate = "";
        if (_startDate != null) {
            returnDate += _startDate.get(Calendar.DAY_OF_MONTH) + "/";
            returnDate += _startDate.get(Calendar.MONTH) + "/";
            returnDate += _startDate.get(Calendar.YEAR);
        }
        return returnDate;
    }

    /**
     * Prints the due date to a string for junit
     * 
     * @return String containing the date in DD/MM/YYYY
     */
    public String printDueDate() {
        String returnDate = "";
        if (_dueDate != null) {
            returnDate += _dueDate.get(Calendar.DAY_OF_MONTH) + "/";
            returnDate += _dueDate.get(Calendar.MONTH) + "/";
            returnDate += _dueDate.get(Calendar.YEAR);
        }
        return returnDate;
    }

    public Calendar getDueDate() {

        if (!_isFloating) {
            return _dueDate;
        } else {
            System.out.println("Trying to get due date from a full day task");
            return null;
        }
    }

    public Calendar getStartDate() {
        if (!_isFloating) {
            return _startDate;
        } else {
            return null;
        }
    }

    public void setDate(Calendar dueDate, boolean isFullDay) {
        _isFloating = false;
        _startDate = null;
        _dueDate = dueDate;
        _isFullDay = isFullDay;
    }

    public void setDate(Calendar startDate, Calendar dueDate, boolean isFullDay) {
        _isFloating = false;
        _startDate = startDate;
        _dueDate = dueDate;
        _isFullDay = isFullDay;
    }

    public Calendar getDateCreated() {
        return _dateCreated;
    }

    public String getDescription() {
        if (_description == null) {
            _description = "";
        }
        return _description;
    }

    public void setDescription(String description) {
        _description = description;
    }

    public boolean isFloating() {
        return _isFloating;
    }

    public void setIfFullDay(boolean isFullDay) {
        _isFullDay = isFullDay;
    }

    public boolean isFullDay() {
        return _isFullDay;
    }

    /**
     * Adds a zero to the string to show time in double digit format
     * 
     * @param digit
     *            - Digit to be padded
     * @return String representation of the time passed in in double digit
     *         format
     */
    private String padZero(int time) {
        String displayedTime = "";
        if (time < 10) {
            displayedTime += "0";
        }
        displayedTime += Integer.toString(time);
        return displayedTime;
    }

    /**
     * Gets time display string for UI to print. Shows time if the duration is
     * within the same day, shows date if the duration crosses to different days
     * 
     * @return 15 character string representing the duration/dueDate of this
     *         task
     */
    public String getTime() {
        if (_isFloating) {
            return null;
        }

        if (_isFullDay) {
            return "[Full Day Task]";
        }

        if (_dueDate == null) {
            return "[Full Day Task]";
        } else if (_startDate == null) {
            SimpleDateFormat sdf = new SimpleDateFormat("HH:mm          ");
            return sdf.format(_dueDate.getTime());
        } else {
            return formatTimeDurations();
        }
    }

    /**
     * Formats the string when it has a start and end time. For getTime()
     * function
     * 
     * @return 15 char string containing year if the dates are different years,
     *         only time if they are the same day, and date if they are
     *         different days
     */
    private String formatTimeDurations() {
        String returnDate = "";
        SimpleDateFormat sdf;

        if (_startDate.get(Calendar.YEAR) != _dueDate.get(Calendar.YEAR)) {
            sdf = new SimpleDateFormat("[dd/MM/YY]");

        } else if (TaskUtils.checkSameDate(_startDate, _dueDate)) {
            sdf = new SimpleDateFormat(" HH:mm ");
        } else {
            sdf = new SimpleDateFormat("[dd/MM]");
        }
        returnDate += sdf.format(_startDate.getTime());
        returnDate += "-";
        returnDate += sdf.format(_dueDate.getTime());

        return returnDate;
    }

    public String getHashtags() {
        assert _hashtags != null : "Hash tag was set to null";
        if (_hashtags == null) {
            _hashtags = "";
        }
        return _hashtags;
    }
}
```
###### src\pastel.css
``` css
.cssLabels,.cssLabelsDescription,.cssLabelsDetails,.cssLabelsFloatingBar,.cssLabelsFloatingTaskInterface,
.cssLabelsSearchView, .cssLabelsCommandBar {
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-fill:rgba(0.0,0.0,0.0,1.0);
}

#cssCommandMainUserInput {
    -fx-background-color: -fx-control-inner-background;
    -fx-font: 12.0px "Arial";
}

#commandText {
	-fx-font: 12.0px "Arial";
}

/* Help Screen */
#cssHelpScreenRoot {
	-fx-background-color: rgba(255.0,255.0,255.0,0.5);
}

#cssHelpComponentHighLighter {
	-fx-background-color: rgba(0.0,0.0,0.0,0.1);
	-fx-border-width: 1.0; 
	-fx-border-color: black;
}

#cssHelpComponentLinker {
	-fx-background-color: rgba(0.0,0.0,0.0,1.0);
}

#cssHelpComponentDescriptionBox {
	-fx-background-color: rgba(255.0,255.0,255.0,1.0);
	-fx-border-width: 1.0; 
	-fx-border-color: black;
}

#cssHelpTitle {
	-fx-text-fill: rgba(240.0,180.0,50.0,1.0);
	-fx-border-width: 0.0 0.0 1.0 0.0; 
	-fx-border-color: black;
}


#rootPane {
	-fx-border-color: #d3d3d3;
    -fx-border-width: 2.0px;
}

.controlFocus {
	-fx-border-color: #FF00FF;
	-fx-border-width: 2.0px;
}

/* css Task view  */
#cssTaskViewMainBackground {
	-fx-background-color: rgba(255.0,255.0,255.0,0.9);
}

#cssTaskViewWeekSelected {
	-fx-background-color: rgba(219.0,190.0,248.0,0.95);
}

#cssTaskViewWeekUnSelected {
	-fx-background-color: rgba(248.0,190.0,248.0,0.5);
}

#cssTaskViewDayBoxSelected {
}

#cssTaskViewDayBoxUnSelected {	
}

#cssTaskViewSelectedTask {
	-fx-background-radius: 20.0; 
	-fx-background-color:  rgba(255.0, 255.0, 255.0, 1.0);
	-fx-background-insets: 1.0 5.0 1.0 5.0;
}

#cssTaskViewUnSelectedTask {
}

#cssTaskViewDayLabel {
	-fx-border-width: 0.0 0.0 1.0 0.0; 
	-fx-border-color: black;
}

/* css expanded panel */
#cssExpandedViewVBox {
	-fx-background-color: rgba(255.0,255.0,255.0,0.9);
	-fx-background-radius: 7.0;
	-fx-background-insets: 0.0 5.0 0.0 5.0;
}

#cssExpandedViewVBoxSelected {
	-fx-background-color: rgba(248.0,190.0,248.0,0.9);
	-fx-background-radius: 7.0;
	-fx-background-insets: 0.0 5.0 0.0 5.0;
}

/* css description panel */
#cssRootDescriptionViewMainBackground {
	-fx-background-color: rgba(255.0,255.0,255.0,0.9);
}

#cssDescriptionLabelSelected {
	-fx-background-color: rgba(255, 122, 137, 1.0);
}

#cssDescriptionLabelUnSelected {
	-fx-background-color: rgba(255.0,255.0,255.0,0.3);
}

/* Detail Componenet CSS */
#cssDetailComponentRoot {
	-fx-background-color: rgba(122.0,137.0,255.0,0.7),rgba(255.0,255.0,255.0,0.95);
}

#cssDetailComponentRootAssociation {
	-fx-background-color: rgba(203.0,203,250,1),rgba(255.0,255.0,255.0,0.7),rgba(193.0,230.0,255.0,0.95);
	-fx-background-insets: 0,2,2;
}

#cssDetailComponentEmptyTitle {
	-fx-background-color: rgba(255, 122, 137, 1.0);
}

#cssDetailComponentProjectHeadBox {
	-fx-background-color: rgba(255.0,255.0,255.0,0.95);
}

#cssDetailAssociationListBox {
	-fx-background-color: rgba(255.0,255.0,255.0,0.0);
	-fx-background-insets: 0.0 0.0 0.0 0.0;
}


/* Floating Bar CSS */
#cssRootFloatingBar {
	-fx-background-color: rgba(213, 21, 117, 0.4), rgba(255.0,255.0,255.0,0.7);
	-fx-background-insets: 0.0,0.0 10.0 0.0 10.0;
}

#cssFloatingBarContentArea {
	-fx-border-width: 0.0 0.0 0.0 1.0; 
	-fx-border-color: black;
}

#cssFloatingBarTitleLabel {
}

/* Floating Task View CSS */
#cssRootFloatingTaskView {
	-fx-background-color: rgba(213, 21, 117, 0.4),rgba(255.0,255.0,255.0,1.0);
	-fx-background-insets: 0.0,5.0;
}

#cssFloatingTaskViewTitle {
	-fx-background-color: rgba(255, 122, 137, 1.0);
}

#cssFloatingTaskViewSelected {
	-fx-background-radius: 20.0; 
	-fx-background-color:  rgba(255.0,178.5,127.5,0.3);
	-fx-background-insets: 1.0 7.0 1.0 7.0;
}

/* Search View CSS */
#cssRootSearchView {
	-fx-background-color: rgba(21, 213, 213, 0.4),rgba(255.0,255.0,255.0,1.0);
	-fx-background-insets: 0.0,5.0;
}

#cssSearchTitle {
	-fx-background-color: rgba(21, 213, 213, 0.4);
}

#cssSearchSelected {
	-fx-background-color: rgba(191.0, 80.0, 191.0,0.3);
	-fx-background-radius: 20.0; 
	-fx-background-insets: 1.0 7.0 1.0 7.0;
}

/* CommandsBar CSS */
#cssCommandBarMainStructure {
	-fx-background-color: rgba(255.0,255.0,255.0,0.8);
}

#cssCommandBarContentZone {
	-fx-border-width: 1.0 0.0 1.0 0.0; 
	-fx-border-color: black;
}


#cssCommandBarfeedback_normal {
	-fx-background-color: rgba(179.0, 255.0, 153.0, 1.0);
}

#cssCommandBarfeedback_conflict {
	-fx-background-color: rgba(249.0, 186.0, 122.0, 1.0);
}

#cssCommandBarfeedback_past {
	-fx-background-color: rgba(246.0, 246.0, 39.0, 1.0);
}

#cssCommandBarfeedback_conflict_past {
	-fx-background-color: rgba(180.0, 251.0, 212.0, 1.0);
}

#cssCommandBarfeedback_error {
	-fx-background-color: rgba(249.0, 122.0, 122.0,1.0);
}

/* Commands CSS */
#cssCommandBarAdd {
	-fx-background-color: rgba(72.0, 238.0, 56.0, 1.0);
	-fx-font-weight: bold;
	-fx-background-radius: 7.0; 
}

#cssCommandBarInvalid {
	-fx-text-fill: rgba(255.0,0.0,0.0,1.0);
}

#cssCommandBarDelete {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(56.0, 238.0, 223.0, 1.0);
	-fx-font-weight: bold;
	-fx-background-radius: 7.0; 
}

#cssCommandBarEdit {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(56.0, 163.0, 238.0, 0.5);
	-fx-font-weight: bold;
	-fx-background-radius: 7.0; 
}

#cssCommandBarLink {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(163.0, 238.0, 56.0, 1.0);
	-fx-font-weight: bold;
	-fx-background-radius: 7.0; 
}

#cssCommandBarDone {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(238.0, 132.0, 56.0, 1.0);
	-fx-font-weight: bold;
	-fx-background-radius: 7.0; 
}

#cssCommandTitle {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(202.0, 247.0, 140.0, 1.0);
	-fx-background-radius: 7.0; 
}

#cssCommandDate {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(247.0, 140.0, 149.0, 1.0);
	-fx-background-radius: 7.0; 
}

#cssCommandHashTag {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(247.0, 238.0, 140.0, 1.0);
	-fx-background-radius: 7.0; 
}

#cssCommandID {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(247.0, 184.0, 140.0, 1.0);
	-fx-background-radius: 7.0; 
}
#cssCommandDescription {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(140.0, 202.0, 247.0, 1.0);
	-fx-background-radius: 7.0; 
}

#cssCommandJump {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(238.0, 56.0, 163.0, 1.0);
	-fx-font-weight: bold;
	-fx-background-radius: 7.0; 
}

#cssCommandSearch {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(132.0, 56.0, 238.0, 1.0);
	-fx-font-weight: bold;
	-fx-background-radius: 7.0; 
}

#cssCommandExit {
	-fx-text-fill: white;
	-fx-background-color: rgba(238.0, 56.0, 72.0, 1.0);
	-fx-font-weight: bold;
	 -fx-font: 20.0px "Arial";
}

#cssCommandFloat {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(238.0, 132.0, 56.0, 1.0);
	-fx-font-weight: bold;
	-fx-background-radius: 7.0; 
}

#cssCommandShow {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(223.0, 56.0, 238.0, 1.0);
	-fx-font-weight: bold;
	-fx-background-radius: 7.0; 
}

#cssCommandHide {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(223.0, 56.0, 238.0, 1.0);
	-fx-font-weight: bold;
	-fx-background-radius: 7.0; 
}

#cssCommandMain {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(238.0, 56.0, 163.0, 1.0);
	-fx-font-weight: bold;
	-fx-background-radius: 7.0; 

}
 
#cssCommandSaveDir {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(183.0, 220.0, 40.0, 1.0);
	-fx-font-weight: bold;
	-fx-background-radius: 7.0; 
}

#cssCommandUndo {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(240.0, 180.0, 20.0, 1.0);
	-fx-font-weight: bold;
	-fx-background-radius: 7.0; 
}

#cssCommandOther {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
}

#cssCommandTheme {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(238.0, 120.0, 163.0, 1.0);
	-fx-font-weight: bold;
	-fx-background-radius: 7.0; 
}

#cssCommandLoadFrom {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(183.0, 220.0, 40.0, 1.0);
	-fx-font-weight: bold;
	-fx-background-radius: 7.0; 
}
```
###### src\storage\JsonConverter.java
``` java
 * 
 *          JsonConverter converts Java to JSON and from JSON to Java via GSON.
 *          This is to facilitate easy saving and retrieving of data.
 */

package storage;

import java.util.ArrayList;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonParseException;
import com.google.gson.reflect.TypeToken;

import entity.AllTaskLists;
import entity.TaskEntity;

public class JsonConverter {

    public JsonConverter() {

    }

    /**
     * Converts Java Object to JSON format via the GSON builder.
     * String returned will include nulls for empty fields.
     * 
     * @param allLists takes in a working AllTaskLists.
     * @return appendedToJson returns String in JSON format.
     */
    public String javaToJson(AllTaskLists allLists) {
        ArrayList<TaskEntity> mainTaskList = allLists.getMainTaskList();
        ArrayList<TaskEntity> floatingTaskList = allLists.getFloatingTaskList();
        ArrayList<TaskEntity> appendedList = new ArrayList<TaskEntity>();

        appendedList.addAll(mainTaskList);
        appendedList.addAll(floatingTaskList);

        GsonBuilder gsonBuilder = new GsonBuilder().setPrettyPrinting().serializeNulls();
        Gson gson = gsonBuilder.create();

        String appendedToJson = gson.toJson(appendedList);
        assert appendedToJson != null;

        return appendedToJson;
    }

    /**
     * Converts JSON format to Java Object via the GSON library.
     * This method returns a null AllTaskLists if the String input is not in
     * JSON format.
     * 
     * @param input Takes in String read from file.
     * @return allLists returns an AllTaskLists containing two ArrayLists of
     *         main and floating tasks.
     */
    public AllTaskLists jsonToJava(String input) {
        Gson gson = new Gson();
        AllTaskLists allLists = new AllTaskLists();

        try {
            // Load JSON string into custom object using TypeToken
            ArrayList<TaskEntity> allTasks = gson.fromJson(input, new TypeToken<ArrayList<TaskEntity>>() {
            }.getType());
            allLists = extractJsonFields(allLists, allTasks);
        } catch (JsonParseException e) {
            System.out.println("Cannot convert from Json to Java.");
            return null;
        }
        return allLists;
    }

    private AllTaskLists extractJsonFields(AllTaskLists allLists, ArrayList<TaskEntity> allTasks) {
        if (allTasks != null) {
            ArrayList<TaskEntity> mainTaskList = new ArrayList<TaskEntity>();
            ArrayList<TaskEntity> floatingTaskList = new ArrayList<TaskEntity>();

            separateMainAndFloating(allTasks, mainTaskList, floatingTaskList);
            allLists = new AllTaskLists(mainTaskList, floatingTaskList);
        }
        return allLists;
    }

    private void separateMainAndFloating(ArrayList<TaskEntity> allTasks, ArrayList<TaskEntity> mainTaskList,
            ArrayList<TaskEntity> floatingTaskList) {
        for (int i = 0; i < allTasks.size(); i++) {
            if (allTasks.get(i).isFloating() == true) {
                floatingTaskList.add(allTasks.get(i));
            } else {
                mainTaskList.add(allTasks.get(i));
            }
        }
    }
}
```
###### src\storage\StorageController.java
``` java
 * 
 *          StorageController to create instances of StorageHandler and
 *          JsonConverter to merge functionalities.
 */

package storage;

import java.util.ArrayList;
import java.util.Queue;

import entity.AllTaskLists;
import entity.ResultSet;
import entity.TaskEntity;

public class StorageController {

    public StorageHandler storageHandler;
    private static final int STORAGE_WRITE_TO_MAIN_FILE = 2;
    private static final int UI_SEARCH_VIEW = 4;
    private static final int STORAGE_COMMAND_QUEUE_SIZE = 5;

    /**
     * Class constructor.
     */
    public StorageController() {
        storageHandler = new StorageHandler();
    }

    // ============================================================================
    // Handling main file
    // ============================================================================

    /**
     * Retrieves all tasks previously saved in the Main Task File.
     * 
     * @return retrievedList returns an AllTaskLists containing both main and
     *         floating ArrayLists.
     */
    public AllTaskLists getTaskLists() {
        JsonConverter jsonConverter = new JsonConverter();

        String retrievedTasks = storageHandler.getAllStoredTasks();
        AllTaskLists retrievedList = jsonConverter.jsonToJava(retrievedTasks);

        return retrievedList;
    }

    /**
     * Returns true if tasks are written to Main Task File, false otherwise.
     * This method stores all working tasks into the Main Task File.
     * 
     * @param allTaskLists takes in an AllTaskLists containing both main and
     *            floating ArrayLists.
     * @return isSaved returns true if written to file, false otherwise.
     */
    public boolean storeTaskLists(AllTaskLists allTaskLists) {
        JsonConverter jsonConverter = new JsonConverter();

        String toStore = jsonConverter.javaToJson(allTaskLists);

        boolean isSaved = storageHandler.identifyWriteTo(toStore, STORAGE_WRITE_TO_MAIN_FILE);
        assert isSaved == true : "Tasks not stored.";

        return isSaved;
    }

    /**
     * Takes in two ArrayLists, main and floating, combines them into an
     * AllTaskLists, and stores them into the Main Task File.
     * 
     * @param main
     * @param floating
     * @return isSaved returns true if written to file, false otherwise.
     */
    public boolean storeTaskLists(ArrayList<TaskEntity> main, ArrayList<TaskEntity> floating) {
        AllTaskLists newList = new AllTaskLists();

        newList.setFloatingTaskList(floating);
        newList.setMainTaskList(main);

        return storeTaskLists(newList);
    }

    // ============================================================================
    // Handling back up file
    // ============================================================================

    /**
     * Retrieves user's tasks from the Back Up File.
     * 
     * @return retrievedList returns an AllTaskLists containing both main and
     *         floating ArrayLists.
     */
    public AllTaskLists getBackUpTaskLists() {
        JsonConverter jsonConverter = new JsonConverter();

        String retrievedTasks = storageHandler.getAllBackUpTasks();
        AllTaskLists retrievedList = jsonConverter.jsonToJava(retrievedTasks);

        return retrievedList;
    }

    /**
     * Deletes Back Up File, to be done after every session.
     */
    public void deleteBackUp() {
        storageHandler.deleteBackUpFile();
    }

    // ============================================================================
    // Handling command file
    // ============================================================================

    /**
     * Returns true if command queue is full and the last command is not in
     * UI_SEARCH_VIEW = 4, false otherwise.
     * This method also offers the new command to the existing command queue.
     * 
     * @param command takes in and stores user's input.
     * @return isFullQueue
     */
    public boolean saveUponFullQueue(String command) {
        singleCommandSavedChecker(command);

        Queue<String> newCommandsQueue = getCommandsQueue();
        newCommandsQueue.offer(command);
        setCommandsQueue(newCommandsQueue);

        boolean isFullQueue = queueFullChecker(command, newCommandsQueue);
        return isFullQueue;
    }

    /**
     * Checks if conditions for committing into Main Task File is met.
     * 
     * @param command
     * @param newCommandsQueue
     * @return isFullQueue
     */
    private boolean queueFullChecker(String command, Queue<String> newCommandsQueue) {
        boolean isFullQueue = false;

        String[] splitCommand = command.split(" ");
        if (isSearchView(splitCommand) == false && isFullQueue(newCommandsQueue)) {
            isFullQueue = true;
        }
        return isFullQueue;
    }

    /**
     * Takes in a command queue and checks if it is more than or equals to
     * QUEUE_SIZE = 20.
     * 
     * @param newCommandsQueue
     * @return isFullQueue returns true if Queue is more than or equals to
     *         QUEUE_SIZE = 20, false otherwise.
     */
    private boolean isFullQueue(Queue<String> newCommandsQueue) {
        return newCommandsQueue.size() >= STORAGE_COMMAND_QUEUE_SIZE;
    }

    /**
     * Checks if UI is in Search View.
     * This method returns true if UI is in search view, false otherwise.
     * 
     * @param splitCommand takes in first int of command.
     * @return isSearchView returns true if UI is in Search View, false
     *         otherwise.
     */
    private boolean isSearchView(String[] splitCommand) {
        return splitCommand[0].equals(UI_SEARCH_VIEW);
    }

    /**
     * Checks if the command has been written to Command File.
     * 
     * @param command takes in one line of user's input command.
     */
    private void singleCommandSavedChecker(String command) {
        boolean isSaved = storeCommandLine(command);
        if (isSaved == false) {
            System.out.println("============================");
            System.out.println("***DID NOT WRITE TO FILE***");
            System.out.println("============================");
        }
    }

    public boolean storeCommandLine(String command) {
        return storageHandler.writeToCommandFile(command);
    }

    public Queue<String> getCommandsQueue() {
        return storageHandler.getAllCommandsQueue();
    }

    public void setCommandsQueue(Queue<String> newCommandsQueue) {
        storageHandler.setAllCommandsQueue(newCommandsQueue);
    }

    public void clearCommandFileOnCommit() {
        storageHandler.clearCommandFileUponCommit();
    }

    public void clearCommandFile() {
        storageHandler.clearCommandFile();
    }

    // ============================================================================
    // Changing directory
    // ============================================================================

    public ResultSet saveToNewDirectory(String newFilePath) {
        return storageHandler.changeDirectory(newFilePath);
    }

    public boolean loadFromSpecifiedFile(String newFilePath) {
        return storageHandler.loadFromExistingFile(newFilePath);
    }

    public String getMainFilePath() {
        return storageHandler.getMainFilePath();
    }

    // ============================================================================
    // Saving theme
    // ============================================================================

    public boolean saveThemePreference(String themeName) {
        return storageHandler.saveThemeName(themeName);
    }

    public String getThemePreference() {
        return storageHandler.getThemeName();
    }
}
```
###### src\storage\StorageHandler.java
``` java
 * 
 *          StorageHandler to handle reading, writing and changing directory of
 *          files. Four files involved: Configuration File, Main Task File, Back
 *          Up Task File and Command File.
 */

package storage;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

import java.util.LinkedList;
import java.util.Queue;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;

import entity.ResultSet;

public class StorageHandler {

    private String configFilePath;
    private String tasksFilePath;
    private String commandsFilePath;
    private String backUpTasksFilePath;

    private File configFile;
    private File tasksFile;
    private File commandsFile;
    private File backUpTasksFile;

    private String allStoredTasks;
    private String allBackUpTasks;
    private Queue<String> allCommandsQueue = new LinkedList<String>();

    private String themeName;

    private Logger logger;
    private FileHandler fileHandler;

    private static final int READ_FROM_CONFIG_FILE = 1;
    private static final int READ_FROM_MAIN_FILE = 2;
    private static final int READ_FROM_BACK_UP_FILE = 3;
    private static final int WRITE_TO_CONFIG_FILE = 1;
    private static final int WRITE_TO_MAIN_FILE = 2;
    private static final int WRITE_TO_BACK_UP_FILE = 3;

    private static final int FILE_ALREADY_EXISTS = -1;
    private static final int RESULT_SET_FALSE = 0;

    private static final String CONFIG_FILE_NAME = "configFile.txt";
    private static final String MAIN_FILE_NAME = "mainTasksFile.txt";
    private static final String BACK_UP_FILE_NAME = "backUpTasksFile.txt";
    private static final String COMMAND_FILE_NAME = "commandsFile.txt";
    private static final String DEFAULT_THEME = "default";
    private static final String NEW_LINE = "\n";

    /**
     * Class constructor.
     */
    public StorageHandler() {
        initLogger();
        processFile();
    }

    // ============================================================================
    // Getters and setters
    // ============================================================================

    public String getMainFilePath() {
        return tasksFilePath;
    }

    public void setMainFilePath(String filePath) {
        this.tasksFilePath = filePath;
    }

    public String getAllStoredTasks() {
        return allStoredTasks;
    }

    public void setAllStoredTasks(String allStoredTasks) {
        this.allStoredTasks = allStoredTasks;
    }

    public String getAllBackUpTasks() {
        return allBackUpTasks;
    }

    public Queue<String> getAllCommandsQueue() {
        return allCommandsQueue;
    }

    public void setAllCommandsQueue(Queue<String> allCommandsQueue) {
        this.allCommandsQueue = allCommandsQueue;
    }

    public String getThemeName() {
        return themeName;
    }

    public void setThemeName(String themeName) {
        this.themeName = themeName;
    }

    // ============================================================================
    // Initialising and creating new files
    // ============================================================================

    /**
     * Initialises Configuration File, Main Task File, Back Up Task File and
     * Command File.
     */
    private void processFile() {
        logger.log(Level.INFO, "Processing file...");
        initConfigFile();
        initMainFile();
        initBackUpFile();
        initCommandFile();
    }

    /**
     * Initialises Configuration File containing the absolute directory of the
     * Main Task File and theme name.
     */
    private void initConfigFile() {
        configFilePath = CONFIG_FILE_NAME;
        configFile = new File(configFilePath);

        if (isExists(configFile)) {
            extractConfigSettings();
            tasksFile = new File(tasksFilePath);
        } else {
            logger.log(Level.INFO, "Creating new config file...");
            createNewFile(configFile);
            tasksFilePath = MAIN_FILE_NAME;
            tasksFile = new File(tasksFilePath);
            setMainFilePath(tasksFile.getAbsolutePath());
            themeName = DEFAULT_THEME;
            writeConfigSettings();
        }
    }

    /**
     * Writes current settings into Configuration File.
     * 
     * @return isWritten returns true if settings successfully written into
     *         Configuration File, false otherwise.
     */
    private boolean writeConfigSettings() {
        return identifyWriteTo(tasksFilePath + NEW_LINE + themeName, WRITE_TO_CONFIG_FILE);
    }

    /**
     * Takes in settings from Configuration File and splits them into Main Task
     * File directory and theme name.
     */
    private void extractConfigSettings() {
        String settings = readFromExistingFile(READ_FROM_CONFIG_FILE);
        String[] settingsSplit = settings.split(NEW_LINE);
        setMainFilePath(settingsSplit[0]);
        setThemeName(settingsSplit[1]);
    }

    /**
     * Initialises Main Task File containing user's tasks.
     * This method creates a new file if an existing file is not found, or reads
     * from the existing file otherwise.
     */
    private void initMainFile() {
        if (isExists(tasksFile)) {
            setAllStoredTasks(readFromExistingFile(READ_FROM_MAIN_FILE));
        } else {
            logger.log(Level.INFO, "Creating new main file...");
            makeNewDirectory(tasksFile);
            createNewFile(tasksFile);
            setMainFilePath(tasksFile.getAbsolutePath());
        }
    }

    /**
     * Initialises Back Up Task File for 'Undo' function.
     * The Back Up Task File created is a temporary file that will be deleted
     * after every session.
     */
    private void initBackUpFile() {
        backUpTasksFilePath = BACK_UP_FILE_NAME;
        backUpTasksFile = new File(backUpTasksFilePath);

        // Temporary back up file to be deleted after every session
        if (isExists(backUpTasksFile) == true) {
            deleteBackUpFile();
        }
        logger.log(Level.INFO, "Creating new back up file...");
        createNewFile(backUpTasksFile);
        copyToBackUp();
    }

    /**
     * Initialises Command File storing all user's inputs for data recovery
     * purposes.
     */
    private void initCommandFile() {
        commandsFilePath = COMMAND_FILE_NAME;
        commandsFile = new File(commandsFilePath);

        if (isExists(commandsFile)) {
            setAllCommandsQueue(readFromExistingCommandFile());
        } else {
            logger.log(Level.INFO, "Creating new command file...");
            createNewFile(commandsFile);
        }
    }

    private boolean createNewFile(File file) {
        boolean isCreated = false;

        try {
            isCreated = file.createNewFile();
        } catch (IOException e) {
            logger.log(Level.SEVERE, "Creating new file failed.");
            e.printStackTrace();
        }
        return isCreated;
    }

    private boolean makeNewDirectory(File file) {
        boolean isCreated = false;

        if (hasDirectory(file) == false) {
            if (file.getParentFile() != null) {
                isCreated = file.getParentFile().mkdirs();
            }
        }
        logger.log(Level.WARNING, "New directory is created: " + isCreated);
        return isCreated;
    }

    private boolean hasDirectory(File file) {
        return file.isDirectory();
    }

    public boolean isExists(File file) {
        return file.exists();
    }

    // ============================================================================
    // Reading from existing files
    // ============================================================================

    private BufferedReader identifyReadFrom(int fromFile) throws FileNotFoundException {
        BufferedReader buffer = null;
        switch (fromFile) {
            case READ_FROM_MAIN_FILE :
                logger.log(Level.INFO, "Reading from main file...");
                buffer = new BufferedReader(new FileReader(tasksFilePath));
                break;
            case READ_FROM_BACK_UP_FILE :
                logger.log(Level.INFO, "Reading from back up file...");
                buffer = new BufferedReader(new FileReader(backUpTasksFilePath));
                break;
            case READ_FROM_CONFIG_FILE :
                logger.log(Level.INFO, "Reading from config file...");
                buffer = new BufferedReader(new FileReader(configFilePath));
                break;
        }
        return buffer;
    }

    /**
     * Reads data from an existing file and returns the appended String.
     * 
     * @param fromFile int representing the file read from.
     * @return readData returns String of data read from the specified file.
     */
    public String readFromExistingFile(int fromFile) {
        BufferedReader buffer;
        String readData = "";
        try {
            buffer = identifyReadFrom(fromFile);
            readData = readString(buffer, readData);
            buffer.close();
        } catch (FileNotFoundException e) {
            logger.log(Level.SEVERE, "FileNotFoundException: " + fromFile);
            e.printStackTrace();
        } catch (IOException e) {
            logger.log(Level.SEVERE, "IOException: " + fromFile);
            e.printStackTrace();
        }
        return readData.trim();
    }

    private String readString(BufferedReader buffer, String readData) throws IOException {
        String currentLine;
        while ((currentLine = buffer.readLine()) != null) {
            readData = readData + currentLine + NEW_LINE;
        }
        return readData;
    }

    /**
     * Reads commands from an existing Command File and returns a command queue.
     * 
     * @return readCommands
     */
    public Queue<String> readFromExistingCommandFile() {
        Queue<String> readCommands = new LinkedList<String>();
        BufferedReader buffer;
        try {
            logger.log(Level.INFO, "Reading from command file...");
            buffer = new BufferedReader(new FileReader(commandsFilePath));
            readQueue(readCommands, buffer);
            buffer.close();
        } catch (FileNotFoundException e) {
            logger.log(Level.SEVERE, "FileNotFoundException for command file.");
            e.printStackTrace();
        } catch (IOException e) {
            logger.log(Level.SEVERE, "IOException for command file.");
            e.printStackTrace();
        }
        return readCommands;
    }

    private void readQueue(Queue<String> readCommands, BufferedReader buffer) throws IOException {
        String currentLine;
        while ((currentLine = buffer.readLine()) != null) {
            readCommands.offer(currentLine);
        }
    }

    /**
     * Copies data from the Main Task File to Back Up Task File to facilitate
     * 'Undo' function.
     * 
     * @return isWritten returns true if settings successfully written into
     *         Configuration File, false otherwise.
     */
    public boolean copyToBackUp() {
        allBackUpTasks = readFromExistingFile(READ_FROM_MAIN_FILE);
        return identifyWriteTo(allBackUpTasks, WRITE_TO_BACK_UP_FILE);
    }

    // ============================================================================
    // Writing to files
    // ============================================================================

    /**
     * Identifies which file to write to based on an int.
     * This method returns true if the data is written into the file, false
     * otherwise.
     * Whether the data has been written into the file depends on its last
     * modified time.
     * 
     * @param data String to be written into file.
     * @param toFile int representing the file to write to.
     * @return isWritten returns true if settings successfully written into
     *         Configuration File, false otherwise.
     */
    public boolean identifyWriteTo(String data, int toFile) {
        File file = null;
        String filePath = null;
        switch (toFile) {
            case WRITE_TO_MAIN_FILE :
                logger.log(Level.INFO, "Writing to main file...");
                file = new File(tasksFilePath);
                filePath = tasksFilePath;
                break;
            case WRITE_TO_BACK_UP_FILE :
                logger.log(Level.INFO, "Writing to back up file...");
                file = backUpTasksFile;
                filePath = backUpTasksFilePath;
                break;
            case WRITE_TO_CONFIG_FILE :
                logger.log(Level.INFO, "Writing to config file...");
                file = configFile;
                filePath = configFilePath;
                break;
        }
        return isWritten(data, file, filePath);
    }

    /**
     * Returns true if file is modified and data is written into file, false
     * otherwise
     * 
     * @param data
     * @param file file written to.
     * @param filePath directory of the file written to.
     * @return isModified returns true if time after modification is after time
     *         before modification, false otherwise.
     */
    private boolean isWritten(String data, File file, String filePath) {
        long beforeModify = file.lastModified();
        long afterModify = -1;
        afterModify = writeToFile(data, file, filePath, afterModify);
        return isModified(beforeModify, afterModify);
    }

    private long writeToFile(String data, File file, String filePath, long afterModify) {
        FileWriter fileWriter;
        try {
            fileWriter = new FileWriter(filePath);
            fileWriter.write(data);
            fileWriter.flush();
            fileWriter.close();
            afterModify = file.lastModified();
        } catch (IOException e) {
            logger.log(Level.SEVERE, "IOException when writing.");
            e.printStackTrace();
        }
        return afterModify;
    }

    /**
     * Returns true if commands are written to the Command File, false
     * otherwise.
     * 
     * @param command String of user's input.
     * @return isModified returns true if time after modification is after time
     *         before modification, false otherwise.
     */
    public boolean writeToCommandFile(String command) {
        FileWriter fileWriter;
        long beforeModify = commandsFile.lastModified();
        long afterModify = -1;
        try {
            // True to append to file
            fileWriter = new FileWriter(commandsFilePath, true);
            fileWriter.write(command + NEW_LINE);
            fileWriter.flush();
            fileWriter.close();
            afterModify = commandsFile.lastModified();
        } catch (IOException e) {
            logger.log(Level.SEVERE, "IOException when writing.");
            e.printStackTrace();
        }
        return isModified(beforeModify, afterModify);
    }

    /**
     * Returns true if timeAfterMod is after timeBeforeMod, false otherwise.
     * 
     * @param timeBeforeModification
     * @param timeAfterModification
     * @return isModified returns true if time after modification is after time
     *         before modification, false otherwise.
     */
    private boolean isModified(long timeBeforeModification, long timeAfterModification) {
        return timeAfterModification > timeBeforeModification;
    }

    // ============================================================================
    // Clearing and removing files
    // ============================================================================

    /**
     * Clears Command File upon committing.
     */
    public void clearCommandFileUponCommit() {
        clearCommandFile();
        allCommandsQueue.clear();
    }

    /**
     * Clears Command File upon committing.
     */
    public void clearCommandFile() {
        logger.log(Level.INFO, "Clearing command file...");
        FileWriter fileWriter;
        try {
            fileWriter = new FileWriter(commandsFilePath);
            fileWriter.write("");
            fileWriter.flush();
            fileWriter.close();
        } catch (IOException e) {
            logger.log(Level.SEVERE, "IOException when clearing.");
            e.printStackTrace();
        }
    }

    public void deleteBackUpFile() {
        backUpTasksFile.delete();
    }

    // ============================================================================
    // Changing file directory
    // ============================================================================

    /**
     * Saves user's tasks to a new Main Task File and updates the Configuration
     * File with the new directory.
     * This method returns FILE_ALREADY_EXISTS = -1 when the file specified
     * already exists,
     * a success ResultSet if directory is successfully changed,
     * a fail ResultSet when a new file or directory cannot be created.
     * 
     * @param newFilePath
     * @return resultSet
     */
    public ResultSet changeDirectory(String newFilePath) {
        boolean isChanged = false;
        ResultSet resultSet = new ResultSet();
        resultSet.setIndex(RESULT_SET_FALSE);

        logger.log(Level.INFO, "Setting new file path...");
        File newFile = new File(newFilePath);

        isChanged = newFileExistsChecker(resultSet, isChanged, newFile);
        if (isChanged == true) {
            isChanged = writeConfigSettings();
        }
        resultSetChecker(resultSet, isChanged);
        return resultSet;
    }

    /**
     * Checks if new file specified by user exists.
     * 
     * @param resultSet
     * @param isChanged
     * @param newFile
     * @return isChanged returns true if the new file specified by user exists,
     *         false otherwise.
     */
    private boolean newFileExistsChecker(ResultSet resultSet, boolean isChanged, File newFile) {
        if (newFile.exists() == false) {
            isChanged = transferToNewFile(newFile);
        } else {
            logger.log(Level.WARNING, "File already exists. Saving failed.");
            resultSet.setIndex(FILE_ALREADY_EXISTS);
        }
        return isChanged;
    }

    /**
     * Transfers user's tasks to the new created file in the new directory.
     * 
     * @param newFile
     * @return isChanged
     */
    private boolean transferToNewFile(File newFile) {
        boolean isChanged;
        isChanged = makeNewDirectory(newFile);
        isChanged = createNewFile(newFile);

        String transferData = readFromExistingFile(READ_FROM_MAIN_FILE);
        setMainFilePath(newFile.getAbsolutePath());
        tasksFile = newFile;
        setAllStoredTasks(transferData);
        identifyWriteTo(transferData, WRITE_TO_MAIN_FILE);
        return isChanged;
    }

    /**
     * Converts boolean isChanged to the corresponding ResultSet.
     * 
     * @param resultSet
     * @param isChanged
     */
    private void resultSetChecker(ResultSet resultSet, boolean isChanged) {
        if (isChanged) {
            logger.log(Level.INFO, "File path changed successfully.");
            resultSet.setSuccess();
        } else {
            resultSet.setFail();
        }
    }

    /**
     * Loads tasks from an existing file specified by the user.
     * 
     * @param newFilePath directory of the new file specified by the user.
     * @return isLoaded returns true if tasks from new Main Task File is loaded,
     *         false if specified file does not exist.
     */
    public boolean loadFromExistingFile(String newFilePath) {
        boolean isLoaded = false;
        File newFile = new File(newFilePath);

        if (isExists(newFile)) {
            isLoaded = extractDataFromNewFile(newFile);
        } else {
            logger.log(Level.WARNING, "File does not exist. Loading failed.");
        }
        return isLoaded;
    }

    private boolean extractDataFromNewFile(File newFile) {
        boolean isLoaded;
        logger.log(Level.INFO, "Loading from existing file...");
        isLoaded = true;
        setMainFilePath(newFile.getAbsolutePath());
        tasksFile = newFile;
        setAllStoredTasks(readFromExistingFile(READ_FROM_MAIN_FILE));
        copyToBackUp();
        writeConfigSettings();
        return isLoaded;
    }

    // ============================================================================
    // Saving theme preference
    // ============================================================================

    /**
     * Writes the chosen theme into the Configuration File.
     * 
     * @param themeName
     * @return isWritten returns true if new theme is written to the
     *         Configuration File, false otherwise.
     */
    public boolean saveThemeName(String themeName) {
        setThemeName(themeName);
        return writeConfigSettings();
    }

    // ============================================================================
    // Logger files
    // ============================================================================

    /**
     * Initialises Logger File to store storage handling process.
     */
    private void initLogger() {
        logger = Logger.getLogger("StorageHandler");
        initFileHandler();
        logger.addHandler(fileHandler);
        fileHandler.setLevel(Level.ALL);
        logger.setLevel(Level.ALL);
        logger.config("Logger initialised.");
        logger.info("Logger name: " + logger.getName());
    }

    /**
     * Initialises File Handler for Logger File.
     */
    private void initFileHandler() {
        try {
            fileHandler = new FileHandler("StorageLogFile.log");
        } catch (SecurityException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```
###### src\storage\StorageInterface.java
``` java
 * 
 *          StorageInterface acts as a facade class for the storage component.
 */

package storage;

import java.util.ArrayList;
import java.util.Queue;

import entity.AllTaskLists;
import entity.ResultSet;
import entity.TaskEntity;

public class StorageInterface {

    private StorageController storageController;

    /**
     * Public class constructor.
     */
    public StorageInterface() {
        storageController = new StorageController();
    }

    /**
     * Retrieves all user's tasks previously saved into the Main Task File.
     * 
     * @return retrievedTaskList returns tasks read from the Main Task File.
     */
    public AllTaskLists getTaskLists() {
        return storageController.getTaskLists();
    }

    /**
     * Gets the absolute directory of the Main Task File.
     * 
     * @return mainFilePath returns a String of directory.
     */
    public String getMainFilePath() {
        return storageController.getMainFilePath();
    }

    /**
     * Takes in an AllTaskLists of the current working tasks. This method
     * returns true if all tasks are written into the Main Task File, false
     * otherwise.
     * 
     * @param allTaskLists takes in an AllTaskLists of working tasks.
     * @return isSaved returns true if all tasks are written into the Main Task
     *         File, false otherwise.
     */
    public boolean storeTaskLists(AllTaskLists allTaskLists) {
        return storageController.storeTaskLists(allTaskLists);
    }

    /**
     * Takes in main and floating ArrayLists of the current working tasks. This
     * method returns true if all tasks are written into the Main Task File,
     * false otherwise.
     * 
     * @param main takes in an ArrayList of main tasks.
     * @param floating takes in an ArrayList of floating tasks.
     * @return isSaved returns true if all tasks are written into the Main Task
     *         File, false otherwise.
     */
    public boolean storeTaskLists(ArrayList<TaskEntity> main, ArrayList<TaskEntity> floating) {
        return storageController.storeTaskLists(main, floating);
    }

    /**
     * Retrieves all tasks read from the Back Up Task File.
     * 
     * @return retrievedTaskList returns tasks read from the Back Up Task File.
     */
    public AllTaskLists getBackUpTaskLists() {
        return storageController.getBackUpTaskLists();
    }

    /**
     * Deletes the Back Up Task File for the current session.
     */
    public void deleteBackUp() {
        storageController.deleteBackUp();
    }

    /**
     * Checks if the queue size of the command queue is more than or equals to
     * the constant QUEUE_SIZE and if the UI is in Search View. This method
     * returns true if both conditions are met, and false otherwise.
     * 
     * @param command takes in one single line of user's input.
     * @return isFullQueue returns true if conditions are met, false otherwise.
     */
    public boolean saveUponFullQueue(String command) {
        return storageController.saveUponFullQueue(command);
    }

    /**
     * Returns the current command queue based on the Command File.
     * 
     * @return commandsQueue returns a Queue of previously input commands up to
     *         a constant QUEUE_SIZE of 20.
     */
    public Queue<String> getCommandsQueue() {
        return storageController.getCommandsQueue();
    }

    /**
     * Takes in a new command queue and replaces the existing command queue with
     * the new queue.
     * 
     * @param newCommandsQueue
     */
    public void setCommandsQueue(Queue<String> newCommandsQueue) {
        storageController.setCommandsQueue(newCommandsQueue);
    }

    /**
     * Clears the Command File when the changes are committed to the Main Task
     * File.
     */
    public void clearCommandFileOnCommit() {
        storageController.clearCommandFileOnCommit();
    }

    /**
     * Clears the Command File Upon proper 'Exit'.
     */
    public void clearCommandFile() {
        storageController.clearCommandFile();
    }

    /**
     * Takes in a file path for the new saving location of the Main Task File.
     * This method returns a ResultSet to indicate the success or failure of
     * changing the directory. -1 will be returned if an existing file is found.
     * If the changing of directory is successful, the new directory will be
     * saved to the Configuration File.
     * 
     * @param newFilePath
     * @return resultSet
     */
    public ResultSet saveTo(String newFilePath) {
        return storageController.saveToNewDirectory(newFilePath);
    }

    /**
     * Loads user's tasks from the specified file path. This method returns true
     * if a file is found, false otherwise. It also updates the Configuration
     * File with the new directory of the Main Task File.
     * 
     * @param newFilePath
     * @return isFileExists
     */
    public boolean loadFrom(String newFilePath) {
        return storageController.loadFromSpecifiedFile(newFilePath);
    }

    /**
     * Writes the chosen theme preference into the Configuration File. Returns
     * true if the changes are successfully updated into the Configuration File,
     * false otherwise.
     * 
     * @param themeName
     * @return isWritten returns true if the changes are written into the
     *         Configuration File, false otherwise.
     */
    public boolean saveThemePreference(String themeName) {
        return storageController.saveThemePreference(themeName);
    }

    /**
     * Returns the name of the preferred theme, previously read from the
     * Configuration File.
     * 
     * @return themeName returns a String theme name.
     */
    public String getThemePreference() {
        return storageController.getThemePreference();
    }
}
```
###### src\test\storage\JUnitStorage.java
``` java
 */

package test.storage;

import static org.junit.Assert.assertEquals;

import java.io.File;
import java.util.ArrayList;
import java.util.Queue;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import entity.AllTaskLists;
import entity.TaskEntity;
import logic.TaskUtils;
import storage.JsonConverter;
import storage.StorageHandler;

public class JUnitStorage {

    private ArrayList<TaskEntity> mainTasks;
    private ArrayList<TaskEntity> floatingTasks;
    private AllTaskLists allLists;
    private StorageHandler sh;

    private static final int READ_FROM_CONFIG_FILE = 1;
    private static final int READ_FROM_MAIN_FILE = 2;
    private static final int WRITE_TO_MAIN_FILE = 2;

    @Before
    public void init() {
        mainTasks = new ArrayList<TaskEntity>();
        floatingTasks = new ArrayList<TaskEntity>();
        sh = new StorageHandler();
    }

    @Test
    public void testStorage_addDummyTasks() {
        mainTasks.add(new TaskEntity("mainTaskOne", null, TaskUtils.createDate(9, 4, 2016), true));
        floatingTasks.add(new TaskEntity("floatingTaskOne"));

        assertEquals(mainTasks.size(), 1);
        assertEquals(floatingTasks.size(), 1);

        allLists = new AllTaskLists(mainTasks, floatingTasks);
    }

    @Test
    public void testStorage_convertJavaToJsonAndBack_conversionSuccessful() {
        JsonConverter jc = new JsonConverter();

        testStorage_addDummyTasks();
        String allListsJson = jc.javaToJson(allLists);
        AllTaskLists convertedFromJson = jc.jsonToJava(allListsJson);

        assertEquals(allLists.equals(convertedFromJson), convertedFromJson.equals(allLists));
    }

    @Test
    public void testStorage_convertJsonToJava_conversionUnsuccessful_nullExpected() {
        JsonConverter jc = new JsonConverter();
        AllTaskLists invalidConversion = jc.jsonToJava("Non-Json String");

        assertEquals(invalidConversion, null);
    }

    @Test
    public void testStorage_initFiles_successful() {
        File configFile = new File("configFile.txt");
        File mainTasksFile = new File("mainTasksFile.txt");
        File backUpTasksFile = new File("backUpTasksFile.txt");
        File commandsFile = new File("commandsFile.txt");

        configFile.exists();
        mainTasksFile.exists();
        backUpTasksFile.exists();
        commandsFile.exists();
    }

    @Test
    public void testStorage_readConfigFile_defaultFilePathAndThemeExpected() {
        String setting = sh.readFromExistingFile(READ_FROM_CONFIG_FILE);
        String[] settingSplit = setting.split("\n");
        String mainFilePathConfig = settingSplit[0];
        String defaultThemeConfig = settingSplit[1];

        File mainFile = new File("mainTasksFile.txt");
        String mainFilePathGet = mainFile.getAbsolutePath();

        assertEquals(mainFilePathConfig, mainFilePathGet);
        assertEquals(defaultThemeConfig, "default");
    }

    @Test
    public void testStorage_readAndWriteMainFile_successful() {
        String toBeWritten = "Write a random string.";
        boolean isWritten = sh.identifyWriteTo(toBeWritten, WRITE_TO_MAIN_FILE);
        assertEquals(isWritten, true);

        String readFromFile = sh.readFromExistingFile(READ_FROM_MAIN_FILE);
        assertEquals(toBeWritten, readFromFile);
    }

    @Test
    public void testStorage_readAndWriteCommandFile_successfullyAppended() {
        String commandOne = "Add commandOne";
        boolean isWritten = sh.writeToCommandFile(commandOne);
        assertEquals(isWritten, true);

        String commandTwo = "Add commandTwo";
        isWritten = sh.writeToCommandFile(commandTwo);
        assertEquals(isWritten, true);

        Queue<String> readFromFile = sh.readFromExistingCommandFile();
        assertEquals(readFromFile.toString(), "[" + commandOne + ", " + commandTwo + "]");
    }

    @Test
    public void testStorage_saveToNewDirectory_successful() {
        sh.changeDirectory("newMainTasksFile.txt");
        File newFile = new File("newMainTasksFile.txt");

        assertEquals(sh.getMainFilePath(), newFile.getAbsolutePath());
    }

    @Test
    public void testStorage_loadFromExistingFile_fileExists_successful() {
        testStorage_saveToNewDirectory_successful();

        sh.loadFromExistingFile("mainTasksFile.txt");
        File newFile = new File("mainTasksFile.txt");

        assertEquals(newFile.exists(), true);
        assertEquals(sh.getMainFilePath(), newFile.getAbsolutePath());
    }

    @Test
    public void testStorage_loadFromExistingFile_fileDoesNotExist_unsuccessful() {
        boolean isLoaded = sh.loadFromExistingFile("invalidFile.txt");
        File newFile = new File("invalidFile.txt");

        assertEquals(newFile.exists(), false);
        assertEquals(isLoaded, false);
    }

    @After
    public void cleanUp() {
        File configFile = new File("configFile.txt");
        File mainTasksFile = new File("mainTasksFile.txt");
        File backUpTasksFile = new File("backUpTasksFile.txt");
        File commandsFile = new File("commandsFile.txt");
        File newMainTasksFile = new File("newMainTasksFile.txt");

        configFile.delete();
        mainTasksFile.delete();
        backUpTasksFile.delete();
        commandsFile.delete();
        newMainTasksFile.delete();
    }
}
```
###### target\classes\pastel.css
``` css
.cssLabels,.cssLabelsDescription,.cssLabelsDetails,.cssLabelsFloatingBar,.cssLabelsFloatingTaskInterface,
.cssLabelsSearchView, .cssLabelsCommandBar {
	-fx-text-fill:rgba(0.0,0.0,0.0,1.0);
	-fx-fill:rgba(0.0,0.0,0.0,1.0);
}

#cssCommandMainUserInput {
    -fx-background-color: -fx-control-inner-background;
    -fx-font: 12.0px "Arial";
}

#commandText {
	-fx-font: 12.0px "Arial";
}

/* Help Screen */
#cssHelpScreenRoot {
	-fx-background-color: rgba(255.0,255.0,255.0,0.5);
}

#cssHelpComponentHighLighter {
	-fx-background-color: rgba(0.0,0.0,0.0,0.1);
	-fx-border-width: 1.0; 
	-fx-border-color: black;
}

#cssHelpComponentLinker {
	-fx-background-color: rgba(0.0,0.0,0.0,1.0);
}

#cssHelpComponentDescriptionBox {
	-fx-background-color: rgba(255.0,255.0,255.0,1.0);
	-fx-border-width: 1.0; 
	-fx-border-color: black;
}

#cssHelpTitle {
	-fx-text-fill: rgba(240.0,180.0,50.0,1.0);
	-fx-border-width: 0.0 0.0 1.0 0.0; 
	-fx-border-color: black;
}


#rootPane {
	-fx-border-color: #d3d3d3;
    -fx-border-width: 2.0px;
}

.controlFocus {
	-fx-border-color: #FF00FF;
	-fx-border-width: 2.0px;
}

/* css Task view  */
#cssTaskViewMainBackground {
	-fx-background-color: rgba(255.0,255.0,255.0,0.9);
}

#cssTaskViewWeekSelected {
	-fx-background-color: rgba(219.0,190.0,248.0,0.95);
}

#cssTaskViewWeekUnSelected {
	-fx-background-color: rgba(248.0,190.0,248.0,0.5);
}

#cssTaskViewDayBoxSelected {
}

#cssTaskViewDayBoxUnSelected {	
}

#cssTaskViewSelectedTask {
	-fx-background-radius: 20.0; 
	-fx-background-color:  rgba(255.0, 255.0, 255.0, 1.0);
	-fx-background-insets: 1.0 5.0 1.0 5.0;
}

#cssTaskViewUnSelectedTask {
}

#cssTaskViewDayLabel {
	-fx-border-width: 0.0 0.0 1.0 0.0; 
	-fx-border-color: black;
}

/* css expanded panel */
#cssExpandedViewVBox {
	-fx-background-color: rgba(255.0,255.0,255.0,0.9);
	-fx-background-radius: 7.0;
	-fx-background-insets: 0.0 5.0 0.0 5.0;
}

#cssExpandedViewVBoxSelected {
	-fx-background-color: rgba(248.0,190.0,248.0,0.9);
	-fx-background-radius: 7.0;
	-fx-background-insets: 0.0 5.0 0.0 5.0;
}

/* css description panel */
#cssRootDescriptionViewMainBackground {
	-fx-background-color: rgba(255.0,255.0,255.0,0.9);
}

#cssDescriptionLabelSelected {
	-fx-background-color: rgba(255, 122, 137, 1.0);
}

#cssDescriptionLabelUnSelected {
	-fx-background-color: rgba(255.0,255.0,255.0,0.3);
}

/* Detail Componenet CSS */
#cssDetailComponentRoot {
	-fx-background-color: rgba(122.0,137.0,255.0,0.7),rgba(255.0,255.0,255.0,0.95);
}

#cssDetailComponentRootAssociation {
	-fx-background-color: rgba(203.0,203,250,1),rgba(255.0,255.0,255.0,0.7),rgba(193.0,230.0,255.0,0.95);
	-fx-background-insets: 0,2,2;
}

#cssDetailComponentEmptyTitle {
	-fx-background-color: rgba(255, 122, 137, 1.0);
}

#cssDetailComponentProjectHeadBox {
	-fx-background-color: rgba(255.0,255.0,255.0,0.95);
}

#cssDetailAssociationListBox {
	-fx-background-color: rgba(255.0,255.0,255.0,0.0);
	-fx-background-insets: 0.0 0.0 0.0 0.0;
}


/* Floating Bar CSS */
#cssRootFloatingBar {
	-fx-background-color: rgba(213, 21, 117, 0.4), rgba(255.0,255.0,255.0,0.7);
	-fx-background-insets: 0.0,0.0 10.0 0.0 10.0;
}

#cssFloatingBarContentArea {
	-fx-border-width: 0.0 0.0 0.0 1.0; 
	-fx-border-color: black;
}

#cssFloatingBarTitleLabel {
}

/* Floating Task View CSS */
#cssRootFloatingTaskView {
	-fx-background-color: rgba(213, 21, 117, 0.4),rgba(255.0,255.0,255.0,1.0);
	-fx-background-insets: 0.0,5.0;
}

#cssFloatingTaskViewTitle {
	-fx-background-color: rgba(255, 122, 137, 1.0);
}

#cssFloatingTaskViewSelected {
	-fx-background-radius: 20.0; 
	-fx-background-color:  rgba(255.0,178.5,127.5,0.3);
	-fx-background-insets: 1.0 7.0 1.0 7.0;
}

/* Search View CSS */
#cssRootSearchView {
	-fx-background-color: rgba(21, 213, 213, 0.4),rgba(255.0,255.0,255.0,1.0);
	-fx-background-insets: 0.0,5.0;
}

#cssSearchTitle {
	-fx-background-color: rgba(21, 213, 213, 0.4);
}

#cssSearchSelected {
	-fx-background-color: rgba(191.0, 80.0, 191.0,0.3);
	-fx-background-radius: 20.0; 
	-fx-background-insets: 1.0 7.0 1.0 7.0;
}

/* CommandsBar CSS */
#cssCommandBarMainStructure {
	-fx-background-color: rgba(255.0,255.0,255.0,0.8);
}

#cssCommandBarContentZone {
	-fx-border-width: 1.0 0.0 1.0 0.0; 
	-fx-border-color: black;
}


#cssCommandBarfeedback_normal {
	-fx-background-color: rgba(179.0, 255.0, 153.0, 1.0);
}

#cssCommandBarfeedback_conflict {
	-fx-background-color: rgba(249.0, 186.0, 122.0, 1.0);
}

#cssCommandBarfeedback_past {
	-fx-background-color: rgba(246.0, 246.0, 39.0, 1.0);
}

#cssCommandBarfeedback_conflict_past {
	-fx-background-color: rgba(180.0, 251.0, 212.0, 1.0);
}

#cssCommandBarfeedback_error {
	-fx-background-color: rgba(249.0, 122.0, 122.0,1.0);
}

/* Commands CSS */
#cssCommandBarAdd {
	-fx-background-color: rgba(72.0, 238.0, 56.0, 1.0);
	-fx-font-weight: bold;
	-fx-background-radius: 7.0; 
}

#cssCommandBarInvalid {
	-fx-text-fill: rgba(255.0,0.0,0.0,1.0);
}

#cssCommandBarDelete {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(56.0, 238.0, 223.0, 1.0);
	-fx-font-weight: bold;
	-fx-background-radius: 7.0; 
}

#cssCommandBarEdit {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(56.0, 163.0, 238.0, 0.5);
	-fx-font-weight: bold;
	-fx-background-radius: 7.0; 
}

#cssCommandBarLink {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(163.0, 238.0, 56.0, 1.0);
	-fx-font-weight: bold;
	-fx-background-radius: 7.0; 
}

#cssCommandBarDone {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(238.0, 132.0, 56.0, 1.0);
	-fx-font-weight: bold;
	-fx-background-radius: 7.0; 
}

#cssCommandTitle {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(202.0, 247.0, 140.0, 1.0);
	-fx-background-radius: 7.0; 
}

#cssCommandDate {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(247.0, 140.0, 149.0, 1.0);
	-fx-background-radius: 7.0; 
}

#cssCommandHashTag {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(247.0, 238.0, 140.0, 1.0);
	-fx-background-radius: 7.0; 
}

#cssCommandID {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(247.0, 184.0, 140.0, 1.0);
	-fx-background-radius: 7.0; 
}
#cssCommandDescription {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(140.0, 202.0, 247.0, 1.0);
	-fx-background-radius: 7.0; 
}

#cssCommandJump {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(238.0, 56.0, 163.0, 1.0);
	-fx-font-weight: bold;
	-fx-background-radius: 7.0; 
}

#cssCommandSearch {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(132.0, 56.0, 238.0, 1.0);
	-fx-font-weight: bold;
	-fx-background-radius: 7.0; 
}

#cssCommandExit {
	-fx-text-fill: white;
	-fx-background-color: rgba(238.0, 56.0, 72.0, 1.0);
	-fx-font-weight: bold;
	 -fx-font: 20.0px "Arial";
}

#cssCommandFloat {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(238.0, 132.0, 56.0, 1.0);
	-fx-font-weight: bold;
	-fx-background-radius: 7.0; 
}

#cssCommandShow {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(223.0, 56.0, 238.0, 1.0);
	-fx-font-weight: bold;
	-fx-background-radius: 7.0; 
}

#cssCommandHide {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(223.0, 56.0, 238.0, 1.0);
	-fx-font-weight: bold;
	-fx-background-radius: 7.0; 
}

#cssCommandMain {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(238.0, 56.0, 163.0, 1.0);
	-fx-font-weight: bold;
	-fx-background-radius: 7.0; 

}
 
#cssCommandSaveDir {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(183.0, 220.0, 40.0, 1.0);
	-fx-font-weight: bold;
	-fx-background-radius: 7.0; 
}

#cssCommandUndo {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(240.0, 180.0, 20.0, 1.0);
	-fx-font-weight: bold;
	-fx-background-radius: 7.0; 
}

#cssCommandOther {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
}

#cssCommandTheme {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(238.0, 120.0, 163.0, 1.0);
	-fx-font-weight: bold;
	-fx-background-radius: 7.0; 
}

#cssCommandLoadFrom {
	-fx-text-fill: rgba(0.0,0.0,0.0,1.0);
	-fx-background-color: rgba(183.0, 220.0, 40.0, 1.0);
	-fx-font-weight: bold;
	-fx-background-radius: 7.0; 
}
```
